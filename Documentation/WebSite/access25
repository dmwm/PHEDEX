#!/usr/bin/env perl

our $TESTING = 0;
our $TESTING_MAIL = undef;
our $DBS_LOOKUP = undef;

use CMSWebTools::SecurityModule::Oracle;
use PHEDEX::Core::SQL;

######################################################################
package Web25::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape);
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} || "./"; $__scriptdir =~ s,[^/]+$,,; unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(urlencode dblink toclink pagelink
		 alert warning breakAtSlash note help
		 age format_num format_percent format_size format_timespan shorten
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec dbinlist makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue
		 auth_help_msg auth_help_warning auth_help_popup
		 fetch_nodes fetch_groups fetch_dbses fetch_identity
                 send_email dn_to_human_name
		 yesno striplabels
		 dump_params dump_var
		 parse_userdata dbs_lookup resolve_data fetch_replicas
);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web25:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff, $precision) = @_;
  $precision = 'minute' if !defined $precision;
  if (! grep ($precision eq $_, qw(second minute)) ) {
      die "Bad args to age()\n";
  }

  my $str = "";
  my $full = 0;

  if ($precision ne 'minute' &&  abs($diff) <= 3600) {
      $str .= sprintf("%dm", $diff / 60);
      $diff %= 60;
      $str .=  sprintf("%02d", $diff);
      return $str;
  }

  if (abs($diff) >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
    $full = 1;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  return unless $val;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&\#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate hide/show help
sub help
{
    my ($linktext, $helpsubject, @help) = @_;
    my $id = 'help'.rand();
    my @ret = ("<a class='help' href='#' onclick='return hideshow(this,\"$id\",0)'>$linktext</a>",
	       "<div id='$id' style='display:none' class='help'>",
	       "<a href='#' class='closelink' onclick='return hideshow(this, \"$id\", 0)'>[close]</a>",
	       "<p class='title'>$helpsubject</p>",
	       "<p class='body'>",
	       @help,
	       "</p>",
	       "</div>");
    return wantarray ? @ret : join '', @ret;
}


# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format number as percent.  Zero is converted into a dash.
sub format_percent
{
  my ($n) = @_;
  return $n ? sprintf("%.1f %%", $n*100) : '&#8211;';
}


# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  return undef if (!defined $bytes && $nodash);

  my @bounds = ([ 2**10, 'k' ], [ 2**20, 'M' ], [ 2**30, 'G' ],
		[ 2**40, 'T' ], [ 2**50, 'P' ], [ 2**60, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    undef $minscale if (defined $minscale && $minscale eq $unit);
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f %sB", $minus, $val, $unit)
    : '&#8211;';
}

# Returns a clipped version of a long string with a toggle control to expand the string
sub shorten {
    my ($tag, $id, $width, $string) = @_;
    return $string;  #TODO:  Actually get this working.
    my $uniq_id = $tag.'_'.$id;
    my $twidth = $width+2;
    return "<div id='$uniq_id' style='width:${twidth}em' class='short'><span class='short' style='width:${width}em;'>$string</span>".
	"<a class='shorttoggle' href='#' onclick='return shortlong(this,\"$uniq_id\",${width})'>...</a></div>";
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Retrun an sql fragment and a bind hash for an SQL "IN" list
sub dbinlist
{
    my ($prefix, @binds) = @_;
    my $in_list = join(', ', map { ":${prefix}_".($_+1) } (0..$#binds));                                                            
    my %in_binds = map { (":${prefix}_".($_+1) => $binds[$_]) } (0..$#binds); 
    return $in_list, %in_binds;
}


# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;

  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :Id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

# Print a help message about authentication requirements
# Takes a hash of $power => [@requirements]
# The first entry of @requirements should be the authentication level,
# the rest are the required roles for $power
sub auth_help_msg 
{
    my ($self, %powers) = @_;

    my $cert_login_url = $self->myurl("secure" => 1);
    my $passwd_login_url = $self->myurl("secure" => 1, "SecModPwd" => 1);

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';
    my $contact_mail = "mailto:$$self{CONFIG}{FEEDBACK_MAIL}";

    my %auth_words = ( 'cert' => 'grid certificate authentication',
		       'passwd' => 'password authentication',
		       'anyauth' => 'to log in via grid certificate or password');
    my $msg = '';
    my %help;
    sub or_list {
	my $last = pop @_;
	return join(', ', @_)." or $last";
    }

    foreach my $power (keys %powers) {
	my @requirements = @{$powers{$power}};
	my $auth_level = shift @requirements;
	$help{$auth_level} = 1;
	$msg .= "You need <b>$auth_words{$auth_level}</b>";
	if (@requirements) {
	    @requirements = map { "<b>'$_'</b>" } @requirements;
	    $help{'sitedb'} = 1;
	    $msg .= ' and to be a '.&or_list(@requirements);
	}
	$msg .= " in order to $power.<br/>  ";
    }
    $msg .= "<br/>";

    if (exists $help{'passwd'} || exists $help{'anyauth'}) {
	$msg .= "Passwords are managed via <a href='$sitedb_url'>SiteDB</a> ".
	    "and are synced with the CMS hypernews passwords.  ";
    }

    if (exists $help{'cert'} || exists $help{'anyauth'}) {
	$msg .= "You can go <a href='$gridcert_help_url'>here</a> to find help on obtaining a grid certificate.  ";
    }

    if (exists $help{'sitedb'}) {
	$msg .= "Authorization roles are handled by <a href='$sitedb_url'>SiteDB.</a> ";
    }

    my $login_msg;
    if (exists $help{'anyauth'} || (exists $help{'cert'} && exists $help{'passwd'})) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a> ".
	    "or <a href='$passwd_login_url'>password</a>";
    } elsif (exists $help{'cert'}) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a>";
    } else {
	$login_msg = "logged in <a href='$passwd_login_url'>with your password</a>";
    }

    $msg .= "If you think you have the necessary rights in SiteDB ".
	"and are $login_msg but you are still ".
	"having problems with this page you may <a href='$contact_mail'>contact the PhEDEx developers</a>.  ";

    return $msg;
}

sub auth_help_popup 
{
    my ($self, %powers) = @_;
    print {$$self{CONTENT}} &help('Privilaged Activities Help', 'Privilaged Activities', $self->auth_help_msg(%powers), "<br/>");
}

sub auth_help_warning
{
    my ($self, %powers) = @_;
    $self->warning($self->auth_help_msg(%powers));
}


# Returns a list of nodes.
# If argument 'with_ids' is true, returns a hash of node_name => node_id
# else it returns an array of nodes
#
# If web_user_auth is set with the name of some role (e.g. 'Data
# Manager'), we check the security module to find out if the user has
# that role, find out for which sites they have that role, and return
# a list of nodes associated with those sites.
#
# web_user_auth can be set with multiple roles separated by '||', for
# which all authorized nodes among those roles will be returned.
# (e.g. web_user_auth => 'Data Manager||Site Admin')
#
# The role 'Admin' need not be specified in web_user_auth.  If
# the user is a Admin then all nodes are always returned.
#
# Otherwise it returns from t_adm_node table, which contains all nodes.
# The default behavior is to return an array of all nodes from t_adm_node.
sub fetch_nodes
{
    my ($self, %args) = @_;

    my @auth_nodes;
    if (exists $args{web_user_auth} && $args{web_user_auth}) {
	my $roles = $$self{SECMOD}->getRoles();
	my @to_check = split /\|\|/, $args{web_user_auth};
	my $roles_ok = 0;
	foreach my $role (@to_check) {
	    if (grep $role eq $_, keys %{$roles}) {
		$roles_ok = 1;
	    }
	}

	my $global_admin = (exists $$roles{'Admin'} &&
			    grep $_ eq 'phedex', @{$$roles{'Admin'}}) || 0;

	# Special "global admin" role only if explicitly specified
	$global_admin = 1 if (grep($_ eq 'PADA Admin', @to_check) &&
			      exists $$roles{'PADA Admin'} &&
			      grep($_ eq 'phedex', @{$$roles{'PADA Admin'}}));

	return unless ($roles && ($roles_ok || $global_admin));
	
	# If the user is not a global admin, make a list of sites and
	# nodes they are authorized for.  If they are a global admin
	# we continue below where all nodes will be returned.
	if (!$global_admin) {
	    my %node_map = $$self{SECMOD}->getPhedexNodeToSiteMap();
	    my %auth_sites;
	    foreach my $role (@to_check) {
		if (exists $$roles{$role}) {
		    foreach my $site (@{$$roles{$role}}) {
			$auth_sites{$site} = 1;
		    }
		}
	    }
	    foreach my $node (keys %node_map) {
		foreach my $site (keys %auth_sites) {
		    push @auth_nodes, $node if $node_map{$node} eq $site;
		}
	    }
	}
    }

    my $sql = qq{select name, id from t_adm_node where name not like 'X%'};
    my $q = &dbexec($$self{DBH}, $sql);
    
    my %nodes;
    while (my ($node, $node_id) = $q->fetchrow()) {
	# Filter by auth_nodes if there are any
	if (!@auth_nodes || grep $node eq $_, @auth_nodes) {
	    $nodes{$node} = $node_id;
	}
    }
    if (exists $args{with_ids} && $args{with_ids}) {
	return %nodes;
    } else {
	return keys %nodes;
    }
}


# Returns a list of groups.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_groups
{
    my ($self, %args) = @_;
    my %groups;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_adm_group});
    while (my ($group, $group_id) = $q->fetchrow()) {
	$groups{$group} = $group_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %groups;
    } else {
	return keys %groups;
    }
}

# Returns a list of DBSes.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_dbses
{
    my ($self, %args) = @_;

    my %dbses;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_dps_dbs});
    while (my ($dbs, $dbs_id) = $q->fetchrow()) {
	$dbses{$dbs} = $dbs_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %dbses;
    } else {
	return keys %dbses;
    }
}


# Tries to resolve the user's identity and returns it.  Also logs the
# identity to the t_adm_identity table, if it is not already there.
# Note:  does not commit this logging activity, this is left to the function caller
sub fetch_identity
{
    my ($self, $secmodUser) = @_;

    my $id = {};
    my @to_sync;

    if (! $secmodUser ) {
	if (! $$self{SECMOD}->isAuthenticated() ) { return; }

	$$id{SECMOD_ID} = $$self{SECMOD}->getID();
	$$id{NAME} = $$self{SECMOD}->getForename() .' '. $$self{SECMOD}->getSurname();
	$$id{EMAIL} = $$self{SECMOD}->getEmail();

	if ($$self{SECMOD}->isCertAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL DN CERTIFICATE);
	    $$id{DN} = $$self{SECMOD}->getDN();
	    $$id{CERTIFICATE} = $$self{SECMOD}->getCert();
	} elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
	    @to_sync = qw(SECMOD_ID NAME EMAIL USERNAME);
	    $$id{USERNAME} = $$self{SECMOD}->getUsername();
	}
    } else {
	$$id{SECMOD_ID} = $$secmodUser{ID};
	$$id{NAME} = $$secmodUser{FORENAME} .' '. $$secmodUser{SURNAME};
	$$id{EMAIL} = $$secmodUser{EMAIL};
	$$id{DN} = $$secmodUser{DN};
	$$id{USERNAME} = $$secmodUser{USERNAME};
	@to_sync = qw(SECMOD_ID NAME EMAIL DN USERNAME);
    }
    my $now = time();

    # Look up a logged identity by either the SecurityModule ID or the DN
    my $q = &dbexec($$self{DBH},
		    qq{ select id, secmod_id, name, email, dn, certificate, username
			    from t_adm_identity where secmod_id = :secmod_id or dn = :dn
			    order by time_update desc },
		    ':secmod_id' => $$id{SECMOD_ID},
		    ':dn' => ($$id{DN} || 'dummy')
		    );

    my $logged_id = $q->fetchrow_hashref();

    my $synced = ($logged_id ? 1 : 0);
    foreach my $param (@to_sync) {
	last if !$synced;
	no warnings;  # we need to compare undef values too
	$synced &&= $$logged_id{$param} eq $$id{$param};
    }

    if ($logged_id && $synced) {
	# If everything is logged and up-to-date, return the identity information
	return $logged_id;
    } elsif ($logged_id && !$synced) {
	# If it is logged, but out of date, update it then return the information by recursing
	my $sql = qq{ update t_adm_identity set };
	my @params = map { "$_ = :$_" } (@to_sync, "TIME_UPDATE");
	$sql .= join(', ', @params);
	$sql .= qq{ where id = :id };
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;
	$binds{':ID'} = $$logged_id{ID};

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    } else {
	# If it is not logged, log it then recurse
	my $sql = qq{ insert into t_adm_identity };
	$sql .= '('.join(', ', "ID", @to_sync, "TIME_UPDATE").') ';
	$sql .= 'values ('.join(', ', "seq_adm_identity.nextval", map { ":$_" } (@to_sync,'TIME_UPDATE')).')';
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    }
}

sub send_email
{
    my (%args) = @_;

    # Required arguments
    foreach (qw(subject from to message)) {
	return 0 unless exists $args{$_};
    }

    # Make to and cc arrays unique
    foreach (qw(to cc)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    my %unique;
	    $unique{$_} = 1 foreach @{$args{$_}};
	    $args{$_} = [keys %unique];
	}
    }

    # Ensure names are not duplicated from to to cc
    if (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	&& ref $args{to} eq 'ARRAY') {
	my @uniquecc;
	foreach my $mail (@{$args{cc}}) {
	    push @uniquecc, $mail unless grep $_ eq $mail, @{$args{to}};	    
	}
	$args{cc} = [ @uniquecc ];
    } elsif (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	     && ref $args{to} ne 'ARRAY') {
	$args{cc} = [ grep $_ ne $args{to}, @{$args{cc}} ];
    } elsif (exists $args{cc}
	     && ref $args{to} eq 'ARRAY') {
	delete $args{cc} if grep $_ eq $args{cc}, @{$args{to}};
    } elsif (exists $args{cc}) {
	delete $args{cc} if $args{cc} eq $args{to};
    }
    
    foreach (qw(from to cc replyto)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    $args{$_} = join(', ', @{$args{$_}});
	} elsif ( exists $args{$_} && ! $args{$_} ) {
	    $args{$_} = '';
	}
    }
    
    foreach (qw(from to cc replyto)) {
	next unless exists $args{$_};
	return 0 unless &validlist($args{$_});
    }

    # For debugging without bothering people
    if ($TESTING) {
	$args{subject} = "TESTING:  $args{subject}";
	$args{message} .= "\n\nTO:  $args{to}\n\n"; $args{to} = $TESTING_MAIL;
	if ($args{cc}) {$args{message} .= "\n\nCC:  $args{cc}\n\n"; delete $args{cc};}
    }

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
 	 "Subject: $args{subject}\n",
 	 "From: $args{from}\n",
 	 (exists $args{replyto} ? "Reply-To:  $args{replyto}\n" : ''),
 	 "To: $args{to}\n",
 	 (exists $args{cc} ? "Cc: $args{cc}\n" : ''),
 	 "\n",
 	 $args{message},
 	 "\n" )
     && close(MAIL))
 	or do { return 0; };
    
    return %args;
}



sub dn_to_human_name
{
    my $dn = shift @_;
    return undef unless $dn;
    my @names = ($dn =~ m:/CN=([^/]+?)[\s\d]*(/|$):g);
    my $name = $names[0];
    foreach (@names) {
      $name = $_ if length $_ > length $name;
    }
    $name =~ s/\b(\w)/\U$1/g;
    return $name;
}


    
sub yesno 
{ 
    $_ = shift @_;
    return undef unless $_;
    s/^y$/Yes/; s/^n$/No/; 
    return $_; 
}



sub striplabels 
{ 
    my @stripped =  map { s:<[/]*label>::g; $_; } @_; 
    return wantarray ? @stripped : shift @stripped;
}



sub dump_params
{
    my $fh = shift @_;
    use Data::Dumper;
    print { $fh } "<pre>$_:\n", Dumper(param($_)), "</pre>" foreach param();

}


sub dump_var
{
    my ($fh, $name, $var) = @_;
    my $out = Dumper($var);
    $out =~ s/\n//g;
    print { $fh } "<pre>$name:\n", Dumper($var), "</pre>";
}


# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  return undef unless ($time && $range);
  return undef if ($time <= 0);
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
  elsif ($range eq 'stamp') { return strftime ('%Y-%m-%d %H:%M:%S UTC', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		 'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

# Takes an array of user data clobs and parses out single dataset and block globs
# Returns a hash of key:  glob pattern value: item type (DATASET or BLOCK)
sub parse_userdata
{
    my ($self, @userdata) = @_;
    my %parsed;
    foreach my $string (@userdata) {
	$string =~ s/^\s+//;  $string =~ s/\s+$//;
	my @data = split(/\s+/, $string);
	foreach my $item (@data) {
	    if ($item =~ m<^/[^/]+/[^/]+(/[^/]+|\#[^\#]+)$>) {
		$parsed{$item} = ($1 =~ /\#/ ? 'BLOCK' : 'DATASET');
	    } else {
		$parsed{$item} = undef;
	    }
	}
    }
    return %parsed;
}

sub dbs_lookup
{
    my ($dbs, $pattern) = @_;

    ### Security:  Strict list of characters allowed to go to shell
    my $reg = qr/[^\w\.\*\-\#\/\?=:\+\&]/;
    foreach (@_) {
	if (/$reg/) {
	    die "Invalid string '$_' given to dbs_lookup()";
	}
    }
        
    if ($dbs =~ /^https/) {
	# remove secure connection
	$dbs =~ s/^https/http/;
	$dbs =~ s|:\d+/|/|;
	$dbs =~ s/_writer//;
    }

    my $dbslookup = $DBS_LOOKUP || '/bin/false';
    my $dbscmd = "$dbslookup -u '$dbs' -d '$pattern'";
    my $dbsresults = `$dbscmd`;
    warn "DBSLookup results:  ", $dbsresults, "\n" if $TESTING;

    my @paths;
    if ($dbsresults) {
	foreach (split "\n", $dbsresults) {
	    push @paths, $_ if /^\//;
	}
    }
    return @paths;
}



# Resolve user datasets;  Search DPS and DBS for glob patterns
# Fill data object with results:
# $$resolved{$userglob} = [ { params }, ... ]
# Where { params } contains:
#   DBS = dbs the data was found in PhEDEx, not necessarily the one the user specified
#   LEVEL = 'BLOCK' or  'DATASET'
#   DATASET = Dataset name
#   BLOCK = Block name.  undef if LEVEL = DATASET
#   ID = The dps unique id for item
#   FILES = Number of files
#   BYTES = Data size
#   DPS_ISKNOWN = 'y' or 'n'
#   DBS_ISKNOWN = 'y' or 'n'
sub resolve_data
{
    my ($dbh, $userdbs, $static, @userdata) = @_;

    my $resolved = {};
    my $userdupes = {};
    my $dbsdupes = {};
    my $all = {};

    foreach my $level (qw(DATASET BLOCK)) {
	$$all{$level} = [];
    }

    # We assume the user is giving us wildcard searches
    # So first we turn the wildcard searches into compiled regexps and
    # SQL like patterns
    my %has = ( DATASET => 0, BLOCK => 0);
    my %userglob_re;
    my %userglob_like = ( DATASET => [], BLOCK => [] );
    foreach my $userglob (@userdata) {
	$$resolved{$userglob} ||= [];

	my $level = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
	$has{$level}++;

	my $re = $userglob;
	$re =~ s:\*+:[^/\#]+:g;                              # simple glob to regex, only * is supported
	$re .= '#[^/\#]+' if $static && $level eq 'DATASET'; # turn dataset match into block match if static
	$userglob_re{$userglob} = qr(^$re$);                 # compile regexp

	my $like = $userglob;
	$like =~ s:\*+:%:g;                                  # glob to sql like, only * is supported
	push @{$userglob_like{$level}}, $like;
    }

    # Now we look for matching data in TMDB using the SQL like patterns
    # We order by ID so we can check for redundant DBS items later
    my $all_items = {};
    if ($has{DATASET} && !$static) {
	my %binds;
	my $ds_lookup = $userglob_like{DATASET};

	my $sql =  qq{
	   select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset,
                  nvl(sum(b.files),0) files, nvl(sum(b.bytes),0) bytes
	     from t_dps_dataset ds
   	     join t_dps_dbs dbs on dbs.id = ds.dbs
             left join t_dps_block b on b.dataset = ds.id
	 }
	. 'where ('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'ds.name', @$ds_lookup).')'
        . qq{ group by dbs.id, dbs.name, ds.id, ds.name
	      order by ds.id };
	
	$all_items->{DATASET} = &dbexec($dbh, $sql, %binds)->fetchall_arrayref({});
    }
    
    if ($has{BLOCK} || ($has{DATASET} && $static)) {
	my %binds;
	my $b_lookup = $userglob_like{BLOCK};
	my $ds_lookup = $userglob_like{DATASET};

	my $sql = qq{
	   select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset,
	          b.id block_id, b.name block, b.files, b.bytes
	     from t_dps_block b
	     join t_dps_dataset ds on b.dataset = ds.id
	     join t_dps_dbs dbs on ds.dbs = dbs.id
            where
	};

	my @filters;
	if ($has{BLOCK}) {
	    push @filters,
	    '('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'b.name', @$b_lookup).')';
	}
	if ($has{DATASET} && $static) {
	    push @filters,
	    '('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'ds.name', @$ds_lookup).')';
	}

	$sql .= join ' or ', @filters;
	$sql .= " and b.is_open = 'n'";
	$sql .= ' order by b.id';

	$all_items->{BLOCK} = &dbexec($dbh, $sql, %binds)->fetchall_arrayref({});
    }

    # Now we go through all the data we just found and use the regexps
    # patterns we made to find what data matched what user request.
    # We need to do this because we want to be able to tell the user
    # which of their strings did not match anything

    foreach my $level (keys %$all_items) {
	my $resultset = $$all_items{$level};
	my $lastid = -1;
	foreach my $row (@$resultset) {
	    my $id = $$row{$level.'_ID'};
	    my $name = $$row{$level};

	    # DBS redundancy checking
	    if ($id == $lastid) {
		$$dbsdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;

	    # Search the TMDB for the user's glob
	    foreach my $userglob (@userdata) {
		my $globlevel = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
		next if (!$static && $level ne $globlevel);
		next unless $name =~ $userglob_re{$userglob};

		push @{$$all{$level}}, $id;

		push @{$$resolved{$userglob}},  { DBS => $$row{DBS},
						  LEVEL => $level,
						  DATASET => $$row{DATASET},
						  BLOCK   => $$row{BLOCK},
						  FILES   => $$row{FILES},
						  BYTES   => $$row{BYTES},
						  REPLICAS => [],
						  DPS_ISKNOWN => 'y',
						  DBS_ISKNOWN => 'y', # XXX This is assuming DPS and DBS are in sync
						  ID => $id };
	    }
	}
    }

    # Lookup in DBS items not found in TMDB. TODO: Put some limit on
    # this.  We are able to look up 1000's of items from TMDB, but
    # getting data from DBS is slower and the user will not know why
    # their search failed
    my $undef_id = 0;
    foreach my $userglob (@userdata) {
	if ($userdbs && ! @{$$resolved{$userglob}}) {
	    my @dbsdata = dbs_lookup($userdbs, $userglob);
	    my $globlevel = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
	    foreach my $name (@dbsdata) {
		$undef_id++;
		push @{$$resolved{$userglob}}, { DBS => $userdbs,
						 LEVEL => $globlevel,
						 DATASET => ($globlevel eq 'DATASET' ? $name : undef),
						 BLOCK   => ($globlevel eq 'BLOCK' ? $name : undef),
						 DPS_ISKNOWN => 'n',
						 DBS_ISKNOWN => 'y',
						 ID => 'undef'.$undef_id };
	    }
	}
    }

    # Look for data which the user has requested in duplicate
    my $lastid = -1;
    foreach my $level (qw(DATASET BLOCK)) {
	foreach my $id (sort @{$$all{$level}}) {
	    if ($id == $lastid) {
		$$userdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	}
    }

    # Attach replicas to resolved data.  We use the IDs from the data
    # we successfully looked up in TMDB to do this efficiently
    my $all_replicas = {};
    foreach my $level (qw(DATASET BLOCK)) {
	my @ids = @{$$all{$level}};
	while ( my @batch = splice @ids, 0, 1000 ) { # query groups of 1000 items
	    my $replicas = &fetch_replicas($dbh, $level, @batch);
	    foreach my $rep (@$replicas) {
		$all_replicas->{$level}->{ $rep->{ $level.'_ID' } } ||= [];
		push @{ $all_replicas->{$level}->{ $rep->{ $level.'_ID' } } }, $rep;
	    }
	}
    }

    foreach my $userglob (@userdata) {
	foreach my $item (grep $_->{DPS_ISKNOWN} eq 'y', @{$$resolved{$userglob}}) {
	    $item->{REPLICAS} = $all_replicas->{$item->{LEVEL}}->{$item->{ID}};
	}
    }
    
    # Return our results
    if (wantarray) {
	return ($resolved, $userdupes, $dbsdupes);
    } else {
	return $resolved;
    }
}

# returns all subscriptions matching the given datasets or blocks and
# their completion status
sub fetch_replicas
{
    my ($dbh, $level, @items) = @_;
    return undef unless ($dbh && $level && @items);

    my $block_select = '';
    my $block_group_by = '';
    my %binds;
    my $where;
    if ($level eq 'DATASET') {
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'ds.id', @items).')';
    } elsif ($level eq 'BLOCK') {
	$block_select = 'b.id block_id, ';
	$block_group_by = ', b.id';
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'b.id', @items).')';
    }

    my $q = &dbexec($dbh, qq{
	select n.id node_id, n.name node_name, ds.id dataset_id,
	       nvl2(s.destination, 1, 0) is_subscribed,
	       nvl2(s.destination, nvl2(s.dataset, 'DATASET', 'BLOCK'), NULL) subs_level,
               $block_select
               nvl(sum(br.node_files),0) files, nvl(sum(br.node_bytes),0) bytes,
	       sign(sum(decode(br.is_custodial, 'y', 1, 0))) is_custodial
         from t_dps_dataset ds
         join t_dps_block b on b.dataset = ds.id
         join t_dps_block_replica br on br.block = b.id
         join t_adm_node n on n.id = br.node
    left join t_dps_subscription s on s.destination = br.node
                                  and (s.dataset = ds.id or s.block = b.id)
        where (br.node_files != 0 or br.dest_files != 0)
          and $where
        group by n.id, n.name, ds.id, s.destination, s.dataset $block_group_by }, %binds);

    my $replicas = [];
    while (my @row = $q->fetchrow_array()) {
	my %hash;
	my $names = $q->{NAME_uc};
	$hash{ $$names[$_] } = $row[$_] for (0..scalar @$names - 1);
	push @$replicas, \%hash;
    }

    return $replicas;
}


# Given a list of dataset IDs and/or block IDs, calculate the number of files and bytes total
sub calculate_size
{
    my ($self, %args);

    my ($datasets, $blocks) = @args{qw(datasets blocks)};
    unless (($datasets && ref $datasets =~ /^ARRAY/) ||
	    ($blocks && ref $blocks =~ /^ARRAY/)) {
	die "calculate size called without dataset or block arrays";
    }

    my @where;
    my %binds;
    if ($datasets) {
	my ($ds_list, %ds_binds) = &dbinlist('ds', @{$datasets});
	push @where, $ds_list;
	$binds{$_} = $ds_binds{$_} foreach keys %ds_binds;
    }

    if ($blocks) {
	my ($b_list, %b_binds) = &dbinlist('b', @{$blocks});
	push @where, $b_list;
	$binds{$_} = $b_binds{$_} foreach keys %b_binds;
    }
    
    my $where_str = join ' or ', @where;
    my $sql = qq{ select sum(b.files), sum(b.bytes)
                    from t_dps_dataset ds
                    join t_dps_block b on b.dataset = ds.id
		    where $where_str };

    my ($files, $bytes) = &dbexec($$self{DBH}, $sql, %binds)->fetchrow();

    return ($files, $bytes);
}


1;


######################################################################
# A tool to create paged results given an SQL query
package Web25::QueryPager;
use strict; use warnings;
use CGI qw(param);
use POSIX qw(ceil);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{RESULTS_PER_PAGE} = 10;
  $$self{BINDS} = {};

  bless $self, $class;
  return $self;
}

# Initialize with
#  $webself  :  A reference to a Web25 object
#  $select   :  SQL to pageinate
#  $binds    :  (Optional, default null)  Hashref of bind parameters for $select
#  $results_per_page  :  (Optional, default 10)  Number of results to show per page
#  $rank_col  :  (Optional, default null) column to group results by
#  $filters  :  (Optional, default null)  hashref of column_name => regexp to filter to post-filter results
sub init
{
    my ($self, $webself, $select, $binds, $results_per_page, $rank_col, $filters) = @_;
    $self->process_filters($filters) if $filters;

    $$self{WEB} = $webself;
    $$self{DBH} = $$webself{DBH};
    $$self{SELECT} = $select;
    $$self{BINDS} = $binds if $binds;
    $$self{RESULTS_PER_PAGE} = $results_per_page if $results_per_page;
    $$self{RANK_COL} = $rank_col;
    $$self{FILTERS} = $filters if $filters && %{$filters};
    $$self{TOTAL_RESULTS} = $self->count_results();
    $$self{TOTAL_PAGES} = $self->total_pages();
    $$self{CURRENT_PAGE} = param('page_num') || 1;
    if ($$self{CURRENT_PAGE} <= 0 
	|| $$self{CURRENT_PAGE} > $$self{TOTAL_PAGES}) {
	$$self{CURRENT_PAGE} = 1;
    }

    if (!$$self{FILTERS}) {
	if (!$$self{RANK_COL}) {
	    $$self{PAGED_SQL} = qq[select * from ( select r.*, rownum as result_number
						   from ($$self{SELECT}) r 
						   where rownum <= :end_result ) 
				   where :start_result <= result_number ];
	} else {
	    $$self{PAGED_SQL} = qq[select * from 
				   (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) result_number
				    from ($$self{SELECT}) results )
				   where result_number >= :start_result and result_number <= :end_result];
	}
	my $start_result = $self->page_to_result();
	my $end_result = $start_result + $$self{RESULTS_PER_PAGE} - 1;
	$$self{BINDS}{':start_result'} = $start_result;
	$$self{BINDS}{':end_result'} = $end_result;
    } else {
	if (@{$$self{FILTERED_RESULTS}}) {
	    my $start_result = $self->page_to_result();
	    warn "ary size ", scalar @{$$self{FILTERED_RESULTS}}, " start_result ", $start_result, " rpp ",
	    $$self{RESULTS_PER_PAGE}, "\n";
	    my @page_results = splice @{$$self{FILTERED_RESULTS}}, $start_result - 1, $$self{RESULTS_PER_PAGE};
	    my ($result_list, %result_binds) = &dbinlist('result_id', @page_results);
	    $$self{BINDS}{$_} = $result_binds{$_} foreach keys %result_binds;
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where r.rowid in ($result_list)];
	} else {
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where 1 = 0];
	}
    }
}


sub get_total_results
{
    my ($self) = @_;
    return $$self{TOTAL_RESULTS};
}

# Returns the pager widget
sub pager
{
    my ($self) = @_;

    my $current_page = $$self{CURRENT_PAGE};
    my $total_pages = $$self{TOTAL_PAGES};

    return if $total_pages == 1;

    my @pager_html;

    push @pager_html, "<div class='pager'>Page $current_page of $total_pages:  ";
   
    if ($current_page > 1) {
	push @pager_html, $self->page_link(1, '[First]'), " \n";
	push @pager_html, $self->page_link(($current_page-1), '[Prev]'), " \n";
    }

    for (my $i = ($current_page-5); $i <= $current_page+5; $i++) {
	next if ($i < 1 || $i > $total_pages);

	if ($i != $current_page) {
	    push @pager_html, $self->page_link($i, $i), " \n";
	} else {
	    push @pager_html, $self->page_link($i, "<strong><big>$i</big></strong>"), " \n";
	}
    }

    if ($current_page < $total_pages) {
	push @pager_html, $self->page_link(($current_page+1), '[Next]'), " \n";
	push @pager_html, $self->page_link($total_pages, '[Last]'), " \n";
    }

    push @pager_html, "</div>";
    return @pager_html;
}

# Returns a query handle with 1 page's worth of results
sub paged_result
{
    my ($self) = @_;
    my $t1 = time();
    my $q = &dbexec($$self{DBH}, $$self{PAGED_SQL}, %{$$self{BINDS}});
    my $t2 = time();
    $$self{TIME_RESULT} = $t2 - $t1;
    return $q;
}

### Private functions ###

sub process_filters
{
    my ($self, $filters) = @_;
    foreach (keys %{$filters}) {
	my $f = $$filters{$_};
	if (!defined $f ||
	    $f eq '' ||
	    $f eq '.*') {
	    delete $$filters{$_};
	}
    }
}

# Return a link to a page
sub page_link
{
    my ($self, $page_num, $linktext) = @_;
# Using this method screws up when using https which seems like a CGI bug
# unfortunately this binds us to using the myurl() function...
#     my @ignore = qw(page);
#     my $cgi = new CGI;
#     $cgi->delete(@ignore);
#     $cgi->param('page_num', $page_num);
#     my $url = $cgi->self_url(-secure=>1);
    my $url = $$self{WEB}->myurl('page_num' => $page_num);
    return "<a href='$url'>$linktext</a>";
}

sub total_pages
{
    my $self = shift @_;
    my ($total_results, $results_per_page) = ($$self{TOTAL_RESULTS}, $$self{RESULTS_PER_PAGE});
    if ($total_results < 1) { $total_results = 1; }
    return POSIX::ceil($total_results/$results_per_page);
}

sub page_to_result
{
    my $self = shift @_;
    my ($current_page, $results_per_page) = ($$self{CURRENT_PAGE}, $$self{RESULTS_PER_PAGE});
    return ( ($current_page - 1 ) * $results_per_page + 1 );
}

sub count_results
{
    my $self = shift @_;

    my $t1 = time();
    my $num_results;
    if (!$$self{FILTERS}) {
	# No post-processing required, get results from sql query
	my $sql;
	if (!$$self{RANK_COL}) {
	    $sql = qq[select count(*) as num_results from ($$self{SELECT})];
	} else {
	    $sql = qq[select max(rank) from 
		      (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) rank
                       from ($$self{SELECT}) results)];
	}
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	($num_results) = $q->fetchrow();
    } else {
	# Full get all results, applying filters to get count, and caching rowid
	my $t1 = time();
	$$self{FILTERED_RESULTS} = [];
	my $sql = qq[select r.*, rownum as result_number, r.rowid
		       from ($$self{SELECT}) r ];
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	while (my $row = $q->fetchrow_hashref()) {
	    my $keep = 1;
	    foreach my $col (keys %{$$self{FILTERS}}) {
		$keep &&= ($$row{$col} =~ /$$self{FILTERS}{$col}/);
	    }
	    push @{$$self{FILTERED_RESULTS}}, $$row{ROWID} if $keep;
	}
	$num_results = scalar @{$$self{FILTERED_RESULTS}};
    }
    my $t2 = time();
    $$self{TIME_COUNT} = $t2 - $t1;

    return $num_results || 0;
}

1;



######################################################################
# A tool to print an html table
# many options for formatting cell data, row style and cell style
# based on given subrefs

package Web25::TableSpool;
use strict; use warnings;
use CGI qw(param);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{FH} = *STDOUT;
  $$self{STRIPE} = undef;
  $$self{ROWCNT} = 0;
  $$self{COLCNT} = 0;
  $$self{TABLECOLS}   = undef;
  $$self{TABLEHEAD}   = undef;
  $$self{TABLECLASS}  = undef;
  $$self{STRIPECLASS} = undef;
  $$self{DATAFORMATS} = undef;
  $$self{ROWFORMATS}  = undef;
  $$self{CELLFORMATS} = undef;
  $$self{PSEUDOCOLS}  = undef;
  $$self{QUERYCOLS}   = undef;
  $$self{STATCOLS}    = undef;
  $$self{STATS}       = undef;
  $$self{FILTERS}     = undef;

  bless $self, $class;
  return $self;
}

# Set filehandle to print to 
sub set_filehandle
{
    my ($self, $fh) = @_;
    $$self{FH} = $fh;
}

# $cols: array ref of DB_column_names to output (others are ignored)
sub set_tablecols
{
    my ($self, $cols) = @_;
    $$self{TABLECOLS} = $cols;
}

# Sets columns to display based on CGI query parameters
# takes a list of column descriptions of the form
# (label, querykey, columnkeys, is_default)
# If no specified query variables are found, the 'is_default' columns are shown
sub set_querycols
{
    my ($self, @column_descriptions) = @_;
    $$self{QUERYCOLS} = [@column_descriptions];
    my %checked_querykeys;
    my @foundcols;
    my @defaultcols;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	unless (exists $checked_querykeys{$querykey}) {
	    foreach my $param_columnkeys (param($querykey)) {
		push @foundcols, split( /:/, $param_columnkeys);
	    }
	}
	$checked_querykeys{$querykey} = 1;
	push @defaultcols, split( /:/, $columnkeys ) if $is_default;
    }

    if (@foundcols) { $self->set_tablecols([ @foundcols ]); }
    else { $self->set_tablecols([ @defaultcols ]); }
}


# $th : hash of DB_column_name=>Pretty_column_name for table headers
sub set_tablehead
{
    my ($self, $th) = @_;
    $$self{TABLEHEAD} = $th;
}

# $class :  CSS class for the HTML table
sub set_tableclass
{
    my ($self, $class) = @_;
    $$self{TABLECLASS} = $class;
}

# $stripe :  CSS class for striped rows
sub set_stripeclass
{
    my ($self, $class) = @_;
    $$self{STRIPECLASS} = $class;
}
# $dataformats : hash of DB_column_name=>formatting_subroutine($data, $rowref) for formatting data
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_dataformats
{
    my ($self, $df) = @_;
    $$self{DATAFORMATS} = $df;
}

# $cellformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the cell (<td>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_cellformats
{
    my ($self, $cf) = @_;
    $$self{CELLFORMATS} = $cf;
}

# $rowformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the row (<tr>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_rowformats
{
    my ($self, $rf) = @_;
    $$self{ROWFORMATS} = $rf;
}

# $sc : hashref of DB_column_name =>function name
# function name may be SUM, COUNT or AVERAGE
sub set_statcols
{
    my ($self, $sc) = @_;
    $$self{STATCOLS} = $sc;
    $$self{STATS} = {};
    foreach my $name (keys %{$sc}) {
	die "TableSpool::set_statscols:  Unknown function requested" 
	    unless (grep $$sc{$name} eq $_, qw(SUM COUNT AVERAGE));
	$$self{STATS}{$name}{COUNT} = 0;
	$$self{STATS}{$name}{SUM}   = 0;
    }
}

# $f : hashref of DB_column_name => subref
# subref is passed the data of DB_column_name in $_[0], and the rest of the columns in $_[1]
# if the subroutine returns true the row is kept, otherwise this row is not printed
# works on pre-formatted data
sub set_filters
{
    my ($self, $f) = @_;
    $$self{FILTERS} = $f;
}

# Returns the earlier requested statistics
sub get_stats
{
    my ($self) = @_;

    my $res = {};
    foreach my $name (keys %{$$self{STATS}}) {
	next unless grep ($name eq $_, @{$$self{TABLECOLS}});
	my $func = $$self{STATCOLS}{$name};
	my $sum = $$self{STATS}{$name}{SUM};
	my $count = $$self{STATS}{$name}{COUNT};
	if ($func eq 'SUM') {
	    $$res{$name} = $sum;
	} elsif ($func eq 'COUNT') {
	    $$res{$name} = $count;
	} elsif ($func eq 'AVERAGE') {
	    $$res{$name} = sprintf("%.2f", $sum/$count) unless $count == 0;
	}
    }
    return keys %{$res} ? $res : undef;
}

# $pseudocols : hash with key 'name' (column name) and value 'generator' (sub ref)
# for generating a pseudocolumn in the table.  Requires 'name' to be in TABLEHEAD for output.
# 'generator' is passed the hash of the current row data, before any processing
sub add_pseudocolumn
{
    my ($self, $name, $generator) = @_;
    $$self{PSEUDOCOLS} = {} unless $$self{PSEUDOCOLS};
    $$self{PSEUDOCOLS}->{$name} = $generator;
}



# Print the beginning of the table
sub start
{
    my ($self) = @_;
    print { $$self{FH} }
    "<table ", $$self{TABLECLASS} ? "class='$$self{TABLECLASS}'" : '', ">\n";
}

# Print the title columns
sub head
{
    my ($self, @headers) = @_;

    if (@headers) {
	# Do nothing
    } elsif ($$self{TABLECOLS} && $$self{TABLEHEAD}) {
	foreach (@{$$self{TABLECOLS}}) {
	    my $colhead;
	    if (exists $$self{TABLEHEAD}{$_}) {
		$colhead = $$self{TABLEHEAD}{$_};
	    } else {
		$colhead = $_;
	    }
	    push @headers, $colhead;
	}
    } elsif ($$self{TABLECOLS}) {
	@headers = @{$$self{TABLECOLS}};
    }

    if (!@headers) {
	die "TableSpool::head called without any column information\n";
    }

    print { $$self{FH} } "<thead>\n";
    print { $$self{FH} } "<tr>";
    print { $$self{FH} } "<th>$_</th>" foreach (@headers);
    print { $$self{FH} } "</tr>\n";
    print { $$self{FH} } "</thead>\n";
    print { $$self{FH} } "<tbody>\n";

    $$self{COLCNT} = scalar @headers;
}

# Prints a row, taking either an array of data
# or a hashref of labled data (name=>val)
sub row
{
    my ($self, @row) = @_;

    if (ref $row[0] eq 'HASH') {
	$self->hash_row($row[0]);
    } else {
	if (ref $row[0] eq 'ARRAY') {
	    @row = @{$row[0]};
	}

	my $rowclass = '';
	if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	    $rowclass = " class='$$self{STRIPECLASS}'";
	}
	
	print { $$self{FH} } "<tr$rowclass>";
	print { $$self{FH} } "<td>$_</td>" foreach (@row);
	print { $$self{FH} } "</tr>";
	$$self{ROWCNT}++;
    }
    return $$self{ROWCNT};
}

sub rows
{
    my ($self, $row_ary) = @_;
    foreach my $row (@{$row_ary}) {
	$self->row($row);
    }
}

# Print a row from a hash applying all features
sub hash_row
{
    my ($self, $row, $rowclass) = @_;
    $rowclass = '' if !defined $rowclass;

    # Copy the row
    my $myrow = {%{$row}};

    # Add the pseudocolumns to the row
    if ($$self{PSEUDOCOLS}) {
	foreach my $name (keys %{$$self{PSEUDOCOLS}}) {
	    $myrow->{$name} = &{$$self{PSEUDOCOLS}->{$name}}(undef, $myrow);
	}
    }

    # Check filters
    if ($$self{FILTERS}) {
	foreach my $name (keys %{$$self{FILTERS}}) {
	    return 0 unless &{$$self{FILTERS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Format data row if format sub provided   
    if ($$self{ROWFORMATS}) {
	my $rowclass_ary = [];
	foreach my $name (keys %{$$self{ROWFORMATS}}) {
	    push @{$rowclass_ary}, &{$$self{ROWFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
	$rowclass = join(' ', $rowclass, @{$rowclass_ary});
    }

    # Format data cell if format sub provided
    my $cellclass_hash = {};
    if ($$self{CELLFORMATS}) {
	foreach my $name (keys %{$$self{CELLFORMATS}}) {
	    $cellclass_hash->{$name} = &{$$self{CELLFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Gather statistics for columns
    if ($$self{STATCOLS}) {
	foreach my $name (keys %{$$self{STATCOLS}}) {
	    # Get number
	    next unless defined $myrow->{$name};
	    my ($val) = ($myrow->{$name} =~ /([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?)/);
	    $$self{STATS}{$name}{COUNT}++ if defined $val;
	    $$self{STATS}{$name}{SUM} += $val if defined $val;
	}
    }

    # Format data columns if format sub provided
    if ($$self{DATAFORMATS}) {
	foreach my $name (keys %{$$self{DATAFORMATS}}) {
	    $myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Print out the row with the appropriate classes
    if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	$rowclass .= ' '.$$self{STRIPECLASS};
    }

    if ($rowclass) { $rowclass = " class='$rowclass'"; }
  
    print { $$self{FH} } "<tr$rowclass>";

    foreach my $name (@{$$self{TABLECOLS}}) {
	my $cellclass = '';
	if (exists $cellclass_hash->{$name}) {
	    $cellclass = " class='".$cellclass_hash->{$name}."'";
	}
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td$cellclass>$val</td>";
    }
    print { $$self{FH} } "</tr>\n";
    $$self{ROWCNT}++;
    return $$self{ROWCNT};
}

# Prints a <tfoot> section and a single row - for stats.
sub footrow
{
    my ($self, $myrow) = @_;

    print { $$self{FH} } "<tfoot><tr>";
    foreach my $name (@{$$self{TABLECOLS}}) {
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td>$val</td>";
    }
    print { $$self{FH} } "</tr></tfoot>";
}


# Finish, returns number of rows printed
sub finish
{
    my ($self) = @_;
    print { $$self{FH} } "</tbody>\n";

    my $results = $self->get_stats();

    if ($results) {
	my $myrow = {%{$results}};  # copy

	# Format data columns if format sub provided
	if ($$self{DATAFORMATS}) {
	    foreach my $name (keys %{$$self{DATAFORMATS}}) {
		next unless exists $myrow->{$name};
		$myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	    }
	}

	$self->footrow($myrow);
    }

    print { $$self{FH} } "</table>\n";
    return $$self{ROWCNT};
}

# Returns form inputs for column selection
# requires set_querycols
sub columns_form
{
    my ($self) = @_;

    my @checked;
    my @defaults;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	foreach my $param_columnkeys (param($querykey)) {
	    push @checked, $label if ($param_columnkeys eq $columnkeys);
	}
	push @defaults, $label if ($is_default);
    }

    unless (@checked) {
	@checked = @defaults;
    }


    my $form = "";
    $form .= "<p><i>Display Columns</i></p>\n";
    foreach my $desc (@{$$self{QUERYCOLS}})
    {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	$form .= "<input type='checkbox' name='$querykey' value='$columnkeys'";
	$form .= (grep $_ eq $label, @checked) ? " checked='checked'" : "";
	$form .= " />&nbsp;$label<br/>\n";
    }
    
    return $form;
}


1;



######################################################################
# A simple class to print an HTML table of a DB query
package Web25::DBTable;
use strict; use warnings;
use base "Web25::TableSpool";

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  bless $self, $class;
  return $self;
}



# Output a table given a statement handle $sth,
# $sth : database handle to iterate on
sub output
{
    my ($self, $sth) = @_;

    if (! $$self{TABLECOLS}) {
	$self->set_tablecols($sth->{NAME});
    }

    if (! $$self{TABLEHEAD}) {
	my $th = {};
	$th->{$_} = $_ foreach (@{$sth->{NAME}});
	$self->set_tablehead($th);
    }

    $self->start();    
    $self->head();
    while (my $row = $sth->fetchrow_hashref()) {
	$self->row($row);
    }
    return $self->finish();
}

1;



######################################################################
package Web25::OptsPane;
use strict; use warnings;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{TABS} = [];
  $$self{HIDDEN} = [];
  $$self{TARGET} = "#";

  bless $self, $class;
  return $self;
}

sub set_form_target
{
    my ($self, $target) = @_;
    $$self{TARGET} = $target;
}

sub add_tab
{
    my ($self, $name, $form) = @_;
    my $id = scalar @{$$self{TABS}};
    push @{$$self{TABS}}, { id => $id, name => $name, form => $form };
}

sub add_hidden
{
    my ($self, $form) = @_;
    push @{$$self{HIDDEN}}, $form;
}

sub output
{
    my ($self) = @_;

    my $html = "";

    $html .= "<form method='get' action='$$self{TARGET}'>\n";

    $html .= "<div id='optsnav'>\n";
    foreach my $tab (@{$$self{TABS}}) {
	my $class = $tab->{id} == 0 ? 'raised' : 'lowered';
	$html .= "<div class='$class' onclick='return showtab($tab->{id})' id='optstab$tab->{id}'><a href='#'>$tab->{name}</a></div>\n";
    }
    $html .= "</div>\n";


    foreach my $tab (@{$$self{TABS}}) {
	my $display = $tab->{id} == 0 ? '' : 'style=\'display:none;\'';
	$html .= "<div class='optscontent' $display id='optspane$tab->{id}'>\n";
	$html .= $tab->{form};
	$html .= "</div>\n";
    }
    foreach my $hidden (@{$$self{HIDDEN}}) {
	$html .= $hidden;
    }

    $html .= "<div id='optsfoot'>\n";
    $html .= "<input type='submit' value='Cancel' onclick='return hideshow(this,\"opts\",0)'/>&nbsp;\n";
    $html .= "<input type='submit' value='Apply' />\n";
    $html .= "</div>\n";

    $html .= "</form>\n";


    return $html;
}

sub link
{
    my ($self, $linkname) = @_;
    "<a href='#' onclick='return hideshow(this,\"opts\",0)'>$linkname</a><br/>\n";
}



1;


######################################################################
package Web25::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

our $TEMPLATE_DEFAULT = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style25.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }

function shortlong(link,item,width) {
    var obj = document.getElementById(item);
    if (obj.style.width != width) {
	obj.style.width = (width+2) + "em";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = width + "em";
    } else {
        obj.style.width = "auto";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = "auto"
    }
    return false;
}

    function showtab(tab) {
	var i=0;
	var tabobj;
	var paneobj;
	for (i=0;i<10;i++) {
	    tabobj = document.getElementById('optstab'+i);
	    paneobj = document.getElementById('optspane'+i);
	    if (tab == i) {
		tabobj.className = 'raised';
		paneobj.style.display = '';
	    } else {
		tabobj.className = 'lowered';
		paneobj.style.display = 'none';
	    }
        }
	return false;
    }

function select_all(form_id, name, value) {
    var formblock= document.getElementById(form_id);
    var forminputs = formblock.getElementsByTagName('input');
    for (i = 0; i < forminputs.length; i++) {
	if (forminputs[i].getAttribute('name') == name) {
	    if (value == '1') {
		forminputs[i].checked = true;
	    } else {
		forminputs[i].checked = false;
	    }
	}
    }
}

--></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>

  <!-- Page-specific head elements -->
  @HEAD@
  <!-- /head -->
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="@HOMEPAGE@" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">@PAGEHEADING@</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@CONTENT@
</div>
</div> <!-- /page -->

<!-- corner navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
</div>

<!-- options panel -->
<div id="opts" style="display:none;">
@OPTIONS@
</div>

</body>
</html>
END_OF_TEMPLATE

our $TEMPLATE_BARE = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  @REFRESH@
  <link rel="stylesheet" href="@ROOTURL@style.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(link,item,hide) {
      var obj = document.getElementById(item);
      if (obj.style.display == '')
      {
        obj.style.display = 'none';
	if (hide) link.style.display = '';
      }
      else
      {
        obj.style.display = '';
	if (hide) link.style.display = 'none';
      }
      return false;
    }
   --></script>

  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
' style='background: none; margin: .5em'>

<!-- main content -->
<div id="content" style='border: none'>
@CONTENT@
</div>
</body>
</html>
END_OF_TEMPLATE

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web25::})
  {
    next if ! /::$/;
    next if ! exists ${$Web25::{$_}}{TOC};
    push (@result, ${$Web25::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web25::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } url_param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ url_param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);

  my $curpage = param('page');
  my $curlayout = param('layout');
  my $currefresh = param('refresh');
  my $cursecure = $$self{SECMOD}->isSecure();
  my $curquery = query_string();
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      ($curlayout ? ('layout' => $curlayout) : ()),
	      ($currefresh ? ('refresh' => $currefresh) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};
  my $fullurl = $args{'fullurl'}; delete $args{'fullurl'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();

  if (($cursecure || 0) != ($secure || 0) 
      || $fullurl) {
      $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url;
  }

  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  
  return $url;
}



sub generate
{
  my ($self, $config, $db) = @_;
  $$self{CONFIG} = $config;
  $$self{DBID} = $db;

  # Fire up the security module
  $$self{SECMOD}->setPwdHandler($self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::Password'));
  $$self{SECMOD}->setSignupHandler($self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setReqCertFailHandler($self->myurl('fullurl' => 1, 'secure' => 0, 'page'=>'Security::SignUp'));
  $$self{SECMOD}->setCallerURL($self->myurl('fullurl' => 1));
  $$self{SECMOD}->init();

  # Find the class scope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Force redirect to https if using http
  if ($$index{SECURE} && !$$self{SECMOD}->isSecure() && param('page') !~ /^Security/) {
      print redirect(-uri => $self->myurl("fullurl" => 1, "secure" => 1));
      return;
  }
  
  # Check if the client's identity was verified
  if ($$self{SECMOD}->isAuthenticated())
  {
    $$self{USER_NAME} = $$self{SECMOD}->getForename()." ".$$self{SECMOD}->getSurname();
    $$self{LOGIN_MESSAGE} =
	"<p>". &escapeHTML($$self{USER_NAME}) .
	" | <a href='" . $self->myurl("secure" => 1, "fullurl" => 1, "SecModLogout" => 1, page=>"Info::Main") . "'>Sign out</a></p>";
    if ($TESTING) {
	use Data::Dumper;
	my $roles = Dumper($$self{SECMOD}->getRoles());
	$$self{LOGIN_MESSAGE} .= "<p>$roles</p>", 
    }
  }
  else
  {
      $$self{LOGIN_MESSAGE} = 
	  "<p>Sign in ".
	  "<a href='" . $self->myurl("secure" => 1) . "'>via Cert</a> or ".
	  "<a href='" . $self->myurl("secure" => 1, "SecModPwd" => 1) . "'>via Password</a>".
	  "</p>";
  }
  my $login_state = $$self{SECMOD}->getAuthnState();
  if ($login_state eq 'cert') { $login_state = 'Logged in via Certificate'; }
  elsif ($login_state eq 'passwd') { $login_state = 'Logged in via Password'; }
  elsif ($login_state eq 'failed') { $login_state = 'Not logged in'; }
  $$self{LOGIN_MESSAGE} .= "<p>$login_state</p>";
  
  # Check whether we are looking at our vs. global view
  if (! $$self{SECMOD}->isAuthenticated() )
  {
      $$self{MY_VIEW} = 0;
      param('view', 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>global</strong></p>";
  }
    elsif (!param('view') || param('view') eq 'my')
  {
      $$self{MY_VIEW} = 1;
      my $otherurl = $self->myurl('view' => 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>my</strong> | <a href='$otherurl'>global</a></p>";
  }
  else
  {
      $$self{MY_VIEW} = 0;
      my $otherurl = $self->myurl('view' => 'my');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><a href='$otherurl'>my</a> | <strong>global</strong></p>";
  }

  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web25::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and obnoxiously warn if so
  my $testwarn = "";
  my $pageheading = 'PhEDEx &#8211; CMS Data Transfers';
  if ($ENV{PHEDEX_DEV}) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $prod =~ s!/dev/$ENV{PHEDEX_DEV}/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a development server for <b>$ENV{PHEDEX_DEV}</b>. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>($ENV{PHEDEX_DEV}'s Development)</blink>";
  } elsif ($ENV{SCRIPT_NAME} =~ m!/test/!) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a test server for the developers. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>(TEST)</blink>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'HEAD' => '',
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'PAGEHEADING' => $pageheading,
    'HOMEPAGE' => $self->myurl('page'=>'Info::Main'),
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      ("<div class='dbopt'>\n" .
       "<label>DB Instance:</label><strong>$$config{INSTANCES}{$db}{TITLE}</strong>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(this,\"dbopts\",0)'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a class='closelink' href='#' onclick='return hideshow(this,\"dbopts\",0)'>[close]</a>\n" .
       join ("",
             map { &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($cat && $$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web25::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       "$$self{LOGIN_MESSAGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
  };

  # Hide these things on the password page
  if (param('page') eq 'Security::Password') { 
      $$replacements{MYPAGE} = '';
      $$replacements{IDENTITY} = '';
      $$replacements{DBSELECTOR} = '';
      $$replacements{PAGESELECTOR} = '';
      $$replacements{TOCSELECTOR} = '';
      $$replacements{THIS_IS_A_TEST} = '';
  }

  # Prepare our cookies
  my @cookies;
  if ($$index{SESSION}) {
      require CGI::Session;
      require CGI::Cookie;
      my $session_name = 'PhEDEx';
      CGI::Session->name($session_name);
      my $session_dir = $$self{CONFIG}{SESSION_DIR} || '/tmp/cgi-sessions';
      my $sid = cookie($session_name) || undef;
      my $session = new CGI::Session("driver:File", $sid, {Directory=>$session_dir});
      $session->expire("+24h");
      $$self{SESSION} = $session;
      $$self{SESSIONID} = $session->id();
      my $cookie = new CGI::Cookie(-name=>$session_name, -value=>$$self{SESSIONID});
      push @cookies, $cookie;
  }

  if(( my $cookie = $$self{SECMOD}->getCookie() )) {
      push @cookies, $cookie;
  }
  


  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $options, $head) = ("", "", "");
  open ($$self{HEAD}, ">", \$head);
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{OPTIONS}, ">", \$options);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;

	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}
      };
      if ($@)
      {
	my $msg = $@;
	my $feedbackurl =
	  "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";

	print STDERR "$0: Internal error: $msg\n";
	return;
      }
    }
    $self->output();
     if ($$self{DBH})
     {
       $$self{DBH}->disconnect() if $$self{DBH};
       delete $$self{DBH};
     }
  };
  if ($@)
  {
    my $message = $@;
    $message = &escapeHTML($message);

    my $feedbackurl =
      "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
      . "PhEDEx%20web%20server%20trouble";

    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>notify the administrators</a>.</p>\n",
        " <p><i>$message</i></p>\n",
        "</div></center>\n";
    }
  }
  close($$self{HEAD});
  close($$self{CONTENT});
  close($$self{OPTIONS});
  $$replacements{HEAD} = join("\n", $head);
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{OPTIONS} = join("\n", $options);

  # Instantiate the desired template and spit it out
  my $template = param('layout');
  $template = 'default'
    if (! $template || ! grep($template eq $_, qw(default bare)));

  my $result = ($template eq 'bare' ? $TEMPLATE_BARE : $TEMPLATE_DEFAULT);
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html', -cookie=>\@cookies), $result;

  if ($$index{SESSION}) { $$self{SESSION}->flush(); }
}


1;

######################################################################
package Web25::XML;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};
  bless $self, $class;
  return $self;
}



sub generate
{
    my ($self, $config, $db) = @_;
    $$self{CONFIG} = $config;
    $$self{DBID} = $db;
    my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

    my ($output) = ("");
    open ($$self{CONTENT}, ">", \$output);
    eval
    {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;
	
	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}

	$self->output();
	if ($$self{DBH})
	{
	    $$self{DBH}->disconnect() if $$self{DBH};
	    delete $$self{DBH};
	}
	close($$self{CONTENT});
    };
    if ($@) {
	my $message = $@;
	$message = &escapeHTML($message);
	print {$$self{CONTENT}} "<error>$message</error>";
    }

    my $root = $$index{ROOT} ? $$index{ROOT} : 'data';
   
    print header(-type => 'text/xml', -encoding=>'ISO-8859-1');
    print "<?xml version='1.0' encoding='ISO-8859-1'?>\n";
    print "<$root>";
    print $output;
    print "</$root>";
}

1;



######################################################################
package Web25::XML::TransferStatus;
use strict; use warnings;
use base "Web25::XML";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { ROOT => 'ajax-response' };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my @datasets = param('dataset');
    my @se_names = param('se_name');
    my $id_suffix = param('id_suffix');

    if (!@datasets or !@se_names) {
	die "Missing parameters.  'dataset' and 'se_name' are required.\n";
    }

    my $multiple_se = 0;
    if (grep(/^\*$/, @se_names) || scalar @se_names > 1) {
	$multiple_se = 1;
    }

    # Get the number of files at an se
    # If the site has MSS, return the MSS rows only
    my $sql = qq{ select n.name node, n.se_name se_name, ds.name,
		  sum(br.node_files) node_files, sum(b.files) total_files
		      from t_dps_block_replica br
		      join t_adm_node n on n.id = br.node
                 left join t_adm_node m on m.se_name = n.se_name
                                       and m.kind = 'MSS'
		      join t_dps_block b on b.id = br.block
		      join t_dps_dataset ds on ds.id = b.dataset
		      where (m.id is null or n.kind = 'MSS')
                        and WHERE
		      group by n.name, n.se_name, ds.name
		      order by n.name, ds.name
		  };

    my @where;
    my %binds;
    if (grep /^\*$/, @se_names) {
	push @where, "n.se_name is not null";
    } else {
	my ($se_list, %se_binds) = &dbinlist('se_name', @se_names);
	push @where, "n.se_name in ($se_list)";
	$binds{$_} = $se_binds{$_} foreach keys %se_binds;
    }
    my ($ds_list, %ds_binds) = &dbinlist('ds', @datasets);
    push @where, "ds.name in ($ds_list)";
    $binds{$_} = $ds_binds{$_} foreach keys %ds_binds;

    my $where_str = join ' and ', @where;
    $sql =~ s/WHERE/$where_str/m;

    my $sth = &dbexec($$self{DBH}, $sql, %binds);
    my $nrows = 0;
    my $responses = {};
    while (my ($node, $se_name, $dataset, $node_files, $total_files) = $sth->fetchrow()) {
	$nrows++;
	my $id;
	if ($multiple_se) {
	    $id = join ':', 'multiple', $dataset;
	} else {
	    $id = join ':', $se_names[0], $dataset;
	}
	$id .= ':'.$id_suffix if $id_suffix;

	my $ratio = sprintf("%.1f", ($node_files / $total_files) * 100);
	my $color;
	if ($ratio == 0) { $color = 'red'; } 
	elsif ($ratio == 100) { $color = 'green'; } 
	else { $color = 'orange'; }

	my $line = "<div name='phedex_transfer_status' style='color:$color;'>".
	    "$node ($se_name) $node_files / $total_files (${ratio}%)".
	    "</div>";

	$$responses{$id}{$line} = 1;
    }

    if ($nrows) {
	foreach my $id (keys %{$responses}) {
	    print {$$self{CONTENT}}	"<response type='object' id='$id'>";
	    foreach my $line (keys %{$$responses{$id}}) {
		print {$$self{CONTENT}} $line;
	    }
	    print {$$self{CONTENT}} "</response>";
	}
    } else {
	# make fake result sets when there are no results
	# so Valentin's framework doesn't choke...
	foreach my $dataset (@datasets) {
	    my $id;
	    if ($multiple_se) {
		$id = join ':', 'multiple', $dataset;
	    } else {
		$id = join ':', $se_names[0], $dataset;
	    }
	    $id .= ':'.$id_suffix if $id_suffix;
	print {$$self{CONTENT}}	"<response type='object' id='$id'>No results</response>";
	}
    }

}

1;



######################################################################
package Web25::Security::Password;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');
    $caller_url =~ s,^http://[^/]+,$$self{CONFIG}{SSL_SERVER_ROOT},;
    my $msg = param('msg');

    print {$$self{CONTENT}} 
    "<h1>Password Sign-In</h1><br/>",
    "<p>Sign in with your CMS SiteDB/Hypernews password</p>",
    ($msg ? "<p style='color:red'>$msg</p>" : ''),
    "<form class='nice' method='post' action='$caller_url'>",
    "<label>Username</label>",textfield(-name=>'SecModLogin', -class=>'labeled'),"<br/>",
    "<label>Password</label>",password_field(-name=>'SecModPwd', -class=>'labeled'),"<br/>",
    "<label>&nbsp;</label>", submit(-name=>'Submit', -value=>'submit'),
    "</form>";
}

1;



######################################################################
package Web25::Security::SignUp;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Password Sign-In" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $sitedb = "<a href='$sitedb_url'>SiteDB</a>";
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';

    my $dn = $$self{SECMOD}->getBrowserDN();
    my $dn_ok = ($dn && $dn ne '(null)') ? 1 : 0;

    print {$$self{CONTENT}} 
    "<h1>Have You Signed Up?</h1><br/>",
    "<p class='blocktext'>You need to sign up with CMS Web Services in order to log in ",
    "and use privileged features.  Signing up can be done via ",
    "$sitedb.</p>",
    "<p class='blocktext'>If you have already signed up with SiteDB, it ",
    "is possible that your certificate or password information is out ",
    "of date there.  In that case go back to $sitedb and update your ",
    "information.</p>",
    "<p>For your information, the DN your browser presents is:</p>",
    ($dn_ok ? "<p>$dn</p>" : "<p><b>No certificate presented by your browser!</b></p>");

    if (!$dn_ok) {
	print {$$self{CONTENT}}
	"<p>For information on obtaining and loading certificates into ",
	"your browser, please visit <a href='$gridcert_help_url'>this ",
	"page</a>";
    }
}

1;


######################################################################
package Web25::Info::Main;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 3 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;



######################################################################
package Web25::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web25::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web25::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web25::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web25::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Components" }; 1;

package Web25::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Reports" }; 1;


######################################################################
package Web25::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web25::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web25::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web25::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web25::Info::Support; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Support Tracker",
	       LINK => "http://savannah.cern.ch/projects/cmscompinfrasup/",
	       LINK_TITLE => "Support Tracker" };
1;

package Web25::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

package Web25::Info::Datasvc; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER =>7, TITLE => "Data Service",
	       LINK => "http://cmsweb.cern.ch/phedex/datasvc/doc",
	       LINK_TITLE => "Data Service" };
1;

######################################################################
package Web25::Request::Page;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

use PHEDEX::Core::Identity;
use PHEDEX::RequestAllocator::Core;
use PHEDEX::RequestAllocator::SQL;

our @reqstates = (
  { STATE => 0, RANK => 0, LABEL => "Pending approval" },
  { STATE => 2, RANK => 3, LABEL => "Partially refused" },
  { STATE => 3, RANK => 4, LABEL => "Partially approved" },
  { STATE => 4, RANK => 9, LABEL => "Refused" },
  { STATE => 5, RANK => 5, LABEL => "Approved" }
);
our %reqstatenames  = map { ($$_{STATE} => $$_{LABEL}) } @reqstates;
our %reqstatevalues = map { ($$_{LABEL} => $$_{STATE}) } @reqstates;
our %reqactionnames = ( subscribe => 'Transfer Approved',
			nosubscribe => 'Transfer Refused',
			moveconfirm => 'Move Approved',
			nomoveconfirm => 'Move Refused',
			delete => 'Deletion Approved',
			nodelete => 'Deletion Refused' );

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub logClientInfo
{
    my ($self, $user_email) = @_;

    my $auth = $self->{SECMOD}->getAuthnState();
    $auth = $auth eq 'cert' ? 'CERTIFICATE' : 
	$auth eq 'passwd' ? 'PASSWORD' : die "not authenticated in logClientInfo";
        
    # Write information about the Client
    my $id_params = &PHEDEX::Core::Identity::getIdentityFromSecMod( $self, $self->{SECMOD} );
    my $identity = &PHEDEX::Core::Identity::fetchAndSyncIdentity( $self,
								  AUTH_METHOD => $auth,
								  %$id_params );
    my %client_attr;
    $client_attr{"Remote host"} = $ENV{HTTP_X_FORWARDED_FOR};
    $client_attr{"User agent"} = user_agent();
    $client_attr{'User email'} = $user_email if $user_email && $user_email ne $$identity{EMAIL};
    my $client_id = &PHEDEX::Core::Identity::logClientInfo($self,
							   $identity->{ID},
							   %client_attr);
    return $client_id;
}

sub getClientData 
{
    my ($self, $clientid) = @_;
    my $clientinfo = &PHEDEX::Core::Identity::getClientInfo($self, $clientid);
    my $identity = &PHEDEX::Core::Identity::getIdentityFromDB($self, $clientinfo->{IDENTITY});
    return { CONTACT_ATTR => $clientinfo, IDENTITY => $identity };
}

sub formatClientData
{
    my ($self, $data) = @_;
    my @html;
    
    my %nice_names = ('NAME' => 'Name',
		      'DN' => 'Distinguished name',
		      'USERNAME' => 'User name',
		      'EMAIL' => 'E-mail');
    if ( $data->{IDENTITY}->{CERTIFICATE} ) {
	push @html, "<label>Certificate:</label>",
	"<div class='labeled' style='height:100px;overflow:scroll;'><pre>", 
	$data->{IDENTITY}->{CERTIFICATE},
	"</pre></div><br/>";
    }
    foreach my $name (qw(NAME DN USERNAME EMAIL)) {
	push @html, "<label>$nice_names{$name}:</label><span class='labeled'>", 
	    ($data->{IDENTITY}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    foreach my $name (sort keys %{$data->{CONTACT_ATTR}}) {
	next if $name eq 'IDENTITY';
	push @html, "<label>$name:</label><span class='labeled'>", 
	($data->{CONTACT_ATTR}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    return @html;
}



sub getRequestData
{
    my ($self, $rid) = @_;
    $$self{DBH}->{LongReadLen} = 10_000;
    $$self{DBH}->{LongTruncOk} = 1;

    my $data = {};
    $data = &dbexec($$self{DBH}, qq{
	select r.id, rt.name type, r.created_by creator_id, r.time_create, rdbs.name dbs, 
	       rc.comments
	  from t_req_request r
          join t_req_type rt on rt.id = r.type
          join t_req_dbs rdbs on rdbs.request = r.id
     left join t_req_comments rc on rc.id = r.comments
	  where r.id = :request }, ':request' => $rid)->fetchrow_hashref();
    
    $$data{CREATOR_DATA} = $self->getClientData($$data{CREATOR_ID});
    
    $$data{NODES} = &dbexec($$self{DBH}, qq{
	select n.name node, n.id node_id,
               case when rn.point = 's' then 'Source Node'
                    when rn.point = 'd' then 'Destination Node'
                    else 'Node' end point,
               rd.decision, rd.decided_by, rd.time_decided, rc.comments
          from t_req_node rn
          join t_adm_node n on n.id = rn.node
     left join t_req_decision rd on rd.request = rn.request and rd.node = rn.node
     left join t_req_comments rc on rc.id = rd.comments
	  where rn.request = :request }, ':request' => $rid)->fetchall_hashref('NODE');

    my ($n, $n_pend, $n_appr, $n_dis) = (0, 0, 0, 0);
    foreach my $node (values %{$$data{NODES}}) {
	$n++;
	if (!$$node{DECISION}) { $n_pend++; }
	elsif ($$node{DECISION} eq 'y') { $n_appr++; }
	elsif ($$node{DECISION} eq 'n') { $n_dis++; }
	$$node{DECIDER_DATA} = $self->getClientData($$node{DECIDED_BY}) if $$node{DECIDED_BY};
    }

    my ($state);
    if    ($n == $n_appr)  { $state = 'Approved'; }
    elsif ($n == $n_dis)   { $state = 'Disapproved'; }
    elsif ($n == $n_pend)  { $state = 'Pending approval'; }
    elsif ($n_appr !=0)    { $state = 'Partially approved'; }
    elsif ($n_dis !=0)     { $state = 'Partially disapproved'; }
    $$data{REQUEST_STATE} = $state;
    $$data{REQUEST_NEEDS_ADMIN} = $n_pend;
    
    if ($$data{TYPE} eq 'xfer') {
	$$data{XFER_DATA} = &dbexec($$self{DBH}, qq{
	    select rx.priority, rx.is_custodial, rx.is_move, rx.is_static,
	           rx.is_transient, rx.is_distributed, 
	           g.id user_group_id, g.name user_group, rx.data
	      from t_req_xfer rx
	      join t_adm_group g on g.id = rx.user_group
	     where rx.request = :request
	 }, ':request' => $rid)->fetchrow_hashref();
    } elsif ($$data{TYPE} eq 'delete') {
	$$data{DELETE_DATA} = &dbexec($$self{DBH}, qq{
	    select rd.rm_subscriptions, rd.data
	      from t_req_delete rd
	     where rd.request = :request
	 }, ':request' => $rid)->fetchrow_hashref();9
    }
				
    $$data{DATA} = &dbexec($$self{DBH}, qq{
	select 'DATASET' lvl, rds.name, ds.id, nvl(sum(b.files),0) files, nvl(sum(b.bytes),0) bytes
	  from t_req_dataset rds left join t_dps_dataset ds on ds.id = rds.dataset_id
                                 left join t_dps_block b on b.dataset = ds.id
         where rds.request = :request
         group by rds.name, ds.id
        union
        select 'BLOCK' lvl, rb.name, b.id, b.files, b.bytes
          from t_req_block rb left join t_dps_block b on b.id = rb.block_id
         where rb.request = :request
        union
        select 'FILE' lvl, rf.name, f.id, 1 files, f.filesize bytes
          from t_req_file rf left join t_dps_file f on f.id = rf.file_id
         where rf.request = :request
     }, ':request' => $rid)->fetchall_hashref([qw(LVL ID)]);

     my ($total_files, $total_bytes) = (0, 0);
     foreach my $lvl (keys %{$$data{DATA}}) {
 	foreach my $item (values %{$$data{DATA}{$lvl}}) {
	    $total_files += $$item{FILES} || 0;
 	    $total_bytes += $$item{BYTES} || 0;
 	}
     }
     $$data{REQUEST_FILES} = $total_files;
     $$data{REQUEST_BYTES} = $total_bytes;

    return $data;
}



sub writeRequest
{
    my ($self) = @_;
    
    my %params;
    foreach (qw(user_email comments dbs data nodes type type_params)) {
	unless (defined $$self{SESSION}->param($_)) {
	    $self->alert('Insuficcient parameters from session: '.$_);
	    return;
	}
	$params{$_} = $$self{SESSION}->param($_);
    }
    my %type_params = %{$params{type_params}}; # copy
    foreach (keys %type_params) {
	$type_params{uc $_} = $type_params{$_};
	delete $type_params{$_};
    }
#    &dump_var( $$self{CONTENT}, 'params', \%params ); # XXX temp
#    &dump_var( $$self{CONTENT}, 'type_params', \%type_params);

    my $now = time();
    my $client_id = $self->logClientInfo($params{user_email});
    
    # Collect dataset and block IDs from resolved data items
    my (@ds_ids, @b_ids);
    foreach my $userglob (keys %{$params{data}}) {
	foreach my $item (@{ $params{data}->{$userglob} }) {
	    if ($$item{LEVEL} eq 'DATASET') {
		push @ds_ids, $$item{ID};
	    } elsif ($$item{LEVEL} eq 'BLOCK') {
		push @b_ids, $$item{ID};
	    }
	}
    }

    # Change node names to node IDs XXX fix earlier?
    my %nodes = $self->fetch_nodes(with_ids => 1);
    foreach my $pair (@{$params{nodes}}) {
	$pair->[1] = $nodes{ $pair->[1] };
    }

    # DBS info XXX fix earlier?
    my %dbses = $self->fetch_dbses(with_ids => 1);
    my $dbs_id = $dbses{$params{dbs}};

    # create the request
    my $req_id = &PHEDEX::RequestAllocator::Core::createRequest($self, \@ds_ids, \@b_ids,
								$params{nodes},
								TYPE => $params{type},
								%type_params,
								DBS_NAME => $params{dbs},
								DBS_ID => $dbs_id,
								COMMENTS => $params{comments},
								CLIENT_ID => $client_id,
								NOW => $now
								);

    return $req_id;
}



sub getRequestTitle
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	return "Transfer Request : ".$self->getRequestTypeSummary($data);
    } elsif ($$data{TYPE} eq 'delete') {
	return "Deletion Request";
    } else {
	return "Unknown Request";
    }
}



sub getRequestTypeSummary
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my $kind = $$data{XFER_DATA}{IS_MOVE} eq 'y' ? 'Move' : 'Replication';
	my %priority_names = (0 => 'High', 1 => 'Normal', 2 => 'Low');
	my $priority = $priority_names{ $$data{XFER_DATA}{PRIORITY} };
	my $custodial = $$data{XFER_DATA}{IS_CUSTODIAL} eq 'y' ? ' Custodial ' : ' ';
	return "$priority Priority$custodial$kind";
    } elsif ($$data{TYPE} eq 'delete') {
	return $$data{DELETE_DATA}{RM_SUBSCRIPTIONS} eq 'y' ? 'Deletion' : 'Retransfer';
    } else {
	return undef;
    }
}



sub printRequest
{
    my ($self, $rid, @auth_nodes) = @_;

    my $data = $self->getRequestData($rid);

    print { $$self{CONTENT} }
    # Request box
    "<div class='nice paramblock lev1'>",
    "<h1>Request $rid : ", $self->getRequestTitle($data), "</h1>",
    # Requestor hideaway box
    "<label>Requestor:</label>", "<div class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"creator$rid\", 0)'>",
    ($$data{CREATOR_DATA}{IDENTITY}{NAME} or 'Unknown'), 
    ( $$data{COMMENTS} ? " (comments)" : ''), "</a>",
    " at ", &formatTime($$data{TIME_CREATE}, 'stamp'), "<br/>",
    "<div id='creator$rid' class='hideaway' style='display:none;'>";
    
    #Creation comments
    if ($$data{COMMENTS}) {
	print { $$self{CONTENT} }
	"<label>Comments:</label>", "<div class='labeled comment'>",
	$$data{COMMENTS}, "</div><br/>";
    }

    print { $$self{CONTENT} }
    $self->formatClientData($$data{CREATOR_DATA}),
    "</div></div><br/>";

    # Request state
    print { $$self{CONTENT} }
    "<label>State:</label>", "<span class='labeled'>", 
    $$data{REQUEST_STATE}, "</span><br/>";

    # Group for transfer requests.  This is transfer-request specific,
    # but it needs more prominence than the hideaway box below
    if ($$data{TYPE} eq 'xfer') {
	print { $$self{CONTENT} }
	"<label>Group:</label>", "<span class='labeled'>", 
	($$data{XFER_DATA}{USER_GROUP} || 'undefined'), "</span><br/>";
    }

    # Data hideaway box
    my $data_label;
    if ($$data{REQUEST_FILES} == 0 && $$data{REQUEST_BYTES} == 0) {
	$data_label = "No longer available in TMDB";
    } else {
	$data_label = "$$data{REQUEST_FILES} files, ". &format_size($$data{REQUEST_BYTES});
    }

    print { $$self{CONTENT} }
    "<label>Data:</label>", "<div class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"data$rid\", 0)'>",
    $data_label, "</a><br/>",
    # Data details (hidden at first)
    "<div id='data$rid' class='hideaway' style='display:none;'>",
    "<label class='inline'>DBS URL:</label>", $$data{DBS}, "<br/>";
    $self->printDataTable($data);
    print { $$self{CONTENT} } "</div></div><br/>";

    # Nodes
    my $nodes = {}; # point => [ array of node objects ]
    my $admin = 0;
    my $reEval = 0;
    foreach my $node (sort keys %{$$data{NODES}}) {
	my $o = $$data{NODES}{$node};
	$admin = 1 if (!$$o{DECISION} && grep($$o{NODE} eq $_, @auth_nodes));
	$reEval = ( $$o{DECISION} &&
		    $$o{DECISION} eq 'y' &&
		    $$o{POINT} eq 'Destination Node' &&
		    $$data{TYPE} eq 'xfer' &&
		    $$data{XFER_DATA}{IS_STATIC} eq 'n' &&
		    $$data{XFER_DATA}{DATA} =~ /\*/ ? 1 : 0);
	$admin = 1 if ($reEval && grep($$o{NODE} eq $_, @auth_nodes));
	$$nodes{ $$o{POINT} } ||= [];
	push @{ $$nodes{$$o{POINT}} }, $o;
    }

    my $approve_url = $self->myurl('page' => 'Request::Admin');
    print { $$self{CONTENT} } "<form method='post' action='$approve_url'>" if $admin;
    foreach my $point ( sort keys %$nodes ) {
	print { $$self{CONTENT} }
	"<label>${point}s:</label>", "<div class='labeled'>";
	foreach my $o (@{$$nodes{$point}}) {
	    my $node_admin = ($admin && grep($$o{NODE} eq $_, @auth_nodes) ? 1 : 0);
	    my $decision_text = '';

	    if (!$$o{DECISION} && $node_admin) {
		my @controls;
		my %labels = ('approve' => 'approve', 'disapprove' => 'disapprove', 'null' => 'do nothing');
		foreach my $action (qw(approve disapprove null)) {
		    my $sel = $action eq 'null' ? "checked='checked'" : '';
		    push @controls, "<input $sel name='admin-$$o{NODE}' value='$action' type='radio'/> ".
			$labels{$action};
		}
		$decision_text = "<span class='warn'><b>admin</b></span> : " . join(' ', @controls);
	    } elsif (!$$o{DECISION}) {
		$decision_text = "<span class='warn'>pending approval</span>";
	    } else {
		my $decider_ref = "nodedec$rid-".$$o{NODE_ID};
		my @controls;
		if ($reEval && $$o{DECISION} eq 'y') {
		    # user can disapprove after the fact if the request is a re-evaluate candidate
		    push @controls, "<input name='admin-$$o{NODE}' value='stopeval' type='checkbox'/> stop evaluating"
			if $reEval;
		}

		$decision_text = 
		    join('', ($$o{DECISION} eq 'y' ? "<span class='good'>approved</span> by " 
			      : "<span class='bad'>disapproved</span> by "),
			 "<a href='#' onclick='return hideshow(this, \"$decider_ref\", 0)'>",
			 $$o{DECIDER_DATA}{IDENTITY}{NAME},
			 ( $$o{COMMENTS} ? " (comments)" : ''),
			 "</a></span>",
			 ' at ', &formatTime($$o{TIME_DECIDED}, 'stamp'),
			 # Request change controls
			 ( $node_admin && @controls ? 
			    ("  :  ", @controls)
			   : ''),
			 "<div id='$decider_ref' class='hideaway' style='display:none;'>",
			 # Creation comments
			 ( $$o{COMMENTS} ? 
			   "<label>Comments:</label><div class='labeled comment'>$$o{COMMENTS}</div><br/>" : ''),
			 $self->formatClientData($$o{DECIDER_DATA}),
			 "</div>");
	    }
	    print { $$self{CONTENT} } "$$o{NODE} : $decision_text<br/>";
	}
	print { $$self{CONTENT} } "</div><br/>";
    }
    if ($admin) {
	print { $$self{CONTENT} }
	"<label>Comment:<br/><span class='note'>(Optional)</span></label>",
	textarea(-name=>'comments', -rows=>5, -cols=>60, -class=>'labeled'), "<br/>",
	"<label>&nbsp;</label>",
	hidden('admin_request', $rid),
	submit(-value=>"Submit Changes for \#$rid", -class=>'labeled'), "<br/>",
	"</form>";
    }
 
    # Request-specific data
    print { $$self{CONTENT} }
    "<label>Details:</label>", "<span class='labeled'>",
    "<a href='#' onclick='return hideshow(this, \"details$rid\", 0)'>",
    $self->getRequestTypeSummary($data), "</a></span><br/>",
    "<div id='details$rid' class='hideaway' style='display:none;'>";
    $self->printRequestSpecific($data);
    print { $$self{CONTENT} } "</div>";

    # Request infomation link, if anything has been approved yet
    if ( $$data{REQUEST_STATE} =~ /approved/i ) {
	print { $$self{CONTENT} }
	"<label>Link:</label>", "<span class='labeled'>",
	$self->getRequestSpecificLink($data),
	"</span><br/>";
    }

    print { $$self{CONTENT} } "</div>";
}


sub printDataTable
{
    my ($self, $data) = @_;
    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(LVL NAME FILES BYTES)]);
    $table->set_tablehead({LVL => 'Data Level', 
			   NAME => 'Data Item',
			   FILES => 'Files',
			   BYTES => 'Size'});
    $table->set_dataformats({ LVL => sub { ucfirst lc $_[0] },
			      BYTES => sub { &format_size($_[0], 1, 2, 'G') }});
    $table->set_statcols({FILES => 'SUM', BYTES => 'SUM'});
    $table->start();
    $table->head();
     foreach my $lvl (keys %{$$data{DATA}}) {
 	foreach my $item (values %{$$data{DATA}{$lvl}}) {
	    $table->row($item);
 	}
     }
    $table->finish();
}



sub printRequestSpecific
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my $spec = $$data{XFER_DATA};
	my %labels = ( PRIORITY => 'Priority',
		       IS_CUSTODIAL => 'Custodial',
		       IS_MOVE => 'Move',
		       IS_STATIC => 'Static',
		       IS_TRANSIENT => 'Transient',
		       IS_DISTRIBUTED => 'Distributed',
		       DATA => 'Requested Data' );
	my %priority_names = (0 => 'High', 1 => 'Normal', 2 => 'Low');
	print { $$self{CONTENT} }
	"<label>$labels{PRIORITY}:</label><span class='labeled'>$priority_names{$$spec{PRIORITY}}</span><br/>";
	foreach my $key (qw(IS_CUSTODIAL IS_MOVE IS_STATIC)) { # TODO:  omitted keys have no function yet...
	    print { $$self{CONTENT} }
	    "<label>$labels{$key}:</label><span class='labeled'>", &yesno($$spec{$key}), "</span><br/>";
	}
	$$spec{DATA} =~ s/ +/<br\/>/g;
	print { $$self{CONTENT} }
	"<label>$labels{DATA}:</label><span class='labeled databox tinytext'>$$spec{DATA}</span><br/>";
    } elsif ($$data{TYPE} eq 'delete') {
	my $spec = $$data{DELETE_DATA};
	my %labels = ( RM_SUBSCRIPTIONS => 'Remove Subscriptions?',
		       DATA => 'Requested Data' );
	foreach my $key (qw(RM_SUBSCRIPTIONS)) { # TODO:  omitted keys have no function yet...
	    print { $$self{CONTENT} }
	    "<label>$labels{$key}:</label><span class='labeled'>", &yesno($$spec{$key}), "</span><br/>";
	}
	$$spec{DATA} =~ s/ +/<br\/>/g;
	print { $$self{CONTENT} }
	"<label>$labels{DATA}:</label><span class='labeled databox tinytext'>$$spec{DATA}</span><br/>";
    } else {
	print { $$self{CONTENT} } 'N/A';
    }
}


sub getRequestSpecificLink
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my @nodes = map { $$_{NODE_ID} } grep $$_{POINT} eq 'Destination Node', values %{$$data{NODES}};
	my $url = $self->myurl(page =>'Data::Subscriptions',
			       reqfilter => $$data{ID},
			       node => \@nodes);
	return ("<a href='$url'>Subscriptions Page</a>");
    } elsif ($$data{TYPE} eq 'delete') {
	my $url = $self->myurl(page =>'Activity::Deletions',
			       reqfilter => $$data{ID},
			       node => '.*');
	return ("<a href='$url'>Deletions Page</a>");
    } else {
	return ("N/A");
    }
}


1;

######################################################################
package Web25::Request::Main;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($n_req) = &dbexec($$self{DBH}, qq{
      select count(*) n_requests
	from t_req_request
    })->fetchrow();

  print {$$self{CONTENT}} "<h1>Requests Overview</h1>";
  print {$$self{CONTENT}} "<p>There are <b>$n_req</b> Requests.</p>";

  my $q = &dbexec($$self{DBH}, qq{
     select n.name node, rt.name type, nvl(rd.decision,'PEND'), count(*) n_req
       from t_req_request r
       join t_req_type rt on rt.id = r.type
       join t_req_node rn on rn.request = r.id
       join t_adm_node n on n.id = rn.node
  left join t_req_decision rd on rd.request = rn.request
                             and rd.node = rn.node
  group by n.name, rt.name, nvl(rd.decision,'PEND')
  order by n.name
});

  print {$$self{CONTENT}}
  "<h2>Overview By Node</h2>",
  "<p><b>Legend:</b>  ", 
  "xfer = Transfer Request, ",
  "del = Delete Request, ",
  "pend = Pending Approval, ",
  "appr = Approved, ",
  "dis = Disapproved</p>";

  my $overview = {};
  while (my ($node, $type, $decision, $n_req) = $q->fetchrow()) {
   #   print {$$self{CONTENT}} "<p>$node $type $decision $n_req</p>";
      $$overview{$node}{$type}{$decision} = $n_req;
  }

  my %dec_switch = ('y' => 'appr',
		    'n' => 'dis',
		    'PEND' => 'pend');
  my @dec_order = qw(PEND y n);
  my $n_cols = 4;
  my $col = 0;
  print {$$self{CONTENT}} "<table class='data'>";
  foreach my $node (sort keys %{$overview}) {
      print {$$self{CONTENT}} "<tr>" if $col == 0;
      print {$$self{CONTENT}} "<td style='padding:1em;'><center><b>$node</b></center>";
      foreach my $type (sort keys %{$$overview{$node}}) {
	  my $o = $$overview{$node}{$type};
	  print {$$self{CONTENT}} "<b>$type:</b>  ";
	  my @decisions;
	  foreach my $dec (@dec_order) {
	      my $n = $$o{$dec} || 0;
	      my $state = $dec_switch{$dec};
	      my $url = $self->myurl('page' => 'Request::View',
				     'nodes' => $node,
				     'type' => $type,
				     'state' => $state);
	      my $link = "<a href='$url'>$n</a>";
	      push @decisions, "$link $state";
	  }
	  print {$$self{CONTENT}} 
	  join(', ', @decisions), "<br/>";
      }
      print {$$self{CONTENT}} "</td>";
      if ($col == $n_cols-1) {
	  print {$$self{CONTENT}} "</tr>";
	  $col = 0;
      } else {
	  $col++;
      }
  }

  if ($col != $n_cols-1) {
      while ($col < $n_cols-1) {
	  print {$$self{CONTENT}} "<td>&nbsp;</td>";
	  $col++;
      }
      print {$$self{CONTENT}} "</tr>";
  }
      
  print {$$self{CONTENT}} "</table>";

}

1;



######################################################################
package Web25::Request::View;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "View/Manage Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(request type nodes state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Request::View" &&
			    $args{"page"} ne "Request::Admin"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;

    my $request = param('request');
    my $type = param('type');
    my $nodes = param('nodes');
    my $state = param('state');

    my $viewurl = $self->myurl();
    print {$$self{CONTENT}}
    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View request \#s </label>",
    textfield(-name=>'request', -default=>$request, -class=>'labeled'),
    "<label class='inline'>",&help("[?]", "Request Numbers", 
	  "Input a space separated list of request numbers to display"), "</label>",
    submit(-value=>'Submit', -class=>'labeled'), 
    "</form><br clear='all'/>",

    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View </label>",
    popup_menu(-name=>'type', -values=>[qw(any xfer delete)],
	       -labels=>{ any => 'any type', xfer => 'transfer', delete => 'deletion' },
	       -class=>'labeled'),
    "<label class='inline'> requests for nodes </label>",
    textfield(-name=>'nodes', -default=>$nodes, -class=>'labeled'),
    popup_menu(-name=>'state', -values=>[qw(any pend appr dis)],
	       -labels=>{ any => 'any requests', pend => 'pending approval', appr => 'approved', dis => 'disapproved'},
	       -class=>'labeled'),
    submit(-value=>'Submit', -class=>'labeled'), "</form><br clear='all'/>";


    my @auth_nodes;
    if ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	@auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');	
    } elsif (!$$self{SECMOD}->isAuthenticated() ||
	     $$self{SECMOD}->isPasswdAuthenticated()) {
	$self->auth_help_popup('approve requests' => ['cert', 'Data Manager', 'Admin']);
    }

    my @where;
    my %binds;

    if ($request) {
	my @requests = grep(/^\d+$/, split(/\s*,*\s+/, $request));
	my ($req_list, %req_binds) = &dbinlist('request', @requests);
	$binds{$_} = $req_binds{$_} foreach keys %req_binds;
	push @where, "r.id in ($req_list)";
    }

    if ($type && grep($type eq $_, qw(xfer delete))) {
	push @where, 'rt.name = :type';
	$binds{':type'} = $type;
    }

    if ($nodes) {
	my @nodes;
	my %all_nodes = $self->fetch_nodes(with_ids => 1);
	foreach my $filter (split /\s+/, $nodes) {
	    push @nodes, grep(/$filter/, keys %all_nodes);
	}
	my ($node_list, %node_binds) = &dbinlist('node', @all_nodes{@nodes});
	$binds{$_} = $node_binds{$_} foreach keys %node_binds;
	push @where, "rn.node in ($node_list)" if %node_binds;
    }
    
    if ($state) {
	if ($state eq 'pend') { push @where, "rd.decision is null"; }
	elsif ($state eq 'appr') { push @where, "rd.decision = 'y'"; }
	elsif ($state eq 'dis') { push @where, "rd.decision = 'n'"; }
    }

    my $where_str = '';
    $where_str = 'where '.join(' and ', @where) if @where;
    
    my $sql = qq{
      select distinct r.id, r.time_create
      from t_req_request r
      join t_req_type rt on rt.id = r.type
      join t_req_node rn on rn.request = r.id
      left join t_req_decision rd on rd.request = r.id
                                 and rd.node = rn.node
      $where_str
      order by r.time_create desc
    };

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, \%binds,  10);
    my $n_requests = $pager->get_total_results();

    if (! $n_requests) {
	print { $$self{CONTENT} } "<p>No requests to show.</p>";
	return;
    }

    print {$$self{CONTENT}} $pager->pager();
    my $qreq = $pager->paged_result();
    while (my ($rid) = $qreq->fetchrow()) {
	$self->printRequest($rid, @auth_nodes);
    }
    print {$$self{CONTENT}} $pager->pager();

}


1;



######################################################################
package Web25::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web25::Common;
use CGI qw(:standard);
BEGIN { my $__scriptdir = $ENV{SCRIPT_FILENAME} 
	|| "./"; $__scriptdir =~ s,[^/]+$,,;
	unshift(@INC, $__scriptdir . "/cgi-bin"); };
use RFC822Addr 'validlist'; # Mail::RFC822::Address really;

our @EXPORT = qw(get_request_nodes
                 create_check_type
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comments
		 create_check_dbs
		 create_check_data
		 create_check_nodes
		 create_check_options
);

sub get_request_nodes
{
    my ($self) = shift @_;
    my %nodes = $self->fetch_nodes(with_ids=>1);
    if ($$self{DBID} eq 'prod') {
	foreach my $node (keys %nodes) {
	    delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
	}
    }
    return sort keys %nodes;
}

sub create_check_type
{
    my ($self, $bad, $type) = @_;
    unless (grep $type eq $_, qw(xfer delete)) {
	alert($self, "Invalid request type.");
	$$bad = 1;
	return undef;
    }
    return $type;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $$self{SECMOD}->isAuthenticated() ) {
      $self->auth_help_warning('create a transfer request' => ['anyauth']);
      $$bad = 1;
      return;
  }
}

sub create_check_email
{
  my ($self, $bad, $email) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

    return $$bad ? undef : $email;
}

sub create_check_comments
{
  my ($self, $bad, $comments) = @_;
  return undef if $$bad;
  return $comments;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
      my @dbses = $self->fetch_dbses();
      if (! grep($_ eq $dbs, @dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}



sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my %userdata = $self->parse_userdata($data);
  if (! %userdata) {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (keys %userdata) {
      if (! $userdata{$data} ) {
	  $self->alert("The data pattern is &ldquo;@{[&escapeHTML($data)]}&rdquo;",
		       " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	  $$bad = 1;
      }
  }

  return $$bad ? undef : keys %userdata;
}

sub create_check_nodes
{
  my ($self, $bad, @nodes) = @_;
  return undef if $$bad;

  if (! @nodes)
  {
    alert($self, "No nodes selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @possible_nodes = $self->get_request_nodes();

  foreach my $node (@nodes)
  {
    if (! grep ($_ eq $node, @possible_nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
  }
}

return $$bad ? undef : sort @nodes;
}

sub create_check_options
{
  my ($self, $bad, $type) = @_;
  return undef if $$bad;

  my $opts = {};

  my %groups = $self->fetch_groups(with_ids=>1);
  my @possible_groups = ('undefined', keys %groups);

  if ($type eq 'xfer') {
      foreach ('is_move', 'is_static', 'is_custodial') {
	  if (!defined param($_) || param($_) !~ /^[yn]$/) {
	      $self->alert("Option '$_' missing or illegal value");
	      $$bad = 1;
	      return ();
	  }
      }
  
      if (!defined param('priority') || param('priority') !~ /^[012]$/) {
	  $self->alert("Option 'priority' missing or illegal value");
	  $$bad = 1;
	  return ();
      }
      
      if (!defined param('group') || ! grep $_ eq param('group'), @possible_groups) {
	  $self->alert("Option 'group' is missing or illegal value");
	  $$bad = 1;
	  return ();
      }

      return ( 'is_move' => param('is_move'),
	       'is_static' => param('is_static'),
	       'priority' => param('priority'),
	       'is_custodial' => param('is_custodial'),
	       'user_group' => param('group')
	       );
  } elsif ($type eq 'delete') {
      foreach ('rm_subscriptions') {
	  if (!defined param($_) || param($_) !~ /^[yn]$/) {
	      $self->alert("Option '$_' missing or illegal value");
	      $$bad = 1;
	      return ();
	  }
      }
      return ('rm_subscriptions' => param('rm_subscriptions') );
  } else {
      $self->alert("Invalid request type '$type'");
      $$bad = 1;
      return ();
  }
}

1;

######################################################################
package Web25::Request::Create;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Create Request",
	       SESSION => 1,
	       LINK_TITLE => "Create a new request",
	       SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;

  &create_check_identity($self, \$bad);
  return if $bad;

  my $type = param('type');
  my $node_label = '';
  my $confirm_page = $self->myurl(page=>'Request::Confirm');

  if (!defined $type || !grep($type eq $_, qw(xfer delete))) {
      print { $$self{CONTENT} }
      "<h1>Choose a request type</h1>",
      "<ul><li><a href='", $self->myurl('type'=>'xfer'), "'>Transfer Request</a></li>",
      "<li><a href='", $self->myurl('type'=>'delete'), "'>Deletion Request</a></li></ul>";
      return;
  } else {
      my %headings = (xfer => "New Transfer Request", delete => "New Deletion Request");
      print { $$self{CONTENT} } "<h1>$headings{$type}</h1><br/>";
      if ($type eq 'xfer') { 
	  $node_label = 'Destinations'; 
      }
      elsif ($type eq 'delete') {
	  $node_label = 'Nodes'; 
      }
  }

  my $email_contact = $$self{SECMOD}->getEmail();
  
  my @dbsnames = $self->fetch_dbses();
  my $defaultdbs = $$self{CONFIG}{DEFAULT_DBS} || 'blank';
  my @nodes = $self->get_request_nodes();
  my @groups = sort $self->fetch_groups();

  my $dbs_selection =  popup_menu(-name=>'dbs', 
				  -values=>[ map { &escapeHTML($_) } @dbsnames ],
				  -default=>&escapeHTML($defaultdbs) );


  print { $$self{CONTENT} }
  "<form class='nice' method='post' action='$confirm_page'>\n",
  hidden('type', $type),
  "<label>E-mail:</label>", textfield(-name=>'email', -default=>$email_contact, -class=>'labeled', -style=>'width:450px'), "<br/>\n",

  &hidden(-name=>'dbschoice', 'value'=>'known'),
  "<label>DBS:</label>",  "<div class='labeled'>",$dbs_selection, "</div><br/>",

  "<label>Data Items:<br/><br/>",
  "<span class='note'>/Primary/Processed/Tier<br/>or<br/>",
  "/Primary/Processed/Tier#Block<br/>(Use * as wildcard)</span><br/>",
  &help("More Help", "Data Item List", 
	"A whitespace separated list of the datasets or blocks you are ",
	"requesting.  The wildcard '*' may be used, but the dataset ",
	"path separators '/' are required.  E.g. to subscribe to all ",
	"'Higgs' datasets you would have to write '/Higgs/*/*', not '/Higgs*'."), 
  "</label>\n",
  textarea(-name=>'data', -value=>'', -style=>'width:450px;height:150px;', -class=>'labeled'), 
  "<br/>",

  "<label>$node_label:</label>",
  "<div class='labeled'  style='font-size:8pt;width:450px;height:150px;overflow:scroll;border:thin solid black;' >",
  "<table><tr valign='top'>",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'nodes', -label=>'', -value=>$_)."$_<br/>") }
   sort grep (/^T1_|T0_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'nodes', -label=>'', -value=>$_)."$_<br/>") }
   grep (/^T2_/, @nodes)),
  "  </td>\n",
  "  <td>\n",
  (map { &striplabels(checkbox(-name=>'nodes', -label=>'', -value=>$_)."$_<br/>") }
   grep (! /^T[012]_/, @nodes)),
  "  </td>\n",
  " </tr></table></div><br/>\n";
  
  if ($type eq 'xfer') {
      print { $$self{CONTENT} }
      "<label>Transfer Type:</label>", popup_menu(-name=>'is_move', 
						  -values=>['n', 'y'],
						  -default=>'n',
						  -labels=>{'n' => 'Replica', 'y' => 'Move'},
						  -class=>'labeled'),
      &help("What's this?", "Transfer Type", "A <b>replica</b> replicates ",
	    "data from the source to the destination, while a <b>move</b> ",
	    "replicates the data then deletes the data at the source.  Note that ",
	    "moves are only used for moving data from T2s to T1s."),
      "<br/>",
      "<label>Subscription Type:</label>", popup_menu(-name=>'is_static', 
 						      -values=>['n', 'y'],
 						      -default=>'n',
 						      -labels=>{'n' => 'Growing', 'y' => 'Static' },
 						      -class=>'labeled'), 
       &help("What's this?", "Subscription Type", 
	     "A <b>growing</b> subscription downloads blocks/files added to open ",
	     "datasets/blocks as they become available, until the dataset/block is ",
	     "closed.  Also, wildcard patterns will be re-evaluated to match new ",
	     "datasets/blocks which become available.  A <b>static</b> subscription ",
	     "will expand datasets into block subscriptions, and no open blocks will ",
	     "be subscribed.  Wildcard patterns will not be re-evaluated. ",
	     "A static subscription is a snapshot of data available now"),
      "<br/>",
      "<label>Priority:</label>", popup_menu(-name=>'priority', 
					     -values=>[2, 1, 0], 
					     -default=>2,
					     -labels=>{ 0 => 'High',
							1 => 'Normal',
							2 => 'Low' },
					     -class=>'labeled'),
      &help("What's this?", "Priority",
	    "Priority is used to determine which data items get priority when resources are limited."),
      "<br/>",
      "<label>Custodial:</label>", popup_menu(-name=>'is_custodial', 
					     -values=>['n', 'y'], 
					     -default=>'n',
					     -labels=>{ 'n' => 'Non-custodial',
							'y' => 'Custodial' },
					     -class=>'labeled'),
      &help("What's this?", "Custodial",
	    "Whether or not the target node(s) have a custodial responsibility for the data in this request."),
      "<br/>",
      "<label>Group:</label>", popup_menu(-name=>'group', 
					  -values=>['undefined', @groups],
					  -default=>'undefined',
					  -class=>'labeled'),
      &help("What's this?", "Group",
	    "The group which is requesting this data.  Used for accounting purposes.  This can be left undefined."),
      "<br/>";
  } elsif ($type eq 'delete') {
      print { $$self{CONTENT} }
      "<label>Remove Subscriptions?:</label>",
      popup_menu(-name=>'rm_subscriptions', -values=>[qw(y n)], -labels=>{y => 'Yes', n => 'No'}, -class=>'labeled'),
      &help("[what's this?]", "Remove Subscriptions",
	    "If you choose not to remove the subscription when deleting data PhEDEx will ",
	    "retransfer the data to your node after the deletion is complete."),
      "<br/>";
  }
  print { $$self{CONTENT} }
  "<label>Comment:</label>", textarea(-name=>'comments',
				      -default=>'', -style=>'width:450px;height:150px;',
				      -class=>'labeled'), "<br/>\n",
    "<label>&nbsp;</label>", submit(-name=>'submit', -value=>'Submit Request', -class=>'labeled'),
  "</form>";
}

1;



######################################################################
package Web25::Request::Confirm;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Submit Request",
	       SESSION => 1, SECURE => 1 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $bad = 0;
  my %params;

  &create_check_identity($self, \$bad);
  &create_check_access($self, \$bad);
  if (!param('go_ahead')) {
      $params{type} = &create_check_type($self, \$bad, param('type'));
      $params{email} = &create_check_email($self, \$bad, param('email'));
      $params{comments} = &create_check_comments($self, \$bad, param('comments'));
      if (param('dbschoice') eq 'known') { $params{dbs} = param('dbs') }
      elsif (param('dbschoice') eq 'user') { $params{dbs} = param('userdbs') } 
      else { $self->alert("Missing or unknown DBS parameters"); return; }
      $params{dbs} = &create_check_dbs($self, \$bad, $params{dbs});
      $params{data} = [&create_check_data($self, \$bad, param('data'))];
      $params{nodes} = [&create_check_nodes($self, \$bad, param('nodes'))];
      my %options = &create_check_options($self, \$bad, $params{type});
      $params{$_} = $options{$_} foreach keys %options;
  }

  if ($bad)
  {
    print { $$self{CONTENT} } "<p>Please resubmit the form with corrected information.</p>\n";
    return;
  }

  if (param('go_ahead') && param('extra_confim')) {
      unless (param('extra_confirm_value') && param('extra_confirm_value') eq 'y') {
	  $self->note('You need to read the confirmation message and click the confirmation box!');
	  return;
      }
  }

  if (param('go_ahead') && param('go_ahead') eq 'y') {
      my $rid = $self->writeRequest();
      $self->{DBH}->commit();
      my $ok = $self->send_request_create_email($rid);

      print { $$self{ CONTENT } }
      "<h1>Request Confirmed</h1>",
      "<p>Your request \#$rid has been logged to the database and the admins have been notified.  ",
      "You will receive updates about this request via e-mail.</p>";

      # Print request (user may be able to approve it immediately)
      my @auth_nodes;
      if ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Admin', 'phedex') || $$self{SECMOD}->hasRole('Data Manager'))) {
	  @auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager'); 
      }
      $self->printRequest($rid, @auth_nodes);

      return;
  }

  # Clear any previous request
  $$self{SESSION}->clear();

  my $node_label;
  if    ($params{type} eq 'xfer')   { $node_label = 'Destinations'; }
  else                              { $node_label = 'Nodes'; }

  print { $$self{CONTENT} } 
  "<form method='post' action='@{[$self->myurl()]}'>\n",
  "<p>Please review these request details and confirm below.  If you would like to ",
  "change your request, use the back button in your browser.</p>",
  "<h1>Request Information</h1>",
  "<div class='nice'>",
  "<label>Requestor:</label><span class='labeled'>$$self{USER_NAME}</span><br/>",
  "<label>E-mail:</label><span class='labeled'>$params{email}</span><br/>",
  "<label>DBS:</label><span class='labeled'>$params{dbs}</span><br/>",
  "<label>Data:</label><span class='labeled'>", join('<br/>', @{$params{data}}), "</span><br/>",
  "<label>$node_label:</label><span class='labeled'>", join(', ', @{$params{nodes}}), "</span><br/>",
  $self->getRequestOptions(%params),
  "</div>";

  # Check options and print warnings/notes
  return unless $self->checkRequestOptions(%params);

  # Check data for problems
  my $problems = 1;
  if    ($params{type} eq 'xfer')   { $problems = $self->checkXferRequestData(%params); }
  elsif ($params{type} eq 'delete') { $problems = $self->checkDeleteRequestData(%params); }

  unless ($problems) {
      print { $$self{CONTENT} }
      hidden(-name=>'go_ahead', -value=>'y'),
      "<p><center>", submit(-value=>'Confirm'), "</p>";
  } else {
      $self->alert("Sorry, due to the problems with your request (in red) it cannot be submitted.  ",
		   "Please go back and resolve the problems if you can, or ",
		   "<a href='mailto:$$self{CONFIG}{FEEDBACK_MAIL}'>mail the admins</a> if you have a question.");
  }
  print { $$self{CONTENT} } "</form>";
}

sub getRequestOptions
{
    my ($self, %params) = @_;
    if ($params{type} eq 'xfer') {
	my %prio = ('0' => 'High', '1' => 'Normal', '2' => 'Low');
	return ("<label>Is Move?:</label><span class='labeled'>", &yesno($params{is_move}), "</span><br/>",
		"<label>Is Static?:</label><span class='labeled'>", &yesno($params{is_static}), "</span><br/>",
		"<label>Priority:</label><span class='labeled'>", $prio{$params{priority}}, "</span><br/>",
		"<label>Custodial:</label><span class='labeled'>", &yesno($params{is_custodial}), "</span><br/>",
		"<label>Group:</label><span class='labeled'>", $params{user_group}, "</span><br/>",
		);
    } elsif ($params{type} eq 'delete') {
	return ("<label>Remove Subscriptions?:</label><span class='labeled'>", &yesno($params{rm_subscriptions}),
		"</span><br/>");
    } else { return (); }
}

sub checkRequestOptions
{
    my ($self, %params) = @_;
    if ($params{type} eq 'xfer') {
	# Request-blocking warnings
	if ($params{is_move} eq 'y' && grep($_ !~ /^T1_\w*_MSS$/, @{$params{nodes}})) {
	    $self->alert("You have requested a move to an unsupported destination (e.g. not a Mass Storage System ",
			 "at a T1 centre).  Please change the destination, or choose to trigger a replication ",
			 "instead of a move");
	    return 0;
	} elsif ($params{is_custodial} eq 'y' && grep($_ !~ /^T1_\w*_MSS$/, @{$params{nodes}})) {
	    $self->note("You have chosen to make a custodial data transfer to an unsupported destination.  ",
			"Custodial data may only be subscribed to a Mass Storage System at a T1 center.  ",
			"Please change the destination, or choose to make a non-custodial copy instead.");
	    return 0;
	} 

	# Extra-confirmation nagging warnings
	my $print_confirm = 0;
	if ($params{is_move} eq 'y' && grep(/^T1_\w*_MSS$/, @{$params{nodes}})) {
	    $self->warning("You have chosen to <b>move data</b> to ", join(', ', @{$params{nodes}}),
			". Source sites with subscriptions will be sent a ",
			"notification to confirm the deletion of this data ",
			"upon successful replication to the destination ",
			"nodes.");
	    $print_confirm = 1;
	} 
	if ($params{is_custodial} eq 'y') {
	    $self->warning("You have chosen to make a <b>custodial data ",
			"subscription</b> to ", join(', ', @{$params{nodes}}), ". ",
			"Make sure that these are the nodes which you want to give ",
			"custodial responsibility for this data.  Once the ",
			" subscription is made, the custodial property can not be ",
			" changed!");
	    $print_confirm = 1;
	}

	if ($print_confirm) {
	    $self->note("Please check the box to confirm that you understand the above warnings.<br/><br/>",
			   hidden('extra_confirm', 1),
			   checkbox(-name=>'extra_confirm_value', -value=>'y', -label=>'Yes, I understand'));
	}
    }
    return 1;
}

sub checkXferRequestData
{
    my ($self, %params) = @_;

    my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, 
							  $params{dbs}, 
							  $params{is_static} eq 'y' ? 1 : 0,
							  @{$params{data}});

    print { $$self{CONTENT} } "<h1>Data Item Lookup</h1>",
    "<p>The following table summarizes an attempt to look for your requested data items in PhEDEx.</p>";
  
    # Pull all subscriptions into a hash organized by node for subscription duplication checking
    my $subscriptions = {};
    my $q = &dbexec($$self{DBH}, qq{ select NVL2(s.block, 'BLOCK', 'DATASET') lvl,
				            NVL2(s.block, s.block, s.dataset) id,
				            n.name node, s.is_custodial
				     from t_dps_subscription s
				     join t_adm_node n on s.destination = n.id });
  
    while (my ($level, $id, $node) = $q->fetchrow_array()) {
	$$subscriptions{$node}{$level}{$id} = 1;
    }

    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(LEVEL ITEM FILES BYTES DPS_ISKNOWN DBS_ISKNOWN SOURCES COMMENT)]);
    $table->set_tablehead({LEVEL => 'Data Level', 
			   ITEM => 'Data Item',
			   FILES => 'Files',
			   BYTES => 'Size',
			   DPS_ISKNOWN => 'Known to PhEDEx', 
			   DBS_ISKNOWN => 'Known to DBS', 
			   SOURCES => 'Sources (current)',
			   COMMENT => 'Comment'});
    $table->set_cellformats({COMMENT     => sub { return 'alarm' if $_[1]->{PROBLEM}; 
						  return 'warn'  if $_[1]->{WARN};
						  return '';
					      },
			     DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			     DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});
    
    $table->set_dataformats({DPS_ISKNOWN => \&yesno,
			     DBS_ISKNOWN => \&yesno,
			     LEVEL => sub { ucfirst lc $_[0] },
			     BYTES => sub { &format_size($_[0], 1, 2, 'G') }});
    $table->set_statcols({FILES => 'SUM', BYTES => 'SUM'});
        
    $table->start();
    $table->head();

    my $problems = 0;
    my %subscribed_sources;
    foreach my $userglob (sort @{$params{data}}) {
	if (! @{$$resolved{$userglob}} ) {
	    $table->row({LEVEL => 'User Search',
			 ITEM  => $userglob,
			 DPS_ISKNOWN => 'n',
			 DBS_ISKNOWN => 'n',
			 COMMENT => 'Data item not found anywhere',
			 WARN => 1});
	    $problems = 1;
	} else {
	    foreach my $res (@{$$resolved{$userglob}}) {
		my @comments;
		my $warn = 0;
		my $row_problem = 0;

		if ($$res{FILES} == 0) {
		    my $item_level = ucfirst lc $$res{LEVEL};
		    push @comments, "$item_level has no files";
		    $warn = 1;
		}
		if ($$res{DBS} ne $params{dbs})  { 
		    push @comments, "Known to PhEDEx in another DBS ($$res{DBS})";
		    $warn = 1; $row_problem = 1;
		}
		if ($$userdupes{$$res{LEVEL}}{$$res{ID}}) { 
		    push @comments, "User duplicated requests";
		    $warn = 1;
		}
		if ($$dbsdupes{$$res{LEVEL}}{$$res{ID}})  { 
		    push @comments, "Data item known to PhEDEx in multiple DBSes";
		    $warn = 1; 
		}
		if ($$res{LEVEL} eq 'BLOCK' && $params{is_move} eq 'y') {
		    push @comments, "Move request includes block-level data.  Only moves of datasets are supported";
		    $warn = 1;
		}

		foreach my $node (@{$params{nodes}}) {
		    if ($$subscriptions{$node}{$$res{LEVEL}}{$$res{ID}}) {
			push @comments, "Already subscribed to $node";
			$warn = 1;
		    }
		}
		
		# Check replicas if a move or custodial request was made
		if ($params{is_move} eq 'y' || $params{is_custodial} eq 'y') {
		    my $bad_t1_move = 0;
		    my @custodial;
		    foreach my $replica (@{$$res{REPLICAS}}) {
			if ($params{is_move} eq 'y' && $$replica{NODE_NAME} =~ /^T1/ && $$replica{IS_SUBSCRIBED}) {
			    $bad_t1_move = 1;
			} elsif ($params{is_move} eq 'y' && $$replica{IS_SUBSCRIBED}) {
			    $subscribed_sources{$$replica{NODE_NAME}} = $$replica{NODE_ID};
			}
			if ($params{is_custodial} eq 'y' && $$replica{IS_CUSTODIAL}) {
			    push @custodial, $$replica{NODE_NAME};
			}
		    }
		    if ($bad_t1_move) {
			push @comments, "Cannot move data subscribed to a T1";
			$row_problem = 1;
		    }
		    if (@custodial) {
			push @comments, "Data already custodial for ", join(', ', @custodial);
			$warn = 1;
		    }
		}

		$$res{SOURCES} = join(', ', sort map { "$$_{NODE_NAME} ($$_{FILES} files)" } @{$$res{REPLICAS}});
		$$res{SOURCES} ||= 'None found';
		$$res{ITEM} = $$res{$$res{LEVEL}}; # Name of dataset or block, depending on which it is for
		$$res{COMMENT} = join('<br/>', @comments);
		$$res{COMMENT} ||= 'None';
		$$res{WARN} = $warn;
		$$res{PROBLEM} = $row_problem;
		
		if ($$res{DPS_ISKNOWN} eq 'n' || $$res{DBS_ISKNOWN} eq 'n') { $problems = 1; }
		$table->row($res);
		$problems ||= $row_problem;
	    }
	}
    }
    $table->finish();

    unless ($problems) {
	# Save the previous state
	$$self{SESSION}->param('type', 'xfer');
	$$self{SESSION}->param('type_params', { 'is_move' => $params{is_move},
						'is_transient' => 'n', # XXX hardcoded
						'is_static' => $params{is_static},
						'is_distributed' => 'n', # XXX hardcoded
						'priority' => $params{priority},
						'is_custodial' => $params{is_custodial},
						'user_group' => $params{user_group},
						'data' => join(' ', @{$params{data}})
						});
	$$self{SESSION}->param('comments', $params{comments});
	$$self{SESSION}->param('dbs', $params{dbs});
	$$self{SESSION}->param('user_email', $params{email});
	my @node_pairs;
	push @node_pairs, ['d', $_ ] foreach @{$params{nodes}};
	push @node_pairs, ['s', $_ ] foreach values %subscribed_sources;
	$$self{SESSION}->param('nodes', \@node_pairs);
	$$self{SESSION}->param('data', $resolved);
    }
 
    return $problems;
}

sub checkDeleteRequestData
{
    my ($self, %params) = @_;

    my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, $params{dbs}, 0, @{$params{data}});

    my $del_queue = &dbexec($$self{DBH}, 
			qq{select n.id node_id, n.name node,
		                  ds.id dataset_id, ds.name dataset,
		                  b.id block_id, b.name block, b.bytes,
                                  bd.block block_queued
                             from t_dps_block_delete bd
		             join t_dps_block b on b.id = bd.block
   	                     join t_dps_dataset ds on ds.id = b.dataset
                             join t_adm_node n on n.id = bd.node
			 })->fetchall_hashref([qw(NODE DATASET_ID BLOCK_ID)]);

    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(LEVEL ITEM FILES BYTES DPS_ISKNOWN DBS_ISKNOWN SOURCES COMMENT)]);
    $table->set_tablehead({LEVEL => 'Data Level', 
			   ITEM => 'Data Item',
			   FILES => 'Files',
			   BYTES => 'Size',
			   DPS_ISKNOWN => 'Known to PhEDEx', 
			   DBS_ISKNOWN => 'Known to DBS', 
			   SOURCES => 'Sources (current)',
			   COMMENT => 'Comment'});
    $table->set_cellformats({COMMENT     => sub { return 'alarm' if $_[1]->{PROBLEM}; 
						  return 'warn'  if $_[1]->{WARN};
						  return '';
					      },
			     DPS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''},
			     DBS_ISKNOWN => sub { $_[0] eq 'n' ? 'alarm' : ''}});
    
    $table->set_dataformats({DPS_ISKNOWN => \&yesno,
			     DBS_ISKNOWN => \&yesno,
			     LEVEL => sub { ucfirst lc $_[0] },
			     BYTES => sub { &format_size($_[0], 1, 2, 'G') }});
    $table->set_statcols({FILES => 'SUM', BYTES => 'SUM'});
        
    $table->start();
    $table->head();

    my $problems = 0;
    foreach my $userglob (sort @{$params{data}}) {
	if (! @{$$resolved{$userglob}} ) {
	    $table->row({LEVEL => 'User Search',
			 ITEM  => $userglob,
			 DPS_ISKNOWN => 'n',
			 DBS_ISKNOWN => 'n',
			 COMMENT => 'Data item not found anywhere',
			 WARN => 1});
	    $problems = 1;
	} else {
	    foreach my $res (@{$$resolved{$userglob}}) {
		my @comments;
		my $warn = 0;
		
		if ($$res{FILES} == 0) {
		    my $item_level = ucfirst lc $$res{LEVEL};
		    push @comments, "$item_level has no files";
		    $warn = 1;
		}
		if ($$res{DBS} ne $params{dbs})  { 
		    push @comments, "Known to PhEDEx in another DBS ($$res{DBS})";
		    $warn = 1; $problems = 1; 
		}
		if ($$userdupes{$$res{LEVEL}}{$$res{ID}}) { 
		    push @comments, "User duplicated requests";
		    $warn = 1;
		}
		if ($$dbsdupes{$$res{LEVEL}}{$$res{ID}})  { 
		    push @comments, "Data item known to PhEDEx in multiple DBSes";
		    $warn = 1; 
		}
		foreach my $node (@{$params{nodes}}) {
		    my ($replica) = grep($node eq $$_{NODE_NAME}, @{$$res{REPLICAS}});
		    if (!$replica || $$replica{FILES} == 0) {
			push @comments, "$node has nothing to delete";
			$warn = 1;
		    } 
		    if ($$replica{SUBS_LEVEL} eq 'DATASET' && $$res{LEVEL} eq 'BLOCK'
			&& $params{rm_subscriptions} eq 'y') {
			push @comments, "You will remove a ".
			    "dataset-level subscription from $node if you ".
			    "delete this block.";
			$warn = 1;
		    } 
		    if ($$replica{IS_CUSTODIAL}) {
			push @comments, "You are requesting to delete ".
			    "a custodial copy of the data.  This must be ".
			    "approved by a global administrator.";
			$warn = 1;
		    }

		    if ($$res{LEVEL} eq 'DATASET' && exists $$del_queue{$node}{ $$res{ID} }) {
			my $n_blocks = scalar keys %{$$del_queue{$node}{ $$res{ID} }};
			push @comments, "$node already has $n_blocks blocks from this dataset queued for deletion";
			$warn = 1;
		    }
		}

		$$res{SOURCES} = join(', ', sort map { "$$_{NODE_NAME} ($$_{FILES} files)" } @{$$res{REPLICAS}});
		$$res{SOURCES} ||= 'None found';
		$$res{ITEM} = $$res{$$res{LEVEL}}; # Name of dataset or block, depending on which it is for
		$$res{COMMENT} = join('<br/>', @comments);
		$$res{COMMENT} ||= 'None';
		$$res{WARN} = $warn;
		$$res{PROBLEM} = $problems;
		
		if ($$res{DPS_ISKNOWN} eq 'n' || $$res{DBS_ISKNOWN} eq 'n') { $problems = 1; }
		$table->row($res);
	    }
	}
    }
    $table->finish();

    unless ($problems) {
	# Save the previous state
	$$self{SESSION}->param('type', 'delete');
	$$self{SESSION}->param('type_params', { 'rm_subscriptions' => $params{rm_subscriptions},
						'data' => join(' ', @{$params{data}})
						});
	$$self{SESSION}->param('comments', $params{comments});
	$$self{SESSION}->param('dbs', $params{dbs});
	$$self{SESSION}->param('user_email', $params{email});
	my @node_pairs = map { [ undef, $_ ] } @{$params{nodes}};
	$$self{SESSION}->param('nodes', \@node_pairs);
	$$self{SESSION}->param('data', $resolved);
    }

    return $problems;
}


sub send_request_create_email
{
    my ($self, $rid) = @_;
    my $data = $self->getRequestData($rid);

    # Get a list of the sites involved in this request
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my (%sites);  # for unique list
    foreach my $node (keys %{$$data{NODES}}) {
	$sites{ $node_sites{ $node } } = 1 if exists $node_sites{ $node };
    }

    # Get the list of Global admins
    my @global_admins = $$self{SECMOD}->getUsersWithRoleForGroup('Admin', 'phedex');

    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach my $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach my $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    # Make a simple list of the data
    my @datalist;
    foreach my $lvl (qw(DATASET BLOCK FILE)) {
	foreach my $item (values %{$$data{DATA}{$lvl}}) {
	    push @datalist, $$item{NAME};
	}
    }

    # Send an email to the requestor, the global admins, the data managers, and the site admins
    my $name = $$data{CREATOR_DATA}{IDENTITY}{NAME};
    my $email = $$data{CREATOR_DATA}{CONTACT_ATTR}{'User email'} ||
	$$data{CREATOR_DATA}{IDENTITY}{EMAIL};
    my $auth = "";
    if (exists $$data{CREATOR_DATA}{IDENTITY}{DN}) {
	$auth = "DN:  ".$$data{CREATOR_DATA}{IDENTITY}{DN};
    } elsif (exists $$data{CREATOR_DATA}{IDENTITY}{USERNAME}) {
	$auth = "Username:  ".$$data{CREATOR_DATA}{IDENTITY}{USERNAME};
    }
    my $instance = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE};
    my $request_type = $self->getRequestTitle($data);
    my @to;
    push @to, $$_{EMAIL} foreach (@global_admins, @data_managers);
    my @cc = ($email);
    push @cc, $$_{EMAIL} foreach @site_admins;

    my $admin_url = $self->myurl('fullurl' => 1,
				 'secure' => 1,
				 'page' => 'Request::View',
				 'request' => $rid);
    my $special_message = $self->get_special_request_message($data);

    my $files = $$data{REQUEST_FILES};
    my $bytes = &format_size($$data{REQUEST_BYTES});
    
    my $comments = $$data{COMMENTS} || '';
	
    my $message =<<ENDEMAIL;
Greetings PhEDEx Data Managers,

You may wish to take note of the following new request:

* Requestor:
   Name: $name
   E-mail: $email
   Authentication: $auth
   Host: $$data{CREATOR_DATA}{CONTACT_ATTR}{'Remote host'}
   Agent: $$data{CREATOR_DATA}{CONTACT_ATTR}{'User agent'}

ENDEMAIL

    if ($$data{TYPE} eq 'xfer') {
	my $group_name = $$data{XFER_DATA}{USER_GROUP} || 'undefined';
	$message .=<<ENDEMAIL;
* Group:
   $group_name

ENDEMAIL
}

    $message .=<<ENDEMAIL;
* Request:
   Type:
     $request_type
   Database:
     $instance
   DBS:
     $$data{DBS}
   Data:
ENDEMAIL

    $message .= join('', map( { "     $_\n" } @datalist));

    my $nodes_by_point = {};
    foreach my $n (values %{ $$data{NODES} }) {
	$$nodes_by_point{ $$n{POINT} } ||= [];
	push @{ $$nodes_by_point{ $$n{POINT} } }, $$n{NODE};
    }

    foreach my $point (sort keys %$nodes_by_point) {
	$message .= "   ${point}s:\n";
	foreach my $node (sort @{$$nodes_by_point{ $point }}) {
	    my $site = $node_sites{$node} || 'unknown';
	    $message .= "     $node (Site:  $site)\n"
	}
    }

    $message .=<<ENDEMAIL;
   Size:
     $files files, $bytes
   Comments:
     "$comments"

$special_message
 
This mail has also been sent to the requestor, the PhEDEx global
admins, and the site admins of the relevant sites.

Go to
  $admin_url
to handle this request.

Yours truly,
  PhEDEx Transfer Request Web Form
ENDEMAIL
    
send_email(subject => "PhEDEx $request_type ($instance instance)",
	   to => [ @to ],
	   cc => [ @cc ],
	   from => "PhEDEx Request Form <$$self{CONFIG}{FEEDBACK_MAIL}>",
	   message => $message)
or $self->alert("Sending request email to admins failed, sorry");

}


sub get_special_request_message
{
    my ($self, $data) = @_;

    my $msg = '';
    if ($$data{TYPE} eq 'xfer') {
	if ($$data{XFER_DATA}{IS_MOVE} eq 'y') {
	    $msg .= "Note:  This is a request for a data MOVE. ".
		"The Data Managers and Site Admins of the source sites have also been notified.  ".
		"Data Managers of the source sites with subscriptions  must approve the move before ".
		"data will be deleted from their node.\n";
	}
	if ($$data{XFER_DATA}{IS_CUSTODIAL} eq 'y') {
	    $msg .= "Note: This is a request for CUSTODIAL STORAGE of ".
		"data.  Please ensure your site is prepared to receive and ".
		"reliably store this data permanently (e.g. on tape) ".
		"before accepting this transfer request.\n";
	}
    }
    return $msg;
}

1;



######################################################################
package Web25::Request::Admin;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Administer Request",
	       LINK_TITLE => "Administer Requests",
	       SECURE => 1 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(request type nodes state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Request::View" &&
			    $args{"page"} ne "Request::Admin"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
    my ($self) = @_;
    
    # Check access method
    if (request_method() ne 'POST') {
	$self->alert("This form can only be accessed with the POST method");
	return;
    }

    # Check authentication and authorization
    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->alert("This form may only be accessed by Data Managers with certificate authentication.");
	return;
    }
    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager', with_ids => 1);

    my %node_actions;
    foreach my $key (grep /^admin-/, param()) {
	my $node = $key;
	$node =~ s/^admin-//;
	unless (grep($node eq $_, keys %auth_nodes)) {
	    $self->alert("You don't have permission to approve requests for $node");
	    return;
	}
	my $action = param($key);
	unless (grep $action eq $_, qw(approve disapprove null stopeval)) {
	    $self->alert("Invalid action '$action' for node '$node'");
	    return;
	}
	$node_actions{$node} = $action;
    }

    # Check parameters
    my $rid = param('admin_request');
    my $comments = param('comments');
    my $now = time ();

    unless ($rid && %node_actions) {
	$self->alert("Missing parameters");
	return;
    }

    # Go to work
    my $data = $self->getRequestData($rid);

    # Check that the request has some data
    unless (keys %{$$data{DATA}{DATASET}} || keys %{$$data{DATA}{BLOCK}}) {
	$self->alert("Request has no data");
	return;
    }

    # Check that each of the nodes is part of this request
    foreach my $node (keys %node_actions) {
	if (!exists $$data{NODES}{$node}) {
	    $self->alert("Node $node isn't part of request \#$rid");
	    return;
	} elsif (defined $$data{NODES}{$node}{DECISION} && $node_actions{$node} ne 'stopeval') {
	    $self->alert("Request \#$rid has already been adminned for ${node}!");
	    return;
	}
    }

    my $client_id = $self->logClientInfo();
    my $comments_id = &PHEDEX::RequestAllocator::SQL::writeRequestComments($self, $rid, $client_id, $comments, $now)
	if $comments;

    my $ok = 1;
    my @results;
    foreach my $node (sort keys %node_actions) {
	my $action = $node_actions{$node};
	my $node_id = $auth_nodes{$node};
	my $node_obj = $$data{NODES}{$node};

	if ($action eq 'null') {
	    push @results, "No action taken for $node";
	} elsif ($action eq 'disapprove') {
	    $ok &&= $self->disapprove($data, $node_obj, $now);
	    $ok &&= $self->markRequestDone($rid, $node_id, 'n', $client_id, $now, $comments_id);
	    push @results, "Disapproved request \#$rid for $node";
	} elsif ($action eq 'approve') {
	    $ok &&= $self->approve($data, $node_obj, $now);
	    $ok &&= $self->markRequestDone($rid, $node_id, 'y', $client_id, $now, $comments_id);
	    push @results, "Approved request \#$rid for $node";
	} elsif ($action eq 'stopeval') {
	    $ok &&= $self->markRequestUndone($rid, $node_id);
	    $ok &&= $self->markRequestDone($rid, $node_id, 'n', $client_id, $now, $comments_id);
	    push @results, "Disapproved request \#$rid for $node to stop request re-evaluation";
	}
    }

    if ($ok) {
       	$$self{DBH}->commit();
	$self->send_request_update_email($rid, \%node_actions, $comments);
	print {$$self{CONTENT}} 
	"<h1>Request Updated</h1>",
	"<p>", join('<br/>', @results), "</p>",
	"<p class='blocktext'>Your changes to request \#$rid ",
	"have been applied and an update email was sent to the ",
	"requestor as well as the Data Managers/Site Admins of the ",
	"relevant sites.</p>";
    } else {
	$$self{DBH}->rollback();
	print {$$self{CONTENT}} "<h1>Error</h1>";
	$self->alert("Problem writing request, transaction rolled back.  ",
		     "Please report this problem to the PhEDEx administrators");
    }
    
    $self->printRequest($rid);

    my $viewurl = $self->myurl(page => "Request::View");
    print {$$self{CONTENT}} "<p><a href='$viewurl'>View requests</a></p>";
}

sub disapprove
{
    my ($self, $data, $node_obj, $time) = @_;

    if ($$data{TYPE} eq 'xfer' && $$data{XFER_DATA}{IS_MOVE} eq 'y' && $$node_obj{POINT} eq 'Source Node') {
	$self->updateMoveSource($$data{ID}, $$node_obj{NODE_ID}, undef);
    }

    return 1;
}

sub approve
{
    my ($self, $data, $node_obj, $time) = @_;

    if ($$data{TYPE} eq 'xfer') {
	if ($$node_obj{POINT} eq 'Destination Node') {
	    $self->subscribe($$data{ID}, $$node_obj{NODE_ID}, $time);
	    if ($$data{XFER_DATA}{IS_MOVE} eq 'y') {
		foreach my $src_obj (grep($$_{POINT} eq 'Source Node', values %{$$data{NODES}})) {
		    my $time_clear;
		    if (!defined $$src_obj{DECISION}) { $time_clear = 9999999999; }
		    elsif ($$src_obj{DECISION} eq 'y') { $time_clear = $time; }
		    else { next; }
		    $self->updateMoveSource($$data{ID}, $$src_obj{NODE_ID}, $time_clear);
		}
	    }
	} elsif ($$node_obj{POINT} eq 'Source Node' && $$data{XFER_DATA}{IS_MOVE} eq 'y'
		 && grep(($$_{POINT} eq 'Destination Node' && $$_{DECISION} && $$_{DECISION} eq 'y'),
			 values %{$$data{NODES}})) {
	    $self->updateMoveSource($$data{ID}, $$node_obj{NODE_ID}, $time);
	}
    } elsif ($$data{TYPE} eq 'delete') {
	if ($$data{DELETE_DATA}{RM_SUBSCRIPTIONS} eq 'y') {
	    $self->unsubscribe($$data{ID}, $$node_obj{NODE_ID}, $time);
	} 
	$self->delete($$data{ID}, $$node_obj{NODE_ID}, $time);
    }
    
    return 1;
}

sub subscribe
{
    my ($self, $rid, $node_id, $time) = @_;

    # Subscribe data to destination.  This DML ignores duplicates but
    # updates the parameters if there are duplicates, except for
    # is_custodial.
    my ($sth, $rv) = &dbexec($$self{DBH}, 
     qq[ merge into t_dps_subscription s
         using
         (select r.id, :destination destination, rdata.dataset, rdata.block,
                 rx.priority, rx.is_move, rx.is_transient, rx.is_custodial, rx.user_group
	    from t_req_request r
            join t_req_xfer rx on rx.request = r.id
            join ( select rds.request, rds.dataset_id dataset, NULL block
                     from t_req_dataset rds
                    where rds.dataset_id is not null
                    union
                   select rb.request, NULL dataset, rb.block_id block
                     from t_req_block rb
                    where rb.block_id is not null
                 ) rdata on rdata.request = r.id 
           where r.id = :request
         ) r
         on (r.destination = s.destination
             and (r.dataset = s.dataset or r.block = s.block))
         when matched then
           update set s.request = r.id,
                      s.is_move = r.is_move,
                      s.priority = r.priority,
                      s.is_transient = r.is_transient,
	              s.user_group = r.user_group
         when not matched then
           insert (request, dataset, block, destination, 
		   priority, is_move, is_transient, is_custodial, user_group, time_create)
           values (r.id, r.dataset, r.block, r.destination, 
		   r.priority, r.is_move, r.is_transient, r.is_custodial, r.user_group, :time_create) ],
			     ':request' => $rid, ':destination' => $node_id, ':time_create' => $time);

    return 1;
}

sub updateMoveSource
{
    my ($self, $rid, $node_id, $time) = @_;
    
    # Update the source subscriptions of a move
    # This query's "exists" clause contains a statement which checks every possible block
    # in the request for a match in the subscriptions table of the given node
    # this is probably quite expensive for large requests...
    my ($sth, $rv) = &dbexec($$self{DBH},
    qq[ update t_dps_subscription s
           set s.time_clear = :time_clear
         where s.destination = :destination
           and exists
               (select 1
 	          from t_req_request r
                  join ( select rds.request, b.dataset, b.id block
                           from t_req_dataset rds
                           join t_dps_block b on b.dataset = rds.dataset_id
                           where rds.dataset_id is not null
                           union
                           select rb.request, b.dataset, b.id block
                             from t_req_block rb
                             join t_dps_block b on b.id = rb.block_id 
                            where rb.block_id is not null
                        ) rdata on rdata.request = r.id
                  where r.id = :request
                    and (rdata.dataset = s.dataset or rdata.block = s.block)
               ) ],
	  ':request' => $rid, ':destination' => $node_id, ':time_clear' => $time);

    return 1;
}

sub unsubscribe
{
    my ($self, $rid, $node_id, $time) = @_;

    # Delete all subscriptions that match the request data
    # This query's "exists" clause contains a statement which checks every possible block
    # in the request for a match in the subscriptions table of the given node
    # this is probably quite expensive for large requests...
    my ($sth, $rv) = &dbexec($$self{DBH},
    qq[ delete from t_dps_subscription s
         where s.destination = :destination
           and exists
               (select 1
 	          from t_req_request r
                  join ( select rds.request, rds.dataset_id dataset, b.id block
                           from t_req_dataset rds
                           left join t_dps_block b on b.dataset = rds.dataset_id
                           where rds.dataset_id is not null
                           union
                           select rb.request, b.dataset, b.id block
                             from t_req_block rb
                             join t_dps_block b on b.id = rb.block_id 
                            where rb.block_id is not null
                        ) rdata on rdata.request = r.id
                  where r.id = :request 
                    and (rdata.dataset = s.dataset or rdata.block = s.block)
               ) ],
	  ':request' => $rid, ':destination' => $node_id);

    return 1;
}


sub delete
{
    my ($self, $rid, $node_id, $time) = @_;

    # Mark all blocks in the request data for deletion
    my ($sth, $rv) = &dbexec($$self{DBH}, 
     qq[ merge into t_dps_block_delete bd
         using
         (select r.id, rdata.dataset, rdata.block, :node node 
	    from t_req_request r
            join ( select rds.request, b.dataset, b.id block
                     from t_req_dataset rds
                     join t_dps_block b on b.dataset = rds.dataset_id
                    where rds.dataset_id is not null
                    union
                   select rb.request, b.dataset, b.id block
                     from t_req_block rb
                     join t_dps_block b on b.id = rb.block_id
                    where rb.block_id is not null 
                 ) rdata on rdata.request = r.id
           where r.id = :request
         ) r
         on (r.node = bd.node
             and r.dataset = bd.dataset
             and r.block = bd.block)
         when matched then
           update set request = r.id,
                      time_request = :time_request,
                      time_complete = NULL
            where time_complete is not null
         when not matched then
           insert (request, block, dataset, node, time_request)
           values (r.id, r.block, r.dataset, r.node, :time_request) ],
	  ':request' => $rid, ':node' => $node_id, ':time_request' => $time);

}


sub markRequestDone
{
    my ($self, $rid, $node_id, $decision, $client_id, $time, $comments_id) = @_;

    my ($sth, $rv) = &dbexec($$self{DBH}, qq{ 
	insert into t_req_decision (request, node, decision, decided_by, time_decided, comments)
	    values (:rid, :node, :decision, :decided_by, :time_decided, :comments) },
	    ':rid' => $rid, ':node' => $node_id, ':decision' => $decision, ':decided_by' => $client_id,
	    ':time_decided' => $time, ':comments' => $comments_id);
    
    return $rv ? 1 : 0;
}

sub markRequestUndone
{
    my ($self, $rid, $node_id) = @_;

    my ($sth, $rv) = &dbexec($$self{DBH}, qq{ 
	delete from t_req_decision where request = :rid and node = :node },
	':rid' => $rid, ':node' => $node_id);
    
    return $rv ? 1 : 0;
}


sub send_request_update_email
{
    my ($self, $rid, $node_actions, $comments) = @_;

    my $data = $self->getRequestData($rid);

    # Build list action descriptions
    my $action_desc = '';
    foreach my $node (keys %$node_actions) {
	my $action = $$node_actions{$node};
	if ($action eq 'null') {
	    next;
	} elsif ($action eq 'disapprove' || $action eq 'stopeval') {
	    $action_desc .= "$node => Disapproved";
	} elsif ($action eq 'approve') {
	    $action_desc .= "$node => Approved";
	}
	$action_desc .= "\n";
    }

    # A list of nodes that have been acted on
    my @action_nodes = sort grep($$node_actions{$_} ne 'null', keys %$node_actions);

    # Get a list of the sites involved in this request update
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my %sites;  # for unique list
    foreach my $node (@action_nodes) {
	$sites{ $node_sites{$node} } = 1 if exists $node_sites{$node};
    }
    
    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach my $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach my $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    my $creator_name = $$data{CREATOR_DATA}{IDENTITY}{NAME};
    my $creator_email = $$data{CREATOR_DATA}{IDENTITY}{EMAIL};
    my $detail_url = $self->myurl(page => 'Request::View', request => $rid, fullurl => 1);
    my $admin_email = $$self{SECMOD}->getEmail();
    my $msg_comments = ($comments ? "\nThe person who handled this had the following comments:\n\n\"$comments\"\n" 
			: '');
    my @cc = map { $$_{EMAIL} } @data_managers, @site_admins;
    my $nodes_str = join(', ', sort grep($$node_actions{$_} ne 'null', keys %$node_actions));
    my $newstate = $$data{REQUEST_STATE};

    my $message=<<ENDEMAIL;
Dear $creator_name,

Your request \#$rid has been acted on by $$self{USER_NAME} for $nodes_str.  The actions taken were:

$action_desc
$msg_comments
This request is now $newstate.

To review details of the request, please go to:

$detail_url

To inquire further about this request, you may reply to this email.

This message has also been CCed to the Data Managers and Site Admins of the sites involved.

Yours truly,
  PhEDEx transfer request webpage

ENDEMAIL

&send_email(subject => "PhEDEx Request Update (request \#$rid)",
	    to => [ $creator_email ],
	    cc => [ @cc ],
	    from => "PhEDEx Web Requests <$$self{CONFIG}{FEEDBACK_MAIL}>",
	    replyto => [ $admin_email ],
	    message => $message
	    ) or $self->alert("Sending request email to admins failed, sorry");;

    return 1;
}

1;




######################################################################
package Web25::Components::Status;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %offline_thresholds = ( 'FileDownload' => 60*30,
			     'FileExport'   => 60*90,
			     'InfoFileSize' => 60*30,
			     'BlockDLSUpdate' => 60*60,
			     'LoadTestInjector' => 60*20,
			     'LoadTestCleanup' => 60*60,
			     'BlockDownloadVerifyInjector' => 60*60,
			     'OTHER'        => 60*15 );
  
  
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
      select n.name, a.name, ast.label, ast.time_update
	  from t_agent_status ast
	  join t_adm_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
      my ($node, $agent, $label, $contact) = @$row;
      $status{$node}{$agent}{$label} = $contact;
      $agents{$agent} = 1;
  }

  my @infrastructure = grep exists $agents{$_}, qw(FileRouter FileIssue FilePump);
  my @workflow = grep exists $agents{$_}, qw(BlockAllocator BlockMonitor BlockDelete
					     BlockActivate BlockDeactivate BlockDLSUpdate);
  my @support = grep exists $agents{$_}, qw(BlockDownloadVerifyInjector InfoFileSize InfoStatesClean
					    InvariantMonitor PerfMonitor LoadTestInjector LoadTestCleanup);
  my @site = grep exists $agents{$_}, qw(FileDownload FileExport FileStager FileRemove BlockDownloadVerify);

  my @other;
  foreach my $agent (keys %agents) {
      push @other, $agent unless grep $agent eq $_, @infrastructure, @workflow, @support, @site;
  }

  foreach my $item ([ "Infrastructure", @infrastructure ],
		    [ "Workflow", @workflow ], ["Support", @support],
		    [ "Site", @site ], ["Other", @other])
  {
      my ($type, @agents) = @{$item};

      next unless @agents;

      my @nodes;
      if ($type =~ /(Site|Other)/) {
	  @nodes = sort keys %status;
      } else {
	  push @nodes, 'PhEDEx Central';
      }

      print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

      foreach my $node (@nodes)
      {
	  next if $type =~ /(Site|Other)/ && ! grep (defined $status{$node}{$_}, @agents);

	  print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
	  foreach my $agent (@agents)
	  {
	      my $check_node;
	      if ($node eq 'PhEDEx Central') {
		  my @running_for;
		  foreach my $n (sort keys %status) {
		      push @running_for, $n if exists $status{$n}{$agent};
		  }
		  $check_node = shift @running_for;
	      } else {
		  $check_node = $node;
	      }

	      my $offline = ( $offline_thresholds{$agent} || $offline_thresholds{OTHER} );
	      my $active = $offline / 3;

	      my @labels = keys %{$status{$check_node}{$agent}};
	      if (!@labels)
	      {
		  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
		  next;
	      }	

	      my $nagents = scalar @labels;
	      my %upstatus;
	      my $nup = 0;
	      my $recent_contact = 0;
	      my $recent_agent = $labels[0];
	      foreach my $label (@labels) {
		  my $contact = $status{$check_node}{$agent}{$label};
		  my $ago = &age($now - $contact);
		  if ($contact > $recent_contact) {
		      $recent_contact = $contact;
		      $recent_agent = $label;
		  }
		  
		  if (($now - $contact) < $active) {
		      $upstatus{$label} = { STATUS => 'UP', COLOR => $goodcolor};
		      $nup++;
		  } elsif (($now - $contact) < $offline) {
		      $upstatus{$label} = { STATUS => "UP ($ago ago)", COLOR => $goodcolor};
		      $nup++;
		  } else {
		      $upstatus{$label} = { STATUS => "DOWN ($ago ago)", COLOR => $badcolor};
		  }
	      }
	      my $overall_status = $upstatus{$recent_agent}{STATUS};
	      my $color = $upstatus{$recent_agent}{COLOR};
	      my $upratio = '';
	      if ($nagents > 1) {
		  $upratio = "<br/>(${nup}/${nagents} agents)";
	      }

	      print { $$self{CONTENT} } "<td align='center' bgcolor='$color'>$overall_status $upratio</td>";

	  }
	  print { $$self{CONTENT} } "</tr>\n";
      }
      print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web25::Components::Agents;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

    my $now = time();

    # Group by host, 
    my $sql = qq[ select s.time_update time_update,
                         n.name node_name, 
                         s.host_name,
                         s.directory_path,
                         a.name agent_name,
                         v.filename,
                         v.release,
                         v.revision,
                         v.tag,
                         s.label agent_label,
                         s.process_id pid,
                         s.worker_id, 
                         s.queue_pending q_pend,
                         s.queue_received q_recv,
                         s.queue_work q_work,
                         s.queue_completed q_comp,
                         s.queue_bad q_bad,
                         s.queue_outgoing q_out,
                         s.state state
 		    from t_agent_status s
                    join (select host_name, agent, label, process_id, min(node) node
			         from t_agent_status group by host_name, agent, label, process_id) s_sub
                      on s_sub.host_name = s.host_name and s_sub.agent = s.agent 
                     and s_sub.label = s.label and s_sub.node = s.node
		     and s_sub.process_id = s.process_id
		    join t_adm_node n on s.node = n.id
                    join t_agent a on s.agent = a.id
                    left join t_agent_version v on v.agent = a.id and v.node = n.id and v.filename = a.name
		   order by n.name, s.host_name, s.directory_path, s.label, s.worker_id ];
    my $q = &dbexec($$self{DBH}, $sql);

    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{ CONTENT });
    
    $dbtable->set_querycols( [('Age', 'pcolumn', 'TIME_UPDATE', 1)],
			     [('Node', 'pcolumn', 'NODE_NAME', 1)],
			     [('Host', 'pcolumn', 'HOST_NAME', 1)],
			     [('Path', 'pcolumn', 'DIRECTORY_PATH', 1)],
			     [('Agent Name', 'pcolumn', 'AGENT_NAME', 1)],
			     [('File and Version Columns', 'pcolumn', 'FILENAME:RELEASE:REVISION:TAG', 0)],
			     [('Agent Label', 'pcolumn', 'AGENT_LABEL', 1)],
			     [('Process', 'pcolumn', 'PID', 1)],
			     [('Worker', 'pcolumn', 'WORKER_ID', 1)],
			     [('Queue State Columns', 'pcolumn', 'Q_PEND:Q_RECV:Q_WORK:Q_BAD:Q_OUT', 1)] 
			     );
    $dbtable->set_tablehead({
	TIME_UPDATE => 'Age',
	NODE_NAME => 'Node',
	AGENT_NAME => 'Agent Name',
	AGENT_LABEL => 'Agent Label',
	PID => 'Process',
	HOST_NAME => 'Host',
	WORKER_ID => 'Worker',
	Q_PEND => 'Pending',
	Q_RECV => 'Received',
	Q_WORK => 'Work',
	Q_COMP => 'Completed',
	Q_BAD => 'Bad',
	Q_OUT => 'Outgoing',
	FILENAME => 'Filename',
	DIRECTORY_PATH => 'Path',
	RELEASE => 'Version Release',
	REVISION => 'Version Revision',
	TAG => 'Version Tag'
	});

    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    $dbtable->set_dataformats({
	TIME_UPDATE => sub { &age($now - $_[0]) }
    });

    my $nullsub = sub { $_[0] ? 'goodbg' : '' };
    $dbtable->set_cellformats({
	TIME_UPDATE => sub { $now - $_[0] <= (1.5)*3600 ? '' : 'alarm' },
	P_ID => sub { $_[1]->{STATE} ? '' : 'alarm' },
	Q_PEND => $nullsub,
	Q_RECV => $nullsub,
	Q_WORK => $nullsub,
	Q_COMP => $nullsub,
	Q_BAD => $nullsub,
	Q_OUT => $nullsub
    });

    my $nrows = $dbtable->output($q);
    if ($nrows == 0) {
	$self->alert("No process data available.");
    }

    #  Options form
    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = $dbtable->columns_form();
    $optspane->add_tab('Columns', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;



######################################################################
package Web25::Components::Links;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Links",
	       LINK_TITLE => "View PhEDEx Topology" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    my $from_filter = param('from_filter') || '.*';
    my $to_filter = param('to_filter') || '.*';
    my $andor = param('andor') || 'and';

    print {$$self{CONTENT}}
    "<form method='get' action='#' class='nice'/>",
    "<label class='inline'>Show links matching from </label>",
    textfield(-name=>'from_filter', -value=>$from_filter, -class=>'labeled'),
    popup_menu(-name=>'andor',
	       -values=>['and', 'or'],
	       -class=>'labeled'),
    "<label class='inline'>to</label>",    
    textfield(-name=>'to_filter', -value=>$to_filter, -class=>'labeled'),
    submit(-name=>'Update', -class=>'labeled'), "<br/>",
    "</form>";

    my @legend = (['Link exists and is valid', 'green'],
		  ['Link exists, but agents are down', 'red'],
		  ['Link exists, but is excluded', 'orange'],
		  ['Link is deactivated', 'purple'],
		  ['Link does not exist', 'white'],
		  ['Self-reference', 'black']);
    
    print {$$self{CONTENT}} 
    "<table style='float:left;border: 1px solid black;margin-bottom:3px;'><tr><th colspan='2' align='center'>Legend</th></tr>";
    foreach my $pair (@legend) {
	my ($def, $color) = @{$pair};
	print {$$self{CONTENT}}
	"<tr><td><div style='border:1px solid black;width:40px;background-color:$color;'>&nbsp;</div></td>",
	"<td>$def</td></tr>";
    }
    print {$$self{CONTENT}} "</table>";

    print {$$self{CONTENT}}
    "<p style='float:left;width:35em;margin-left:1em;'>",
    "This page displays links between nodes in PhEDEx.  Valid links ",
    "are required for transfers to be possible.  ",
    "Links are invalid when the source/destination node agents are down or they actively ",
    "exclude the other node with the -ignore/-accept options.  ",
    "Links may also be deactivated by the PhEDEx administrators.  ",
    "<b>Warning:</b> Nodes that have never connected to the database are marked as excluded, which is not correct.",
    "</p><br clear='all'/>";
    $from_filter = qr/$from_filter/;
    $to_filter = qr/$to_filter/;

    my $sql = qq{ select fn.name from_node, tn.name to_node, l.is_active, fn.kind from_kind, tn.kind to_kind,
		         xso.time_update source_update, xso.protocols source_protos,
		         xsi.time_update sink_update,   xsi.protocols sink_protos
		    from t_adm_link l
		    join t_adm_node fn on fn.id = l.from_node
		    join t_adm_node tn on tn.id = l.to_node
		    left join t_xfer_source xso
		      on xso.from_node = fn.id
		     and xso.to_node = tn.id
		    left join t_xfer_sink xsi
		      on xsi.from_node = fn.id
		     and xsi.to_node = tn.id
	       };
    my $now = time();
    my $downtime = 5400 + 15*60;  # Hour and a half (real expiration) + 15 minutes grace time
    my $links = &dbexec($$self{DBH}, $sql)->fetchall_arrayref();
    my %link_params;

    my (%from_nodes, %to_nodes);
    foreach my $link (@{$links}) {
	my ($from, $to, $is_active, $from_kind, $to_kind, 
	    $xso_update, $xso_protos, $xsi_update, $xsi_protos) = @{$link};
	my $key = $from.'-->'.$to;
	$link_params{$key} = { EXISTS => 1,
			       IS_ACTIVE => $is_active,
			       XSI_UPDATE => $xsi_update,
			       XSO_UPDATE => $xso_update,
			       FROM_KIND => $from_kind,
			       TO_KIND => $to_kind,
			       XSO_PROTOS => $xso_protos,
			       XSI_PROTOS => $xsi_protos
			       };

	# Explain why links are valid or invalid.  For now we benefit
	# from the fact the xfer_source/xfer_sink tables are never
	# cleaned up.  Exclusion deletes from xfer_source, and
	# xfer_sink, so if there is an old update we know the agent is
	# down, if there is no entry, we know the node has been
	# excluded.  It would be nice to do a more explicit check for
	# this but for now the logic is ok.
	if ($from_kind eq 'MSS' && $to_kind eq 'Buffer') { # Staging link
	    $link_params{$key}{VALID} = 1;
	    $link_params{$key}{REASON} = 'Staging link OK';
	} elsif ($from_kind eq 'Buffer' && $to_kind eq 'MSS') { # Migration link
	    if (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Migration agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Migration agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'Migration link OK';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	} else { # WAN link
	    if (!$xso_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Source agent excluded';
	    } elsif ($xso_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Source agent down';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
	    } elsif (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Destination agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Destination agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'WAN Link OK';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	}

 	# Check active state
 	if ($link_params{$key}{IS_ACTIVE} ne 'y') {
 	    $link_params{$key}{VALID} = 0;
 	    $link_params{$key}{REASON} = "Link is deactivated";
 	}
	
	# Check protocols
	if ($link_params{$key}{VALID}) {
	    my @from_protos = split(/\s+/, $xso_protos || '');
	    my @to_protos   = split(/\s+/, $xso_protos || '');
	    my $match = 0;
	    foreach my $p (@to_protos) {
		next if ! grep($_ eq $p, @from_protos);
		$match = 1;
		last;
	    }
	    unless ($match) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = "No matching protocol";
	    }
	}

	my $from_match =  ($from =~ /$from_filter/);
	my $to_match = ($to =~ /$to_filter/);
	if (($andor eq 'and' && ($from_match && $to_match)) ||
	    ($andor eq 'or'  && ($from_match || $to_match))) {
	    $from_nodes{$from} = 1;
	    $to_nodes{$to} = 1;
	}
    }
    my @from_nodes = sort keys %from_nodes;
    my @to_nodes = sort keys %to_nodes;

    my $table = new Web25::TableSpool;
    $table->set_filehandle($$self{CONTENT});
    $table->set_tableclass('data dense rspace');
    $table->set_tablecols(['FROM_NODE', @to_nodes]);
    $table->set_tablehead({'FROM_NODE' => 'From Node &darr; To Node &rarr;'});
    $table->set_cellformats({FROM_NODE => sub { 'head' }});
    
    $table->start();
    $table->head();
    
    foreach my $from (@from_nodes) {
	my $row = {};
	foreach my $to (@to_nodes) {
	    $$row{FROM_NODE} = $from;
	    my $key = $from.'-->'.$to;
	    my $link = $link_params{$key};
	    my $color;
	    if ($from eq $to) { 
		$color = 'black';
	    } elsif ( $$link{EXISTS} && 
		      $$link{IS_ACTIVE} ne 'y' ) {
		$color = 'purple';
	    } elsif ($$link{EXISTS} 
		     && $$link{VALID}) {
		$color = 'green';
	    } elsif ($$link{EXCLUDED}) {
		$color = 'orange';
	    } elsif ( $$link{EXISTS} ) {
		$color = 'red';
	    } else {
		$color = 'white';
	    }
	    # Tooltips only for existing links, for performance reasons
	    my $tooltip = $$link{EXISTS} ? $self->get_tooltip($key, $link, $now) : '';
	    my $cell = "<div class='ttp' style='background-color:$color;'>&nbsp;$tooltip</div>"; 
	    $$row{$to} = $cell;
	}
	$table->row($row);
    }
    
    $table->finish();
}

sub get_tooltip
{
    my ($self, $key, $link, $now) = @_;
    $key =~ s/-->/ &rarr; /;
    my $msg = '';
    my $color = $$link{VALID} ? 'green' : 'red';
    if ($$link{EXISTS}) {
	$msg .= "<p>$$link{REASON}</p>";
	$msg .= "<p>Source update:  $$link{XSO_AGE} ago</p>" if $$link{XSO_AGE};
	$msg .= "<p>Destination update:  $$link{XSI_AGE} ago</p>" if $$link{XSI_AGE};
    } else {
	$msg = $$link{COMMENT};
    }
    return "<div class='tt'><p><b>$key</b></p><span style='color:$color;'>$msg</span></div>";
}

1;



######################################################################
package Web25::Activity::Rate;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::TransferRate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  @save = qw(andor tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::TransferDetails");
  @save = qw(tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::ErrorInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my %stats = ();
  my @spans = qw(h 2h d w m);
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  my $span = param('span') || $spans[0];
  $span = $spans[0] if ! grep($span eq $_, @spans);
  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files
    from t_history_link_events h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_history_link_stats h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    next if ! exists $stats{$span};
    $stats{$span}{N}{$key}{PARAM_RATE} = $$row{PARAM_RATE};
    $stats{$span}{N}{$key}{PARAM_LATENCY} = $$row{PARAM_LATENCY};
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  my $errors = param('errors') ? "checked='checked'" : "";
  my $tofilter = param('tofilter') || "";
  my $fromfilter = param('fromfilter') || "";
  my $andor = param('andor') || 'or';
  print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'><tbody>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n";

  foreach my $kind (qw(N T))
  {
      no warnings 'uninitialized'; # XXX being lazy here...
      foreach my $row (sort { 
	                       $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];

      my $errorcolumn = &format_num($$row{FAIL_FILES});
      if ($$row{FAIL_FILES} && $$row{FROM_NODE} && $$row{TO_NODE}) {
	  my $errorurl = $self->myurl(page => 'Activity::ErrorInfo',
				      fromfilter => $$row{FROM_NODE},
				      tofilter => $$row{TO_NODE});
	  $errorcolumn = "<a href='$errorurl'>$errorcolumn</a>";
      }

      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>$errorcolumn</a></td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></p></form>\n";
}

1;

######################################################################
package Web25::Activity::PlotPage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  $$self{PERIOD_ORDER} = [ qw(l12h l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PERIODS} = {
      "l12h" => [ "12:hour", "Last 12 Hours" ],
      "l24h" => [ "24:hour", "Last 24 Hours" ],
      "l48h" => [ "48:hour", "Last 48 Hours" ],
      "l72h" => [ "72:hour", "Last 72 Hours" ],
      "l96h" => [ "96:hour", "Last 96 Hours" ],
      "l132h" => [ "132:hour", "Last 132 Hours" ],
      "l7d" => [ "7:day", "Last 7 Days" ],
      "l14d" => [ "14:day", "Last 14 Days" ],
      "l30d" => [ "30:day", "Last 30 Days" ],
      "l45d" => [ "45:day", "Last 45 Days" ],
      "l90d" => [ "90:day", "Last 90 Days" ],
      "l120d" => [ "120:day", "Last 120 Days" ],
      "l6w" => [ "6:week", "Last 6 Weeks" ],
      "l26w" => [ "26:week", "Last 26 Weeks" ],
      "l52w" => [ "52:week", "Last 52 Weeks" ],
      "ad" => [ "0:day", "Daily Since Start" ],
      "aw" => [ "0:week", "Weekly Since Start" ],
      "am" => [ "0:month", "Monthly Since Start" ] };
  $$self{DEFAULT_PERIOD} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  $$self{ENTITY_ORDER} = [qw(dest src link)];
  $$self{ENTITIES} = {dest => 'Destination', src => 'Source', link => 'Link'};
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(period graph entity src_filter dest_filter no_mss upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  $$self{GRAPHTOOL} = "$$self{CONFIG}{GRAPHTOOL_URL}";

  my $page = param("page");
  my $period = param("period");
  my $graph = param("graph");
  my $entity = param("entity");
  my $src_filter = param("src_filter") || '';
  my $dest_filter = param("dest_filter") || '';
  my $no_mss = param("no_mss");
  if (!defined $no_mss) { $no_mss = 'true'; } # Filter MSS by default
  my $upto = param("upto") || '';
  $period = $$self{DEFAULT_PERIOD} if (! $period || ! exists $$self{PERIODS}{$period});
  $graph = $$self{DEFAULT_GRAPH} if (! $graph || ! exists $$self{GRAPHS}{$graph});
  $entity = 'dest' if (! $entity || ! grep($_ eq $entity, @{$$self{ENTITY_ORDER}} ));
  

  my $dest_filter_name = 'destination';
  if (exists $$self{DEST_ONLY_GRAPHS}
      && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      $$self{ENTITY_ORDER} = ['dest'];
      $$self{ENTITIES} = { dest => 'Node' };
      $dest_filter_name = 'node';
  }

  my $formurl = $self->myurl();

  print { $$self{CONTENT} } 
  "<form method='get' action='$formurl' class='nice'>\n",
  "<label for='graph' class='inline'>Graph</label>\n",
  popup_menu(-name=>'graph', -onchange=>'submit()',
	     -values=>$$self{GRAPH_ORDER},
	     -labels=>$$self{GRAPHS},
	     -class=>'labeled'),
  "<label for='entity' class='inline'>by</label> ",
  popup_menu(-name=>'entity', -onchange=>'submit()', 
	     -values=>$$self{ENTITY_ORDER},
	     -labels=>$$self{ENTITIES},
	     -class=>'labeled'),
  "<label class='inline'>filter</label>";

  unless (exists $$self{DEST_ONLY_GRAPHS} && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      print { $$self{CONTENT} }
      "<label class='inline' for='src_filter'>source</label>",
      textfield(-name=>'src_filter', -size=>15,
		-title=>("Regular expression to match against node names. "
			 ."Only those matching the expression will be shown."),
		-class=>'labeled');
  } else { print {$$self{CONTENT}} hidden('src_filter'); }

  print { $$self{CONTENT} }
  "<label class='inline' for='dest_filter'>$dest_filter_name</label>",
  textfield(-name=>'dest_filter', -size=>15,
	    -title=>("Regular expression to match against node names. "
		     ."Only those matching the expression will be shown."),
	    -class=>'labeled'),
  popup_menu(-name=>'no_mss', -values=>['true', 'false'], -labels=>{'true' => 'hide MSS nodes', 'false' => 'show MSS nodes'},
	     -default=>$no_mss, -onchange=>'submit()', -class=>'labeled'),
  "<br/>";
  
  print { $$self{CONTENT} }
  "<label for='period' class='inline'>Period</label>\n",
  popup_menu(-name=>'period', -onchange=>'submit()',
	     -values=>$$self{PERIOD_ORDER},
	     -labels=>{ map { $_ => $$self{PERIODS}{$_}[1] } @{$$self{PERIOD_ORDER}} },
	     -default=>$period,
	     -class=>'labeled'),
  "<label for='upto' class='inline'>up to</label>",
  textfield(-name=>'upto', -size=>15,
	    -title=>("Time up to and including which results will be shown. "
		     ."Specify the time in format matching the selected period:\n"
		     ."YYYYMMDDZHHMM for hourly periods;\n"
		     ."YYYYMMDD for daily periods;\n"
		     ."YYYYMM for monthly periods;\n"
		     ."YYYYWW for weekly periods."),
	    -class=>'labeled'),
		     submit(-label=>'Update', -class=>'labeled'), "<br/>",
		     "</form>";

  my ($last, $unit) = $$self{PERIODS}{$period}[0] =~ /([^:]+)/g;
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  # The new plot package really does set range to time 0.
  # Need to provide a more reasonable range.  PhEDEx started taking data in Sep 2004.
  $start = timegm(0, 0, 0, 1, 9, 2004-1900) if $start == 0;  

  my $conn = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{CONNECTION};

  my %args = ('conn' => $conn, 'unit' => $unit, 'span' => $span{$unit}, 'by' => $entity, 'last' => $last,
              'src_filter' => $src_filter, 'dest_filter' => $dest_filter, 'no_mss' => $no_mss,
	      'upto' => $upto, 'starttime' => $start, 'endtime' => $end);
  
  my $imgsrc = $self->imgsrc($graph, %args);
  print {$$self{CONTENT}} "<p><img src='$imgsrc' /></p>";

#   &dump_var($$self{CONTENT}, 'tns_admin', $ENV{TNS_ADMIN});
#   print {$$self{CONTENT}} "<pre>";
#   print {$$self{CONTENT}}<<STOP;
#       no_mss:  $no_mss
#  dest_filter:  $dest_filter
#   src_filter:  $src_filter
#      formurl:  $formurl
#       imgsrc:  $imgsrc
# STOP
# print {$$self{CONTENT}} "</pre>";
#   &dump_var($$self{CONTENT}, 'args', {%args});
#   &dump_params($$self{CONTENT});

}

1;

######################################################################
package Web25::Activity::RatePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quantity_rates';
  $$self{GRAPH_ORDER} = [ 'quantity_rates', 'quantity', 'quantity_cumulative' ];
  $$self{GRAPHS} = { 'quantity_rates' => "Transfer Rate", 
		     'quantity' => "Transfer Volume", 
		     'quantity_cumulative' => "Cumulative Rate" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QueuePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'destined', 'resident', 'pending', 'request', 'idle', 'cooloff' ];
  $$self{GRAPHS} = { 'destined' => "Volume Routed",    # by dest only
		     'resident' => "Volume Resident",     # by dest only
		     'pending'  => "Volume Queued", # any
		     'request'  => "Volume Requested",    # by dest only
		     'idle'     => "Volume Idle",  # by dest only
		     'cooloff'  => 'Volume Cool-off' };   # any

  $$self{DEST_ONLY_GRAPHS} = [ qw( destined resident request idle ) ];

  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $dest_only = (grep($graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) ? 1 : 0);
  if ($dest_only && $args{by} ne 'dest') {
      $self->alert("The \"$$self{GRAPHS}{$graph}\" graph can only show data by destination");
      return;
  } elsif ($dest_only) {
      $graphargs{node} = $to_node;
      delete $graphargs{from_node};
      delete $graphargs{to_node};
  }

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QualityPlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quality_all';
  $$self{GRAPH_ORDER} = [ 'quality_all', 'quality_try', 'quality_done', 'quality_fail' ];
  $$self{GRAPHS} = { 'quality_all' => "Quality Map",
		     'quality_try' => "Attempts",
		     'quality_done' => "Successes",
		     'quality_fail' => "Failures" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('to_node' => $to_node,
		   'from_node' => $from_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::Routing;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Routing",
	       LINK_TITLE => "Show current routing information" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my $tofilter = param('tofilter') || ".*";
  my $fromfilter = param('fromfilter') || ".*";
  my $priority = param('priority') || 'any';
  my $blockfilter = param('blockfilter') || '.*';
  my $showinvalid = param('showinvalid') || 0;

  my $now = time();
  my @nodes = sort $self->fetch_nodes();

  print {$$self{CONTENT}}
  "<form class='nice' method='get' action='#'>",
  "<label>Show paths on links to </label>",
  textfield(-name=>'tofilter', -default=>$tofilter, -size=>15, -class=>'labeled'),
  "<label class='inline'>and from </label>",
  textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15, -class=>'labeled'),
  "<label class='inline'> with  </label>",
  popup_menu(-name=>'priority', -values=>['any', 'high', 'normal', 'low'],
	     -default=>$priority, -onchange=>'submit()', -class=>'labeled'),
  "<label class='inline'> priority  </label>",
  checkbox(-name=>'showinvalid', -checked=>$showinvalid, -label=>'Show Invalid Paths', -class=>'labeled'),
  "<br/><label>Filter blocks </label>",
  textfield(-name=>'blockfilter', -default=>$blockfilter, -size=>15, -class=>'labeled'),
  " ", submit(-name=>'Update'),
  "</form><br clear='all'>";

  my $query = qq{
      select nd.name destination, ns.name source, b.name block,
             s.priority, s.is_valid, s.route_files, s.route_bytes, s.xfer_attempts, s.time_request
       from t_status_block_path s
       join t_adm_node nd on nd.id = s.destination
       join t_adm_node ns on ns.id = s.src_node
       join t_dps_block b on b.id = s.block
       order by s.time_request
  };

  my $q = &dbexec($$self{DBH}, $query);

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  my @cols = qw(DESTINATION SOURCE BLOCK PRIORITY ROUTE_FILES ROUTE_BYTES
		XFER_ATTEMPTS AVG_ATTEMPTS TIME_REQUEST);
  unshift(@cols, 'IS_VALID') if $showinvalid;

  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead({
      DESTINATION => 'Destination',
      SOURCE => 'Source',
      BLOCK => 'Block Name',
      PRIORITY => 'Priority',
      IS_VALID => 'Valid?',
      ROUTE_FILES => 'Routed<br/>Files',
      ROUTE_BYTES => 'Routed<br/>Bytes',
      XFER_ATTEMPTS => 'Transfer<br/>Attempts',
      AVG_ATTEMPTS => 'Average<br/>Attempts',
      TIME_REQUEST => 'Earliest<br/>Request'
      });

  $dbtable->set_dataformats({
       'PRIORITY' => sub { my $name;
 			  if    ($_[0] == 0) {$name = 'high'}
 			  elsif ($_[0] == 1) {$name = 'normal'}
 			  else               {$name = 'low' }
 			  return $name; },
      'IS_VALID' => sub { $_[0] ? 'valid' : 'invalid' },
      'ROUTE_BYTES' => sub { &format_size($_[0]) },
      'TIME_REQUEST' => sub { &age($now - $_[0])." ago" },
      'AVG_ATTEMPTS' => sub { sprintf("%.2f", $_[0]) }
  });

  $dbtable->add_pseudocolumn('AVG_ATTEMPTS', sub { return $_[1]->{ROUTE_FILES} ? 
						       $_[1]->{XFER_ATTEMPTS} / $_[1]->{ROUTE_FILES}
						   : 'N/A' });

  $dbtable->set_filters({
      'DESTINATION' => sub { $_[0] =~ /$tofilter/ ? 1 : 0 },
      'SOURCE' => sub { $_[0] =~ /$fromfilter/ ? 1 : 0 },
      'BLOCK' => sub { $_[0] =~ /$blockfilter/ ? 1 : 0 },
      'IS_VALID' => sub { $showinvalid || $_[0] == 1 ? 1 : 0 },
      'PRIORITY' => sub { ($priority eq 'any'
			   || ($priority eq 'high'   && $_[0] == 0)
			   || ($priority eq 'normal' && $_[0] == 1)
			   || ($priority eq 'low'    && $_[0] >= 2)) ? 1 : 0 }
  });

  $dbtable->set_cellformats({
      'AVG_ATTEMPTS' => sub { $_[0] >= 3 ? 'alarm' : '' },
      'TIME_REQUEST' => sub { ($now - $_[0]) > 3600*24*3 ? 'alarm' : '' },
      'IS_VALID' => sub { $showinvalid && $_[0] == 0 ? 'alarm' : '' }
  });

  $dbtable->set_statcols({
      'ROUTE_FILES' => 'SUM',
      'ROUTE_BYTES' => 'SUM'
      });

  my $nrows = $dbtable->output($q);

  if ($nrows == 0) {
      $self->note("No results available.");
  }
}

1;

######################################################################
package Web25::Activity::TransferDetails;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;

    # Transfer state details
    my $rows = 0;
    my $now = time();
    my %total = ();
    my $tofilter = param('tofilter') || "";
    my $fromfilter = param('fromfilter') || "";
    my $andor = param('andor') || 'or';
    my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      state, priority,
      files, bytes
    from t_status_task xs
      join t_adm_node ns on ns.id = xs.from_node
      join t_adm_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, state});

    print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='10' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th rowspan='2'>Age</th>\n",
    " <th>To Node</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>Transfer</th>\n",
    " <th rowspan='2'>Priority</th>\n",
    " <th rowspan='2'>N Files</th>\n",
    " <th rowspan='2'>Size</th>\n",
    " <th rowspan='2'>Detail</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>\n",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")
	      ),
     "</th>",
     "<th>",
     "<select name='andor' onchange='submit()'>",
     " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
     "  value='and'>and</option>",
     " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
     "  value='or'>or</option>",
     "</select>",
     "</th>",
     "<th>",
     textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	       -title=>("Regular expression to match against node or link names. "
			."Only those matching the expression will be shown.")),
     "</th>",
     "</tr>\n";
    
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $state, $priority,
	    $files, $bytes) = @$row;

	next if (($fromfilter || $tofilter)
		 && ($andor eq 'or'
		     ? ! (($fromfilter && $from_node =~ /$fromfilter/)
			  || ($tofilter && $to_node =~ /$tofilter/))
		     : ! (($fromfilter && $from_node =~ /$fromfilter/)
			  && ($tofilter && $to_node =~ /$tofilter/))));
	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $transfer_name = ($priority % 2 == 0 ? 'local' : 'remote'); # Local even, remote odd
	my $priority_name = ($priority == 0 || $priority == 1 ? 'high'
			     : $priority == 2 || $priority == 3 ? 'normal'
			     : $priority == 4 || $priority == 5 ? 'low'
			     : 'unknown');
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	my $url = $self->myurl("page" => "Activity::FileInfo",
			       "to_node" => $to_node,
			       "from_node" => $from_node,
			       "state" => $state_name,
			       "priority" => $priority
			       );
	print { $$self{CONTENT} }
	"<tr>\n",
	" <td$stampcolor>", ($now - $stamp < 5*60 ? 'current' : &age($now - $stamp)), "</td>\n",
	" <td>$to_node</td>\n",
	" <td align='right'>&nbsp;</td>\n",
	" <td>$from_node</td>\n",
	" <td align='left'>$state_name</td>\n",
	" <td align='left'>$transfer_name</td>\n",
	" <td align='left'>$priority_name</td>\n",
	" <td align='right'>@{[&format_num($files)]}</td>\n",
	" <td align='right'>@{[&format_size($bytes)]}</td>\n",
	" <td align='center'><a href='$url'>(Files)</a></td>\n",
	"</tr>\n";
    }
    
    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	
	print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
	$first_total = 0;
    }

    print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";

    # Destined
    $rows = 0;
    $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_adm_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    "<th align='center' colspan='8'>Destined Data</th>\n",
    "</tr>",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $n =~ /$fromfilter/)
		   || ($tofilter && $n =~ /$tofilter/)));

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";


    # Replicas
  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.files, xr.bytes
    from t_status_replica xr join t_adm_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='5' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;


######################################################################
package Web25::Activity::Deletions;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 7, TITLE => "Deletions",
	       LINK_TITLE => "View Deletion Queue",
               SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my $self = shift @_;

    my @reqfilter  = grep(/^\d+$/, split(/\s*,*\s+/, param('reqfilter')));
    my $nodefilter  = param('node') ||'Enter a node name';
    my $blockfilter = param('blockfilter') || '.*';
    my $state    = param('state') || 'any';

    print { $$self{CONTENT} }
    "<p class='blocktext'>",
    "This page shows the blocks which are queued for deletions.  The record of ",
    "completed block deletions is removed after three days.</p>",
    "<form class='nice' method='get' action='#'>",
    "<label class='inline'>Show deletions from requests </label>",
    textfield(-name=>'reqfilter', -size=>15, -class=>'labeled'),
    "<label class='inline'> at node </label>",
    textfield(-name=>'node', -default=>$nodefilter, -size=>15, -class=>'labeled'),
    "<label class='inline'> with state </label>",
    popup_menu(-name=>'state', -values=>['any', 'pending', 'complete'],
	       -default=>$state, -class=>'labeled'),
    "<label class='inline'> filter blocks </label>",
    textfield(-name=>'blockfilter', -default=>$blockfilter, -size=>15, -class=>'labeled'),
    " ", submit(-name=>'Update'),
    "</form><br clear='all'>";

    my @where = ('1=1');
    my %binds;
    my %all_nodes = $self->fetch_nodes(with_ids=>1);
    my @select_nodes = grep /$nodefilter/, keys %all_nodes;

    if (! @select_nodes ) {
	$self->note('No nodes match the given filter');
	return;
    }

    if (scalar @select_nodes < scalar keys %all_nodes) {
	my $list;
	($list, %binds) = &dbinlist('node', map { $all_nodes{$_} } @select_nodes);
	push @where,"n.id in ($list)";
    }

    if (@reqfilter) {
	my ($l, %b) = &dbinlist('request', @reqfilter);
	push @where, "del.request in ($l)";
	$binds{$_} = $b{$_} for keys %b;
    }

    my $where = join ' and ', @where;

    my $sql = qq{ select del.request, n.name node, b.name block, b.files, b.bytes, del.time_request, del.time_complete
		      from t_dps_block_delete del
		      join t_dps_block b on b.id = del.block
		      join t_adm_node n on n.id = del.node
		      where $where
		      order by del.time_complete desc, del.time_request desc };
    

    my $q = &dbexec($$self{DBH}, $sql, %binds);
    
    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{CONTENT});
    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    $dbtable->set_tablehead({ 
	REQUEST => 'Request',
	NODE => 'Node',
	BLOCK => 'Block',
	FILES => 'Files',
	BYTES => 'Size',
	TIME_REQUEST => 'Requested',
	TIME_COMPLETE => 'Completed' });

    my $reqpage = $self->myurl(page => 'Request::View');
    $dbtable->set_dataformats({ 
	REQUEST => sub { return defined $_[0] ? "<a href='${reqpage}?request=$_[0]'>$_[0]</a>" : 'unknown'; },
	BYTES => sub { &format_size($_[0]) },
	TIME_REQUEST  => sub { &formatTime($_[0], 'stamp') },
	TIME_COMPLETE => sub { $_[0] ? &formatTime($_[0], 'stamp') : 'Pending' } });

    $dbtable->set_filters({
	'BLOCK' => sub { $_[0] =~ /$blockfilter/ ? 1 : 0 },
	'TIME_COMPLETE' => sub { return 1 if $state eq 'any';
				 return 1 if $state eq 'pending' && !defined $_[0];
				 return 1 if $state eq 'complete'&& defined $_[0];
				 return 0;
			     }
    });
    
    $dbtable->set_statcols({
	'FILES' => 'SUM',
	'BYTES' => 'SUM'
	});

    my $nrows = $dbtable->output($q);

    if ($nrows == 0) {
	$self->note("No results available.");
    }
    
}

1;



######################################################################
package Web25::Activity::FileInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "File Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $to_node = param('to_node');
  my $from_node = param('from_node');
  my $state = param('state');
  my $priority = param('priority');
  if (! defined $to_node || $to_node eq ''
      || ! defined $from_node || $from_node eq ''
      || ! defined $state || $state eq ''
      || ! defined $priority || $priority eq ''
      )
  {
    print { $$self{CONTENT} }
    $self->alert('Missing Arguments');
    return;
  }

  my $state_join = '';
  my $state_where = '';
  if    ($state eq 'exported')     { 
      $state_join = 'join t_xfer_task_export ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_inxfer )';
  } elsif ($state eq 'transferring') { 
      $state_join = 'join t_xfer_task_inxfer ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_done )';
  } elsif ($state eq 'transferred')  { 
      $state_join = 'join t_xfer_task_done ts on ts.task = xt.id'; }
  elsif ($state eq 'assigned') {
      $state_where = 'and xt.id not in ( select task from t_xfer_task_export )';
  } else {
      $self->alert('Invalid state');
  }
     
  my $sql = qq{
    select f.id, f.logical_name, f.filesize, xt.from_pfn, xt.to_pfn,
	   xt.time_assign, err.cnt num_errors
      from t_xfer_task xt
      $state_join
      join t_xfer_file f on f.id = xt.fileid
      join t_adm_node ns on ns.id = xt.from_node
      join t_adm_node nd on nd.id = xt.to_node
      left join (select xe.fileid, xe.from_node, xe.to_node, count(*) cnt 
                   from t_xfer_error xe
                  group by xe.fileid, xe.from_node, xe.to_node
                 ) err 
           on     err.fileid = xt.fileid 
              and err.from_node= xt.from_node 
              and err.to_node = xt.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      and xt.priority = :priority
      $state_where
      order by xt.time_assign, f.logical_name};

  my $query = &dbexec($$self{DBH}, $sql, 
		      ':from_node' => $from_node,
		      ':to_node' => $to_node,
		      ':priority' => $priority);
  print { $$self{CONTENT} }
    "<h1>Files $state from $from_node to $to_node.</h1>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($fileid, $lfn, $size, $from_pfn, $to_pfn, $assigned, $nerrors) = @$row;
    my $errorurl = $self->myurl('page' => 'Activity::ErrorInfo',
				'tofilter' => $to_node,
				'fromfilter' => $from_node,
				'fileid' => $fileid);
    print { $$self{CONTENT} }
    "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
    "<b>size</b>=$size<br />",
    ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
    ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
    ($nerrors ? "<span class='alarm'><b>errors</b>=$nerrors</span> <a href='$errorurl'>(View)</a><br />"  : ""),
    ($assigned ? "<b>time_assign</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($assigned))]} UTC<br />" : ""),
    "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;



######################################################################
package Web25::Activity::ErrorInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 8, TITLE => "Recent Errors" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}


sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor
		report_code xfer_code from_pfn to_pfn log_detail log_validate);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}



sub output
{
    my ($self) = @_;

    my $fileid = param('fileid');
    my $tofilter = param('tofilter') || '.*';
    my $fromfilter = param('fromfilter') || '.*';

    my @filter_list = qw(report_code xfer_code from_pfn to_pfn log_detail log_validate);
    my $error_filters = {};
    foreach (@filter_list) {
	$$error_filters{$_} = param($_) || '.*';
    }

    my @nodes = sort $self->fetch_nodes();

    my @where;
    my %binds;
    if ($fileid) {
	push @where, qq[xe.fileid = :fileid];
	$binds{':fileid'} = $fileid;
    } else {
	print {$$self{CONTENT}}
	&help("Filtering Help", "Filtering Help", 
	      "The <b>to</b> and <b>from</b> node filters are perl regular expressions.  ",
	      "The rest of the filters are Oracle regular expressions (regexp_like function) ",
	      "with one special option: You may put '!' as the first ",
	      "character in the field to only return results which do ",
	      "NOT match the given regular expession.  For performance ",
	      "reasons, you must filter one of <b>to</b> or <b>from</b> ",
	      "if you wish to filter on any of the other fields.  The ",
	      "<b>Transfer Log</b> cannot be ", "filtered due to its ",
	      "large size."),
   	"<form method='get' action='#' class='nice'/>",
	"<label>Show errors on links to </label>",
	textfield(-name=>'tofilter', -value=>$tofilter, -class=>'labeled'),
	"<label>from</label>",
	textfield(-name=>'fromfilter', -value=>$fromfilter, -class=>'labeled'), "<br/>",
	"<label>Report Code:</label>",
	textfield(-name=>'report_code', -value=>$$error_filters{report_code}, -class=>'labeled'),
	"<label>Transfer Code:</label>",
	textfield(-name=>'xfer_code', -value=>$$error_filters{xfer_code}, -class=>'labeled'), "<br/>",
	"<label>To PFN:</label>",
	textfield(-name=>'to_pfn', -value=>$$error_filters{to_pfn}, -class=>'labeled'),
	"<label>From PFN:</label>",
	textfield(-name=>'from_pfn', -value=>$$error_filters{from_pfn}, -class=>'labeled'), "<br/>",
	"<label>Detail Log:</label>",
	textfield(-name=>'log_detail', -value=>$$error_filters{log_detail}, -class=>'labeled'),
	"<label>Validate Log:</label>",
	textfield(-name=>'log_validate', -value=>$$error_filters{log_validate}, -class=>'labeled'), "<br/>",
	"<label>&nbsp;</label>", submit(-name=>'Update', -class=>'labeled'), "<br/>",
	"</form>";
    }

    my @from = grep /$fromfilter/, @nodes;
    if (scalar @from != scalar @nodes) {
	my ($from_list, %from_binds) = &dbinlist('from', @from);
	push @where, "ns.name in ($from_list)";
	$binds{$_} = $from_binds{$_} foreach (keys %from_binds);
    }
    my @to = grep /$tofilter/, @nodes;
    if (scalar @to != scalar @nodes) {
	my ($to_list, %to_binds) = &dbinlist('to', @to);
	push @where, "nd.name in ($to_list)";
	$binds{$_} = $to_binds{$_} foreach (keys %to_binds);
    }

    foreach my $col (keys %{$error_filters}) {
	my $f = $$error_filters{$col};
	my $not = substr($f, 0, 1) eq '!' ? 'not ' : '';
	$f = substr($f, 1) if $not;
	next if !defined $f || $f eq '' || $f eq '.*';
	my $bind_label = ":${col}_rxp";
	push @where, "${not}regexp_like($col, $bind_label)";
	$binds{$bind_label} = $f;
    }

    my $where = @where ? " where ".join(' and ', @where) : '';

    # Make sure the nodes are filtered if we are filtering with regexp_like
    # TODO:  Remove these restrictions with error pre-processing
    if ($where =~ /regexp_like/ &&
	($where !~ /nd.name|ns.name/ ||
	 $where =~ /ns.name in/ && scalar @from > 5 ||
	 $where =~ /nd.name in/ && scalar @to > 5)) {
	$self->alert("You must reduce the number of links you search  if you wish to use the other ",
		     "filters.  Filter also on link <b>to</b> or <b>from</b>.");
	return;
    }

    my $sql = qq{ select ns.name from_node, nd.name to_node,
		         time_assign, time_expire, time_export, time_inxfer, time_xfer, time_done,
		         report_code, xfer_code, from_pfn, to_pfn,
		         log_xfer, log_detail, log_validate
		    from t_xfer_error xe
                    join t_adm_node nd on nd.id = xe.to_node
		    join t_adm_node ns on ns.id = xe.from_node
                  $where
		order by time_done desc
	    };

    my $max_log_length = 100_000;
    $$self{DBH}->{LongReadLen} = $max_log_length;
    $$self{DBH}->{LongTruncOk} = 1;

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%binds}, 10);
    my $n_errors = $pager->get_total_results();

    if ($fileid) {
	my $alllink = $self->myurl('fromfilter' => $fromfilter, 'tofilter' => $tofilter);
	print {$$self{CONTENT}}
	"<p><a href='$alllink'>Show all errors for this link</a></p>";
    } else {
	print {$$self{CONTENT}} 
	"<h1>$n_errors recent errors on links to ", &escapeHTML($tofilter), 
	" from ", &escapeHTML($fromfilter), "</h1>";
    }

    if ($n_errors >= 100) {
	print {$$self{CONTENT}} 
	"<p>Please note that PhEDEx only stores the last 100 link errors to the database ",
	"for a limited period of time. More errors may have occurred that are not visible here.</p>"
    }

    print {$$self{CONTENT}} $pager->pager();

    my $q = $pager->paged_result();

    my $time_labels = { TIME_ASSIGN => "Time Assigned",
			TIME_EXPORT => "Time Exported",
			TIME_INXFER => "Time Pumped",
			TIME_XFER   => "Time Transfer Start",
			TIME_DONE   => "Time Transfer Done",
			TIME_EXPIRE => "Time Transfer Expires" };

    my $log_labels = { LOG_XFER => "Transfer Log",
		       LOG_DETAIL => "Detail Log",
		       LOG_VALIDATE => "Validate Log" };

    my $now = time();
    ERROR: while (my $error = $q->fetchrow_hashref()) {
	print { $$self{CONTENT} }
	"<div class='nice errorinfo'>",
	"<h1>Error $$error{RESULT_NUMBER}</h1>";

	print { $$self{CONTENT} }
	"<label>To Node:</label><span class='labeled halfwidefield'>$$error{TO_NODE}</span>",
	"<label>From Node:</label><span class='labeled halfwidefield'>$$error{FROM_NODE}</span><br/>";

	my $time_assign = $$error{TIME_ASSIGN};
	my $tn = 0;
	foreach my $time (qw(TIME_ASSIGN TIME_XFER TIME_EXPORT TIME_DONE TIME_INXFER TIME_EXPIRE)) {
	    my $timestamp   = &formatTime($$error{$time}, 'stamp');
	    my $diff_assign = &age($$error{$time} - $time_assign, 'second');
	    my $diff_now    = &age($$error{$time} - $now, 'second');

	    print { $$self{CONTENT} }
	    "<label>$$time_labels{$time}:</label><span class='labeled halfwidefield'>", 
	    ($timestamp ? ($timestamp,
			   " <span class='diff_assigned'>($diff_assign since assigned)</span> ",
			   " <span class='diff_now'>($diff_now from now)</span>") :
	     $$error{$time} ),
	     "</span>",
	     (++$tn % 2 == 0 ? "<br/>" : '');
	}

	print { $$self{CONTENT} }
	"<hr/>",
	"<label>Report Code:</label><span class='labeled halfwidefield'>$$error{REPORT_CODE}</span>",
	"<label>Transfer Code:</label><span class='labeled halfwidefield'>$$error{XFER_CODE}</span><br/>",
	"<hr/>",
	"<label>To PFN:</label><span class='labeled'>$$error{TO_PFN}</span><br/>",
	"<label>From PFN:</label><span class='labeled'>$$error{FROM_PFN}</span><br/>",
	"<hr/>";

	foreach my $log (qw(LOG_XFER LOG_DETAIL LOG_VALIDATE)) {
	    if (! defined $$error{$log} ) { $$error{$log} = ''; }
	    my $chars = length $$error{$log};
	    my $trunc = ($chars == $max_log_length ? "<br/><span class='alarm'>Truncated</span>" : '');
	    $$error{$log} =~ s/\s*$/\n/;
	    my $lines = ($$error{$log} =~ tr/\n/\n/);
	    $lines = 0 if $chars == 0;
	   
	    print { $$self{CONTENT} }
	    "<label>$$log_labels{$log}:<br/><span class='note'>($lines lines)<br/>($chars chars)$trunc</span></label>",
	    "<div class='labeled logbox'>$$error{$log}</div><br/>";	    
 	}
	print { $$self{CONTENT} } "</div>";
    }
    print {$$self{CONTENT}} $pager->pager();
}

1;


######################################################################
package Web25::Data::ExplorePage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub init
{
    my $self = shift @_;
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];
    my %nodesel;
    if (defined param('node')) {
	%nodesel = (map { $_ => 1 } param('node'));
    } else {
	my %auth_nodes = reverse $self->fetch_nodes(web_user_auth => 'Data Manager||Site Admin', with_ids => 1);
	if (%auth_nodes && scalar keys %auth_nodes <= 5) {
	    %nodesel = (map { $_ => 1 } keys %auth_nodes);
	} else {
	    %nodesel = (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN/, @{$$self{NODE_LIST}}));
	}
    }
    $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
    $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions");

  # If we stay in the same database, keep all, otherwise strip off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit) || !defined param($option);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
	  . " value='@{[&escapeHTML(param($option))]}' />";
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;

  # "where in" lists are limited to 1000 entries
  my ($where, %binds) = ("", ());
  if (scalar @datasets < 1000) {
      my $list;
      ($list, %binds) = &dbinlist('dataset', map { $$_{ID} } @datasets);
      $where = " where ds.id in ($list) ";
  }

  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
      from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_adm_node n on n.id = br.node
      $where
     group by ds.id, n.id}, %binds);

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_adm_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my %datasets = map { $$_{DATASET}{ID} => 1 } @blocks;
  my ($list, %binds) = &dbinlist('ds', keys %datasets);
  my $q = &dbexec($$self{DBH}, 
		  qq{ select b.id block, br.node node,
                        nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
                        nvl(sum(br.dest_files),0) dest_files,
                        nvl(sum(br.dest_bytes),0) dest_bytes,
                        nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
                        nvl(sum(br.node_files),0) node_files,
                        nvl(sum(br.node_bytes),0) node_bytes
                      from t_dps_block b
                      join t_dps_block_replica br on br.block = b.id
                     where b.dataset in ($list)
                     group by b.id, br.node}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my %datasets = map { $$_{DATASET}{ID} => 1 } @blocks;
  my ($list, %binds) = &dbinlist('ds', keys %datasets);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_adm_node n on n.id = f.node
    where b.dataset in ($list)
    group by b.id, f.node, n.name}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my ($list, %binds) =  &dbinlist('block', map { $$_{ID} } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, 
           case when br.is_active = 'n' then br.node
                else xr.node
            end node
    from t_dps_block b
    join t_dps_block_replica br on br.block = b.id
    join t_dps_file f on f.inblock = b.id
    left join t_xfer_replica xr on xr.fileid = f.id
   where b.id in ($list)}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;

  my @result = ();
  my %nodes = $self->fetch_nodes(with_ids=>1);
  while (my ($name, $id) = each %nodes) {
    push(@result, { ID => $id, NAME => $name });
  }

  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
  $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 0, "Files" => 1,
                      "Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
  if (defined param('dcolumn'))
  {
    $$self{DCOLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
		    
  if (defined param('rcolumn'))
  {
    $$self{RCOLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
  $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };
  if (defined param('scolumn'))
  {
    $$self{SCOLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
		      "Destined blocks", "Destined files", "Destined bytes",
		      "Missing blocks", "Missing files", "Missing bytes",
		      "% Complete (files)", "% Complete (bytes)"
		      ];
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');
  $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Bail out if there is no filter
  my ($filter) = $self->output_filter();
  return if ! defined $filter || $filter eq '' || $filter =~ /^Enter dataset/;
  

  # Now get a sorted list of the datasets we are interested in
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}


sub dbs_form
{
    my ($self) = @_;

    my $form = "";
    $form .= "<div id='dbschoice'>\n";
    $form .= "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n";
    $form .= "    <table>\n";
    $form .= "     <thead>\n";
    $form .= "      <tr>\n";
    $form .= "       <th width='4%' align='center'>Show</th>\n";
    $form .= "       <th width='20%' align='left'>DBS</th>\n";
    $form .= "       <th width='100%' align='left'>DLS contact</th>\n";
    $form .= "       <th width='4%' align='right'>Id</th>\n";
    $form .= "      </tr>\n";
    $form .= "     </thead>\n";
    $form .= "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
	my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
	$form .= "      <tr$rowcolor>\n";
	$form .= "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'";
	$form .= ($$dbs{IS_SHOWN} ? " checked='checked'" : '') . " /></td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DBS}</td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DLS}</td>\n";
	$form .= "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n";
	$form .= "      </tr>\n";
    }
    $form .= "     </tbody>\n";
    $form .= "    </table>\n";
    $form .= "  </div>\n";
    $form .= "</div>\n";
    return $form;
}

sub node_form
{
  my ($self) = @_;

  my $form = "";

  $form .= "<div id='nodechoice'>\n";
  $form .= "<input type='button' value='Select all' onclick=\"select_all('nodechoice', 'node', '1')\"/>\n",
  $form .= "<input type='button' value='Select none' onclick=\"select_all('nodechoice', 'node', '0')\"/>\n",

  my (@all, @columns) = @{$$self{NODE_LIST}};
  my $percolumn = int(scalar(@all)/4 + 0.5);
  $percolumn = 4 if ! $percolumn;
  push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

  $form .= "  <div id='nodemenu' style='font-size:0.9em'>\n";
  $form .= "    <table style='white-space:  nowrap;'>\n";
  $form .= "     <tbody>\n";
  $form .= "      <tr>\n";

  foreach my $col (@columns)
  {
      $form .= "       <td>\n";
      $form .= join("\n", (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
				     ($$_{IS_SHOWN} ? " checked='checked'" : "") .
				     " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
			   @$col));
      $form .= "       </td>\n";
  }
  
  $form .= "     </tr>\n";
  $form .= "    </tbody>\n";
  $form .= "   </table>\n";
  $form .= " </div>\n";
  $form .= "</div>\n";
  return $form;
}


sub columns_form
{
    my ($self, @display_columns) = @_;

    my $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Display Columns</i></p>\n";
    foreach my $pair (@display_columns)
    {
	my ($dataset, $column) = @{$pair};

	$form .= "   <input type='checkbox' name='$dataset' value='$column'" .
	    ($$self{uc($dataset)}{$column} ? " checked='checked'" : "") .
	    " />&nbsp;$column<br/>\n";
    }
    
    return $form;
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  if ($filter) { $filter =~ s/^\s+//; $filter =~ s/\s+$//; }

  my $filterform = "" .
    "<form style='display:inline' method='get' action='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>($filter or "Enter dataset or regular expression"), -size=>60 ) .
    " <input type='submit' value='Filter' />" .
     &help("[?]", 'Filtering',
	   'Enter a dataset name or perl regular expression.  ',
	   'To show all datasets, enter ".*"') .
    "</form>";

  return ($filter, $filterform);
}

sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->apply_options();
  $self->init();
  $self->output_page();
  $self->output_options_form();
}

1;


######################################################################
package Web25::Data::Replicas;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  $self->fetch_data(); # puts all data into $self

  my ($filter, $filterform) = $self->output_filter();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $node_th = $$self{NVALUE};
  $node_th =~ s/Node\s+//;
  $node_th =~ s/ +/\&nbsp;/g;
  $node_th = ucfirst($node_th);

  print { $$self{CONTENT} }
    "<table>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='4%' align='center'>Blocks</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]} $node_th</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody class='nowrap'>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = (($$obj{NODE_BLOCKS} || $$obj{DEST_BLOCKS}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = ($$obj{DEST_BLOCKS} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BLOCKS} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = (($$obj{NODE_FILES} || $$obj{DEST_FILES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = ($$obj{DEST_FILES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = (($$obj{NODE_BYTES} || $$obj{DEST_BYTES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = ($$obj{DEST_BYTES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  } 
  elsif ($$self{NVALUE} eq "% Complete (files)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_FILES} || 0) / ($$obj{DEST_FILES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  } elsif ($$self{NVALUE} eq "% Complete (bytes)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_BYTES} || 0) / ($$obj{DEST_BYTES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  }


  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue, $intr) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= $intr;
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
    (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
	if ($$self{NVALUE} !~ /^%/) {
	    $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
	} else {
	    $total{$$_{ID}}{VALUE} = 0; # TODO:  Properly sum part/whole for percents
	}
	$total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue, $intr) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= $intr;
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  # Footer, sum totals
  print { $$self{CONTENT} }
  " </tbody>\n",
  " <tfoot>\n",
  "   <tr bgcolor='#f8f8f8'>\n",
  "    <th>&nbsp;</th>\n",
  ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
   ? "   <th colspan='2' align='left'>Total</th>\n"
   : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
   ? "   <th align='left'>Total</th>\n"
   : ()),
       ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>@{[&format_num($total{BLOCKS})]}</td>\n" : ()),
       ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
       ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
       ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
       (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
       "   </tr>\n",
       " </tfoot>\n",
       "</table>\n";
  
  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
      print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(dcolumn rcolumn node nvalue dbs rows));
    $optspane->add_hidden($form);

   # Columns Tab
    my @display_columns;
    push @display_columns, 
    [('rcolumn', 'DBS')], 
    [('rcolumn', 'Name')], 
    [('dcolumn', 'Blocks')],
    [('rcolumn', 'Files')], 
    [('rcolumn', 'Bytes')], 
    [('rcolumn', 'Source')], 
    [('dcolumn', 'Open')], 
    [('dcolumn', 'Transient')];

    $form = $self->columns_form(@display_columns);
    $optspane->add_tab('Columns', $form);

    # DBS Source tab
    $form = $self->dbs_form();
    $optspane->add_tab('DBS Sources', $form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);
    
    # Node Values tab
    $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Node Values</i></p>\n";
    foreach my $opt (@{$$self{NVALUES}})
    {
	$form .= "  <input type='radio' name='nvalue' value='$opt'" .
	    ($$self{NVALUE} eq $opt ? " checked='checked'" : "") .
	    " />&nbsp;$opt<br/>\n";
    }

    $form .= "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n" .
	"   <input type='radio' name='rows' value='all'" .
	($$self{ROWS} eq 'all' ? " checked='checked'" : "") .
	" />&nbsp;Show all rows<br/>\n" .
	"   <input type='radio' name='rows' value='interesting'" .
	($$self{ROWS} eq 'interesting' ? " checked='checked'" : "") .
	" />&nbsp;Show interesting rows<br/>\n";

    $optspane->add_tab('Node Values', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Data::Subscriptions;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  if (!$$self{SECMOD}->isAuthenticated() &&
      !($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	$$self{SECMOD}->hasRole('Data Manager') ||
	$$self{SECMOD}->hasRole('Site Admin') ||
	$$self{SECMOD}->hasRole('PADA Admin'))) {
      $self->auth_help_popup('suspend/unsuspend subscriptions'
		       => ['anyauth', 'Data Manager', 'Site Admin', 'PADA Admin', 'Admin'],
		       'change priorities of subscriptions'
		       => ['cert', 'Data Manager', 'Admin']);
      }

  my %admin_opts = ('suspend' => 'Suspend subscriptions',
		    'unsuspend' => 'Unsuspend subscriptions',
		    'priorityhi' => 'Make high priority',
		    'prioritymd' => 'Make normal priority',
		    'prioritylo' => 'Make low priority');
  my %admin_grps = ('suspend' => ['suspend', 'unsuspend'],
		    'priority' => ['priorityhi', 'prioritymd', 'prioritylo']);
  my @admin_auth;
  if ($$self{SECMOD}->isAuthenticated() &&
      ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager') ||
      $$self{SECMOD}->hasRole('Site Admin') ||
      $$self{SECMOD}->hasRole('PADA Admin'))) {
      push @admin_auth, 'suspend';
  }

  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
      $$self{SECMOD}->hasRole('Data Manager'))) {
      push @admin_auth, 'priority';
  }

  if (param('subsaction')) {
      $self->update_subscriptions();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->data_subscriptions();
  
  my @cols = qw(SELECT REQUEST ITEM_LEVEL ITEM_NAME NODE_NAME PRIORITY IS_CUSTODIAL USER_GROUP
		NODE_FILES NODE_BYTES PCT_FILES PCT_BYTES
		IS_MOVE TIME_SUSPEND_UNTIL ITEM_OPEN
		TIME_CREATE TIME_COMPLETE TIME_DONE TIME_CLEAR
		);
  my $th =
  { SELECT => 'Select',
    REQUEST => 'Request',
    ITEM_LEVEL => 'Data Level',
    ITEM_NAME => 'Data Item',
    NODE_NAME => 'Node',
    PRIORITY => 'Priority',
    IS_CUSTODIAL => 'Custodial',
    USER_GROUP => 'Group',
    NODE_FILES => 'Node Files',
    NODE_BYTES => 'Node Bytes',
    PCT_FILES => '% Files',
    PCT_BYTES => '% Bytes',
    IS_MOVE => 'Replica/Move',
    TIME_SUSPEND_UNTIL => 'Active/Suspended',
    ITEM_OPEN => 'Item Open',
    TIME_CREATE => 'Time Create',
    TIME_COMPLETE => 'Time Complete',
    TIME_DONE => 'Time Done',
    TIME_CLEAR => 'Time Move Auth.'
    };
  
  # Special data fromats
  my $now = time();
  my $reqpage = $self->myurl(page => "Request::View");
  my $df = 
  { 
      REQUEST => sub { return defined $_[0] ? "<a href='${reqpage}?request=$_[0]'>$_[0]</a>" : 'unknown'; },
      PRIORITY => sub { if ($_[0] == 0) { return 'High'; }
			if ($_[0] == 1) { return 'Normal'; }
			if ($_[0] == 2) { return 'Low'; } },
      IS_CUSTODIAL => \&yesno,
      IS_MOVE => sub { return $_[0] eq 'y' ? 'Move' : 'Replica'; },
      TIME_SUSPEND_UNTIL => sub { 
	  my $susp_time = $_[0];
	  if (!defined $susp_time || $susp_time <= $now) { return 'Active'; }
	  elsif ($susp_time == 9_999_999_999)            { return 'Suspended Forever'; }
	  else { return 'Suspended Until  '.&formatTime($susp_time, 'stamp') }
      },
      ITEM_OPEN => \&yesno,
      TIME_CREATE =>   sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      TIME_COMPLETE => sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      TIME_DONE =>     sub { &formatTime($_[0], 'stamp') || '&#8211;' },
      TIME_CLEAR => sub { 
	  my $clear_time = $_[0];
	  if (!defined $clear_time) { return '-'; }
	  elsif ($clear_time == 9_999_999_999)            { return 'Pending approval'; }
	  else { return &formatTime($clear_time, 'stamp') }
      },
      NODE_FILES => \&format_num,
      NODE_BYTES => sub { &format_size($_[0]) },
      PCT_FILES => \&format_percent,
      PCT_BYTES => \&format_percent
  };

  # Special cell formats
  my $cf = 
  { 
      TIME_SUSPEND_UNTIL => sub { return defined $_[0] && $_[0] >= $now ? 'alarm' : ''; },
      PCT_FILES => sub { return defined $_[0] && $_[0] == 1 ? '' : 'bad' },
      PCT_BYTES => sub { return defined $_[0] && $_[0] == 1 ? '' : 'bad' }
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='s_id' value='$_[1]->{ITEM_LEVEL}:$_[1]->{ITEM_ID}:$_[1]->{NODE_ID}'/>" },
       'PCT_FILES' => sub { ($_[1]->{NODE_FILES} || 0) / ($_[1]->{DEST_FILES} || -1); },
       'PCT_BYTES' => sub { ($_[1]->{NODE_BYTES} || 0) / ($_[1]->{DEST_BYTES} || -1); }
       );
  
  # Filters
  my @reqfilter   = grep(/^\d+$/, split(/\s*,*\s+/, param('reqfilter') || ''));
  my $itemfilter  = param('filter') || '.*';
  my $priofilter  = param('priority') || 'any';
  my $suspfilter  = param('suspended') || 'any';
  my $custfilter  = param('custodial') || 'any';
  my $groupfilter = param('group') || 'any';

  my @groups = ('any', 'undefined', sort $self->fetch_groups());

  my $filterform = join('', "<p><i>Subscription data filters</i></p>",
			"<div class='nice'>",
			"<label>Requests: </label>",
			textfield(-name=>'reqfilter', -default=>'', -size=>30, -class=>'labeled'), "<br>",
			"<label>Data items: </label>",
			textfield(-name=>'filter', -default=>$itemfilter, -size=>30, -class=>'labeled'), "<br>",
			"<label>Priority: </label>",
			popup_menu(-name=>'priority', -values=>['any', 'high', 'normal', 'low'],
				   -default=>$priofilter, -class=>'labeled'), "<br/>",
			"<label>Active/Suspended: </label>",
			popup_menu(-name=>'suspended', -values=>['any', 'active', 'suspended'],
				   -default=>$suspfilter, -class=>'labeled'), "<br/>",
			"<label>Custodial: </label>",
			popup_menu(-name=>'custodial', 
				   -values=>['any', 'y', 'n'],
				   -labels=>{ 'any' => 'any',
					      'y' => 'custodial',
					      'n' => 'non-custodial' },
				   -default=>$custfilter, -class=>'labeled'), "<br/>",
			"<label>Group: </label>",
			popup_menu(-name=>'group', -values=>\@groups,
				   -default=>$groupfilter, -class=>'labeled'), "<br/>",

			"</div>"
			);


  my $filter = 
  { 
      REQUEST => sub { return 1 if !@reqfilter;
		       return 0 if @reqfilter && !defined $_[0];
		       return 1 if grep $_[0] == $_, @reqfilter; },
      ITEM_NAME => sub { $_[0] =~ /$itemfilter/ ? 1 : 0 },
      PRIORITY => sub { ( $priofilter eq 'any'
			  || ($priofilter eq 'high'   && $_[0] == 0)
			  || ($priofilter eq 'normal' && $_[0] == 1)
			  || ($priofilter eq 'low'    && $_[0] >= 2)) ? 1 : 0 },
      TIME_SUSPEND_UNTIL => sub { return 1 if $suspfilter eq 'any';
				  return 1 if $suspfilter eq 'active' && !defined $_[0];
				  return 1 if $suspfilter eq 'suspended' && defined $_[0];
				  return 0;
			      },
      IS_CUSTODIAL => sub { return 1 if $custfilter eq 'any';
			    return 1 if $custfilter eq $_[0];
			    return 0;
			},
      USER_GROUP => sub { return 1 if $groupfilter eq 'any';
			  return 1 if defined $_[0] && $groupfilter eq $_[0];
			  return 1 if !defined $_[0] && $groupfilter eq 'undefined';
			  return 0;
		      }
  };

  if (!@admin_auth) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->set_filters($filter);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);

  my @querycols;
  foreach (@cols) {
      my $default = $_ =~ /PCT_FILES|ITEM_OPEN|TIME_COMPLETE|TIME_DONE/ ? 0 : 1;
      push @querycols, [ ($$th{$_}, 'col', $_,  $default) ];
  }
  $dbtable->set_querycols( @querycols );


  if (@admin_auth) {
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='button' value='Select all' onclick=\"select_all('subsform', 's_id', '1')\"/>\n",
      "<input type='button' value='Select none' onclick=\"select_all('subsform', 's_id', '0')\"/>\n",
      "</p>\n";

      my $target = $self->myurl();
      print { $$self{CONTENT} }
      "<form id='subsform' method='post' action='$target'>",
      # Save view parameters
      $self->saveform(),
      "<input type='hidden' name='priority' value='$priofilter'/>",
      "<input type='hidden' name='suspended' value='$suspfilter'/>",
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='subsaction'>\n";
      foreach my $auth (@admin_auth) {
	  foreach my $opt (@{$admin_grps{$auth}}) {
	      print { $$self{CONTENT} } 
	      "<option value='$opt'>$admin_opts{$opt}</option>\n";
	  }
      }
      print { $$self{CONTENT} }
      "</select>\n",
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if (@admin_auth) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }

  my $optspane = new Web25::OptsPane;
  
  my $target = $self->myurl();
  $optspane->set_form_target($target);

  my $form = "";

  # Save everything except what this form controls
  $form = $self->saveform(qw(node filter));
  $optspane->add_hidden($form);

  $form = $dbtable->columns_form();
  $optspane->add_tab('Columns', $form);

  # Node Selection tab
  $form = $self->node_form();
  $optspane->add_tab('Nodes Shown', $form);

  # Data filters tab
  $optspane->add_tab('Filters', $filterform);

  print { $$self{OPTIONS} } $optspane->output();

}

sub output_options_form { }

sub update_subscriptions
{
    my ($self) = @_;

    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager||Site Admin||PADA Admin', with_ids => 1);
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $upd_suspend = qq[ update t_dps_subscription set time_suspend_until = :val
			  where _ITEM_ = :id and destination = :dest ];
    my $upd_priority = qq[ update t_dps_subscription set priority = :val
			   where _ITEM_ = :id and destination = :dest];

    my $action_list = 
    {
	suspend => { desc => ' suspended',
		     sql  => $upd_suspend,
		     val  => 9_999_999_999 },
    	unsuspend => { desc => ' unsuspended',
		       sql  => $upd_suspend,
		       val  => undef },
	priorityhi => { desc => ' set to high priority',
			sql => $upd_priority,
			val => 0 },
	prioritymd => { desc => ' set to medium priority',
			sql => $upd_priority,
			val => 1 },
	prioritylo => { desc => ' set to low priority',
			sql => $upd_priority,
			val => 2 }
    };

    # Execute the update
    my $action = $action_list->{param('subsaction')};

    my $n_changed = 0;
    my %warn_hash;  # to keep unique warnings

    foreach (param('s_id')) {
	my ($level, $id, $destination) = split /:/;
	if (grep $destination == $_, values %auth_nodes) { # Check permission
	    my $sql = $$action{sql};
	    $sql =~ s/_ITEM_/$level/;

	    my @rv = &dbexec($$self{DBH}, $sql, 
			     ':val' => $$action{val},
			     ':id'  => $id,
			     ':dest' => $destination);
	    $n_changed += $rv[1];
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$destination} subscriptions!</p>";
	    $warn_hash{$warn} = 1;
	}
    }

    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$n_changed data items $action->{desc}!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

sub data_subscriptions
{
  my ($self) = @_;
  $self->fetch_nodes();
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($node_list, %node_binds) = &dbinlist('node', @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
       select s.request,
              NVL2(s.block, 'BLOCK', 'DATASET') item_level,
	      NVL2(s.block, s.block, s.dataset) item_id,
	      NVL2(s.block, b.name, ds.name) item_name,
	      NVL2(s.block, b.is_open, ds.is_open) item_open,
	      ds.id dataset_id, ds.name dataset_name,
	      n.id node_id, n.name node_name,
	      s.destination subs_destination, s.dataset subs_dataset, s.block subs_block,
	      s.priority, s.is_move, s.is_transient,
              s.is_custodial, g.name user_group,
	      s.time_suspend_until, s.time_create,
	      s.time_clear, s.time_complete, s.time_done,
	      reps.exist_files, reps.node_files, reps.dest_files,
	      reps.exist_bytes, reps.node_bytes, reps.dest_bytes
	    from t_dps_subscription s
	    join t_adm_node n on n.id = s.destination
	    left join t_dps_block b on b.id = s.block
	    left join t_dps_dataset ds on ds.id = s.dataset or ds.id = b.dataset
	    left join t_adm_group g on g.id = s.user_group
	    join
	    (select s2.destination, s2.dataset, s2.block,
		    sum(b2.files) exist_files, sum(b2.bytes) exist_bytes,
		    sum(br.node_files) node_files, sum(br.dest_files) dest_files,
		    sum(br.node_bytes) node_bytes, sum(br.dest_bytes) dest_bytes
	       from t_dps_subscription s2
	       left join t_dps_block b2 on b2.dataset = s2.dataset or b2.id = s2.block
	       left join t_dps_block_replica br on br.node = s2.destination and br.block = b2.id
	       group by s2.destination, s2.dataset, s2.block
	    ) reps
	    on reps.destination = s.destination
	   and (reps.dataset = s.dataset or reps.block = s.block)
     where n.id in ($node_list)
     order by s.time_create desc, s.dataset desc, s.block desc, n.name
  }, %node_binds);

  return $q;
}


1;



######################################################################
package Web25::Data::LoadTestInject;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "LoadTest Injections",
	       LINK_TITLE => "Manage/View LoadTest Injections" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  if (!$$self{SECMOD}->isAuthenticated() &&
      !($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	$$self{SECMOD}->hasRole('Data Manager') ||
	$$self{SECMOD}->hasRole('Site Admin') ||
	$$self{SECMOD}->hasRole('PADA Admin'))) {
      $self->auth_help_popup('manage LoadTest injections'
			     => ['cert', 'Data Manager', 'Site Admin', 'PADA Admin', 'Admin']);
  }
  
  my %admin_opts = ('rate'       => 'set rate (MB/s)',
		    'inject_now' => 'one-time injection (files)',
		    'start'      => 'start injections',
		    'stop'       => 'stop injections',
		    'remove'     => 'remove injection');
  my @opts_order = qw(rate inject_now start stop remove);
	    
  my $admin_ok = 0;
  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
       $$self{SECMOD}->hasRole('Data Manager') ||
       $$self{SECMOD}->hasRole('Site Admin') ||
       $$self{SECMOD}->hasRole('PADA Admin'))) {
      $admin_ok = 1;
  }

  if (param('action')) {
      $self->update_injections();
  }

  if (param('create_source') && param('create_source') != -1 
      && param ('create_dest') && param('create_dest') != -1) {
      $self->create_injection();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->get_injections();
  
  my @cols = qw(SELECT DEST_NODE_NAME THROTTLE_NODE_NAME SRC_DATASET_NAME DEST_DATASET_NAME
		IS_ACTIVE RATE INJECT_NOW TIME_INJECT);
  my $th =
  { SELECT => 'Select',
    DEST_NODE_NAME => 'Injection Node',
    SRC_DATASET_NAME => 'Source Dataset',
    DEST_DATASET_NAME => 'Injection Dataset',
    THROTTLE_NODE_NAME => 'Destination Node',
    IS_ACTIVE => 'Status',
    RATE => 'Rate',
    INJECT_NOW => 'Inject Now',
    TIME_INJECT => 'Last Injection'
    };
  
  # Special data fromats
  my $now = time();
  my $df = 
  { 
      IS_ACTIVE   => sub { return $_[0] eq 'y' ? 'Active' : 'Stopped'; },
      RATE => sub { return &format_size($_[0], 1) . "/s"; },
      TIME_INJECT => sub { &formatTime($_[0], 'stamp') || '&#8211;' }
  };

  # Special cell formats
  my $cf = 
  { 
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='lp_id' value='$_[1]->{SRC_DATASET}:$_[1]->{DEST_DATASET}:$_[1]->{DEST_NODE}'/>" }
       );
  
  if (!$admin_ok) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);
  my @querycols;
  foreach (@cols) {
      my $default = 1;
      push @querycols, [ ($$th{$_}, 'col', $_,  $default) ];
  }
  $dbtable->set_querycols( @querycols );
  $dbtable->set_statcols({RATE => 'SUM', INJECT_NOW => 'SUM'});

  if ($admin_ok) {
      my $target = $self->myurl();
  
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='button' value='Select all' onclick=\"select_all('subsform', 'lp_id', '1')\"/>\n",
      "<input type='button' value='Select none' onclick=\"select_all('subsform', 'lp_id', '0')\"/>\n",
      "</p>\n";

      print { $$self{CONTENT} }
      "<form id='subsform' method='post' action='$target'>",
      $self->saveform(),
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='action'>\n";
      foreach my $opt (@opts_order) {
	  print { $$self{CONTENT} } 
	  "<option value='$opt'>$admin_opts{$opt}</option>\n";
      }
      
      print { $$self{CONTENT} }
      "</select>\n",
      " = ",
      textfield(-name=>'actionvalue', -class=>'labeled', -size=>'5'),
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if ($admin_ok) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }

  my $optspane = new Web25::OptsPane;
  
  my $target = $self->myurl();
  $optspane->set_form_target($target);

  my $form = "";

  # Save everything except what this form controls
  $form = $self->saveform(qw(node));
  $optspane->add_hidden($form);

  $form = $dbtable->columns_form();
  $optspane->add_tab('Columns', $form);

  # Node Selection tab
  $form = $self->node_form();
  $optspane->add_tab('Nodes Shown', $form);

  my $sources = $self->get_sources();

  my $create_source_form;
  if (values %$sources) {
      # Create new Injections widget
      # List of all nodes, except MSS nodes
      my %all_nodes = $self->fetch_nodes(with_ids => 1);
      foreach (keys %all_nodes) {
	  delete $all_nodes{$_} if /_MSS$/;
      }
      my $sort_all_nodes = [ map { $all_nodes{$_} } sort keys %all_nodes ];
      unshift @$sort_all_nodes, -1;
      $all_nodes{'Select a Node'} = -1;

      my $sort_sources = [ map { $$_{SRC_DATASET} } 
			    sort {$$a{SRC_NODE_NAME} cmp $$b{SRC_NODE_NAME}}
			   values %$sources ];
      unshift @$sort_sources, -1;
      $$sources{-1} = { SRC_DATASET => -1, SRC_NODE_NAME => 'Select a Node' };

      $create_source_form = join "",
      "Create LoadTest Stream<br/>",
      "from ",
      popup_menu(-name=>'create_source',
		 -values=>$sort_sources,
		 -labels=>{ map { $$_{SRC_DATASET} => $$_{SRC_NODE_NAME} }
			    values %$sources }),
      " to ",
      popup_menu(-name=>'create_dest',
		 -values=>[ map { $all_nodes{$_} } sort keys %all_nodes ],
		 -labels=>{ reverse %all_nodes }), 
      " at ",
      textfield(-name=>'rate',
		-value=>5,
		-size=>5),
      " MB/s";
  } else {
      $create_source_form = join "",
      "<p>You don't have permission to create new LoadTest streams.  ",
      "Check that you have a LoadTestSource injected for your authorized nodes.</p>";
  }

  $optspane->add_tab('Create Injection', $create_source_form);

  print { $$self{OPTIONS} } $optspane->output();

}

sub output_options_form { }

sub update_injections
{
    my ($self) = @_;

    my $now = time();
    my %warn_hash;  # to keep unique warnings
    my $action = param('action');
    my $bad = 0;
    unless (grep $action, qw(rate inject_now start stop remove)) {
	$warn_hash{"Unknown action"} = 1;
	$bad = 1;
    }

    my $actionvalue = param('actionvalue');
    if (($action eq 'rate' || $action eq 'inject_now')
	&& (!defined $actionvalue || ! (sprintf("%.4f", $actionvalue) >= 0) )) {
	my $desc;
	if    ($action eq 'rate')       { $desc = 'change the rate'; }
	elsif ($action eq 'inject_now') { $desc = 'do an immediate injection'; }
	$warn_hash{"You must provide a value in order to $desc"} = 1;
	$bad = 1;
    }

    if ($action eq 'rate' && $actionvalue > 10_000) {
	$warn_hash{"Rate is too high.  Limit is 10 GB/s."} = 1;
	$bad = 1;
    }
	
    if ($action eq 'inject_now' && $actionvalue > 10_000) {
	$warn_hash{"Injection size is too high.  Limit is 10000 files."} = 1;
	$bad = 1;
    }

    if ($bad) {
	print { $$self{CONTENT} } "<p class='alarm'>$_</p>" for keys %warn_hash;
	return;
    }

    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'PADA Admin||Data Manager||Site Admin', with_ids => 1);
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $u_rate = &dbprep($$self{DBH}, qq{ update t_loadtest_param set rate = :rate * power(1024, 2), time_update = :now
					   where src_dataset = :src_dataset
                                             and dest_dataset = :dest_dataset
					     and dest_node = :dest_node });

    my $u_inject = &dbprep($$self{DBH}, qq{ update t_loadtest_param set inject_now = :inject_now, time_update = :now
					     where src_dataset = :src_dataset
                                               and dest_dataset = :dest_dataset
					       and dest_node = :dest_node });

    my $u_active = &dbprep($$self{DBH}, qq{ update t_loadtest_param set is_active = :is_active, time_update = :now
					     where src_dataset = :src_dataset
                                               and dest_dataset = :dest_dataset
					       and dest_node = :dest_node });
    
    my $del = &dbprep($$self{DBH}, qq{ delete from t_loadtest_param
 				        where src_dataset = :src_dataset
                                          and dest_dataset = :dest_dataset
					  and dest_node = :dest_node });

    my $action_list = 
    {
	rate => { desc => 'rate changed',
		  dml => $u_rate,
		  values => { ':rate' => $actionvalue, ':now' => $now }
	      },
	inject_now => { desc => 'immediate injection set',
			dml => $u_inject,
			values => { ':inject_now' => $actionvalue, ':now' => $now }
		    },
	stop => { desc => 'injections stopped',
		  dml => $u_active,
		  values => { ':is_active' => 'n', ':now' => $now }
	      },
	start => { desc => 'injections started',
		   dml => $u_active,
		   values => { ':is_active' => 'y', ':now' => $now }
	       },
	remove => { desc => 'injections deleted',
		    dml => $del,
		    values => {}
		}
    };

    # Execute the update
    $action = $action_list->{$action};

    my $n_changed = 0;

    foreach (param('lp_id')) {
	my ($src_dataset, $dest_dataset, $dest_node) = split /:/;
	if (grep $dest_node == $_, values %auth_nodes) { # Check permission
	    my $dml = $$action{dml};
	    
	    my $rv = &dbbindexec($dml, 
				 ':src_dataset' => $src_dataset,
				 ':dest_dataset' => $dest_dataset,
				 ':dest_node' => $dest_node,
				 %{$$action{values}});
	    $n_changed += $rv;
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$dest_node} injections!</p>";
	    $warn_hash{$warn} = 1;
	}
    }
    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$action->{desc} for $n_changed injections!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

sub get_injections
{
  my ($self) = @_;
  $self->fetch_nodes();
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($node_list, %node_binds) = &dbinlist('node', @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
        select
        lp.dest_node, dn.name dest_node_name,
	lp.src_dataset, ds.name src_dataset_name,
        lp.dest_dataset, dd.name dest_dataset_name,
        lp.is_active, lp.dataset_size, lp.dataset_close,
        lp.block_size, lp.block_close,
        lp.rate, lp.inject_now,
        lp.throttle_node, tn.name throttle_node_name,
        lp.time_inject
            from t_loadtest_param lp
            join t_dps_dataset ds on ds.id = lp.src_dataset
            join t_dps_dataset dd on dd.id = lp.dest_dataset
            join t_adm_node dn on dn.id = lp.dest_node
            left join t_adm_node tn on tn.id = lp.throttle_node
	    where lp.dest_node in ($node_list)
	    order by dn.name, ds.name, dd.name
        }, %node_binds);                    

  return $q;
}

sub create_injection
{
    my ($self) = @_;

    my $src_dataset = param('create_source');
    my $to_node = param('create_dest');
    my $rate = param('rate');
    my $now = time();

    if (!$src_dataset || !$to_node || !$rate || ! (sprintf("%.4f", $rate) > 0)) {
	print {$$self{CONTENT}} "<p class='alarm'>Missing parameters for injection creation</p>";
	return;
    }

    if ($rate > 10_000) {
        print {$$self{CONTENT}} "<p class='alarm'>Rate too high.  Injection rate is limited to 10 GB/s</p>";
        return;
    }
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids=>1);
    my $sources = $self->get_sources(); # gets only authorized sources
    my $source = $$sources{$src_dataset};

    my $from = $$source{SRC_NODE_NAME};
    my $to = $all_nodes{$to_node};

    if ($from eq $to) {
	print {$$self{CONTENT}} "<p class='alarm'>You can't create a stream from $from to $to</p>";
	return;
    }

    foreach (\$from, \$to) {
	$$_ =~ s/^T._//;  $$_ =~ s/_(Buffer|Disk|MSS)$//;
    }
    my $dest_ds_name = "/PhEDEx_Debug/LoadTest07_$from/$to";
    my $dest_ds;
    my @rv;

    ($dest_ds) = &dbexec($$self{DBH}, qq{
	select ds.id from t_dps_dataset ds where ds.name = :name
	}, ':name' => $dest_ds_name)->fetchrow();

    @rv = &dbexec($$self{DBH}, qq{
	insert into t_dps_dataset
	    (id, dbs, name, is_open, is_transient, time_create)
	    values
	    (seq_dps_dataset.nextval, 1, :name, 'y', 'y', :now)
	    returning id into :dest_ds
	},  ':name' => $dest_ds_name,
		  ':now' => $now,
		  ':dest_ds' => \$dest_ds) unless $dest_ds;
    
    my ($lt_exists) = &dbexec($$self{DBH}, qq{
	select 1 from t_loadtest_param
         where src_dataset = :src_ds
           and dest_dataset = :dest_ds
           and dest_node = :dest_node 
       }, ':src_ds' => $$source{SRC_DATASET},
			      ':dest_ds' => $dest_ds,
			      ':dest_node' => $$source{SRC_NODE})->fetchrow();
    
    if ($lt_exists) {
	print {$$self{CONTENT}} "<p class='alarm'>Injection from $from to $to already exists!</p>";
    } else {
	@rv = &dbexec($$self{DBH}, qq{
	    insert into t_loadtest_param
	    (src_dataset, dest_dataset, dest_node, is_active,
	     dataset_size, dataset_close, block_size, block_close,
	     rate, inject_now, throttle_node,
	     time_create, time_update)
	    values
	    (:src_ds, :dest_ds, :dest_node, 'y',
	     NULL, 'n', 100, 'y',
	     :rate * power(1024,2), 0, :throttle_node,
	     :time_create, :time_update)
	}, ':src_ds' => $$source{SRC_DATASET},
		      ':dest_ds' => $dest_ds,
		      ':dest_node' => $$source{SRC_NODE},
		      ':rate' => $rate, ':throttle_node' => $to_node,
		      ':time_create' => $now, ':time_update' => $now);
    }

    if ($rv[1] > 0) {
	$$self{DBH}->commit();
	print {$$self{CONTENT}} "<p class='note'>Created LoadTest stream from $from to $to</p>";
    }


}

sub get_sources
{
    my ($self) = @_;
    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'PADA Admin||Data Manager||Site Admin', with_ids => 1);
    return {} unless %auth_nodes;
    my ($node_list, %node_binds) = &dbinlist('node', values %auth_nodes );

    # This query looks funny, but it works faster then the obvious thing
    # The key is to not process all the rows of t_dps_file
    my $q = &dbexec($$self{DBH}, qq{
	select ds.id src_dataset, ds.name src_dataset_name,
               n.id src_node, n.name src_node_name
	  from t_dps_dataset ds
          cross join t_adm_node n
         where ds.name like '%LoadTest07Source%'
           and n.id =
           (select f.node from t_dps_file f
              join t_dps_block b on b.id = f.inblock
             where rownum = 1
               and b.dataset = ds.id
               and f.node in ($node_list))
     }, %node_binds);

    return $q->fetchall_hashref('SRC_DATASET');
}


1;


######################################################################
package Web25::Data::Verify;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Verification",
	       LINK_TITLE => "Block Verification Test Results" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(node block test status);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Data::Verify"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
  my ($self) = @_;

  my $nodefilter = param('node') || '.*';
  my $blockfilter = param('block') || '.*';
  my $testchoice = param('test') || 'Any';
  my $statuschoice = param('status') || 'Any';


  my $q_tests = &dbexec($$self{DBH}, qq{ select name from t_dvs_test order by name });
  my @tests;  
  while (my $row = $q_tests->fetchrow()) {
      push @tests, $row; 
  }
  unshift @tests, 'Any';
  
  my $q_status = &dbexec($$self{DBH}, qq{ select name from t_dvs_status order by name });
  my @status;  
  while (my $row = $q_status->fetchrow()) {
      push @status, $row; 
  }
  unshift @status, 'Any';
  

  print {$$self{CONTENT}}
  "<form method='get' action='#' class='nice'/>",
  "<label class='inline'>Show</label>",
  popup_menu(-name=>'test', values=>\@tests, -class=>'labeled'),
  "<label class='inline'>tests on nodes </label>",
  textfield(-name=>'node', -value=>$nodefilter, -size=>10, -class=>'labeled'),
  "<label class='inline'>for block</label>",
  textfield(-name=>'block', -value=>$blockfilter, -size=>20, -class=>'labeled'),
  "<label class='inline'>with</label",
  popup_menu(-name=>'status', values=>\@status, -class=>'labeled'),
  "<label class='inline'>status</label",
  submit(-name=>'Update', -class=>'labeled'), "<br/>",
  "</form>";

  my @where;
  my %binds;
  my %all_nodes = $self->fetch_nodes(with_ids=>1);
  my @select_nodes = grep /$nodefilter/, keys %all_nodes;
  if (scalar @select_nodes < scalar keys %all_nodes) {
      my $list;
      ($list, %binds) = &dbinlist('node', map { $all_nodes{$_} } @select_nodes);
      push @where,"n.id in ($list)";
  }

  if ($testchoice ne 'Any') {
      push @where, 't.name = :test';
      $binds{':test'} = $testchoice;
  }

  if ($statuschoice ne 'Any') {
      push @where, 's.name = :status';
      $binds{':status'} = $statuschoice;
  }

  my $where = @where ?  "where ".join(' and ', @where) : '';

  my $sql = qq{ select v.id, b.name block, block blockid, n_files, n_tested, n_ok,
             s.name status, t.name test, time_reported, n.name node
             from t_status_block_verify v join t_dvs_status s on v.status = s.id
             left join t_dps_block b on v.block = b.id
             join t_dvs_test t on v.test = t.id
	     join t_adm_node n on n.id = v.node
	     $where
             order by time_reported desc };

  my $pager = new Web25::QueryPager;
  $pager->init($self, $sql, {%binds}, 1000, undef, {BLOCK => $blockfilter});
  my $n_rows = $pager->get_total_results();
  
  if (! $n_rows) {
      print { $$self{CONTENT} } "<p>No results to show.</p>";
      return;
  }

  print {$$self{CONTENT}} $pager->pager();
  my $q = $pager->paged_result();

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols([qw(TIME_REPORTED NODE BLOCK TEST STATUS N_FILES N_TESTED N_OK)]);
  $dbtable->set_tablehead({ TIME_REPORTED => 'Time Reported',
			    NODE => 'Node',
			    BLOCK => 'Block',
			    TEST => 'Test',
			    STATUS => 'Status',
			    N_FILES => '# Files',
			    N_TESTED => '# Tested',
			    N_OK => '# OK' });
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats({ TIME_REPORTED => sub { &formatTime($_[0], 'stamp') } });
  $dbtable->set_rowformats({ STATUS => sub { return $_[0] eq 'Fail' ? 'alarm' : '' } });
#  $dbtable->set_formats($cf);
  $dbtable->output($q);
  print {$$self{CONTENT}} $pager->pager();
  
}



######################################################################
package Web25::Reports::DailyReports;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web25::Reports::DailyReport;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/\"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web25::Reports::Size;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_status_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_status_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web25::Reports::SiteData;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Site Data",
	       LINK_TITLE => "Site storage allocation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

# WORKHERE
sub output
{
    my ($self) = @_;
    

    my %nodes = $self->fetch_nodes(with_ids => 1);
    my $node = param('node') || 'T0_CH_CERN_MSS';
    my $viewurl = '#';

    print { $$self{CONTENT} }
    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View node: </label>",
    popup_menu(-name=>'node',
	       -values=>[sort keys %nodes], -default=>$node,
	       -class=>'labeled'),
    submit(-value=>'Submit', -class=>'labeled'), "</form><br clear='all'/>";

    my $node_id = $nodes{$node};

    my %data;

    print { $$self{CONTENT} }
    "<h2>$node Site Data</h2>",
    "<table>",
    "<tr><th>Quantity</th><th>Subscribed</th><th>Resident</th><th>Missing</th></tr>",
    "<tr><td>Custodial Data</td><td>",&format_size(100),"</td></tr>",
    "<tr><td>Non-Custodial Data</td><td>",&format_size(100),"</td></tr>",
    "<tr><td>GroupA</td><td>",&format_size(100),"</td></tr>",
    "<tr><td>GroupB</td><td>",&format_size(100),"</td></tr>",
    "<tr><td>Total</td><td>",&format_size(100),"</td></tr>",
    "</table>";

}

1;

######################################################################
package Web25::Test::Test;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use CGI::Session;

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Test Functions",
	       SESSION => 1,
	       LINK_TITLE => "Testing Page" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

   &dump_var($$self{CONTENT}, 'TESTING', $TESTING);
   return if (!$TESTING);  # For security
   &dump_var($$self{CONTENT}, '$PERL_VERSION', sprintf("v%vd", $^V));
   &dump_var($$self{CONTENT}, 'CGI::VERSION', $CGI::VERSION);
   &dump_var($$self{CONTENT}, 'CGI::Session::VERSION', $CGI::Session::VERSION);
   &dump_var($$self{CONTENT}, 'DBI::VERSION', $DBI::VERSION);
   &dump_var($$self{CONTENT}, 'DBD::Oracle::VERSION', $DBD::Oracle::VERSION);
#   &dump_var($$self{CONTENT}, '@INC', [@INC]);
#   &dump_var($$self{CONTENT}, 'TESTING_MAIL', $TESTING_MAIL);
  &dump_var($$self{CONTENT}, 'SESSION', $$self{SESSION} ? 'Session OK' : 'NO SESSION');
  &dump_var($$self{CONTENT}, 'SESSIONID', $$self{SESSIONID});
  print { $$self{CONTENT} } "<pre>", $$self{SESSION}->dump(), "</pre>";

  if ($$self{SESSION} && param('data')) {
      $$self{SESSION}->param('data', param('data'));
      print {$$self{CONTENT}} "<p>Saved data</p>";
  } else {
      print {$$self{CONTENT}} "<form action='#' method='post'>",
      textfield(-name=>'data'),
      submit(),
      "</form>";
  }
  
  my $data = $$self{SESSION}->param('data');
  if ($data) {
      print {$$self{CONTENT}} "<p>Your saved data is $data</p>";
  } else {
      print {$$self{CONTENT}} "<p>No session data.</p>";
  }

  #&dump_var($$self{CONTENT}, 'Config', $$self{CONFIG});
#  &dump_var($$self{CONTENT}, 'Env', {%ENV});

#   &dump_var($$self{CONTENT}, 'ENV{ORACLE_HOME}', $ENV{ORACLE_HOME});
#   &dump_var($$self{CONTENT}, 'ENV{TNS_ADMIN}', $ENV{TNS_ADMIN});

  my $cgi = new CGI;
  print {$$self{CONTENT}} 
  "<p>absolute URL current  ",     $self->myurl('fullurl'=>1),"</p>",
  "<p>absolute URL security on  ", $self->myurl('fullurl'=>1, 'secure'=>1),"</p>",
  "<p>absolute URL security off  ",$self->myurl('fullurl'=>1, 'secure'=>0),"</p>",
  "<p>relative URL current ", $self->myurl(),"</p>",
  "<p>relative URL security on  ", $self->myurl('secure'=>1),"</p>",
  "<p>relative URL security off ", $self->myurl('secure'=>0),"</p>",
  "<p>CGI absolute URL current ",  $cgi->url(-full=>1), "</p>",
  "<p>CGI relative URL current ",  $cgi->url(-relative=>1, -path=>1), "</p>",
  "<p>CGI Normal URL security on ",  $cgi->url(-relative=>1, -secure=>1, -path=>1), "</p>",
  "<p>CGI Normal URL security off ",  $cgi->url(-relative=>1, -secure=>0, -path=>1), "</p>",
  "<p>CGI -rewrite ", $cgi->url(-rewrite=>1), "</p>"
  ;
  
  
#   &dump_var($$self{CONTENT}, 'ENV{HTTPS}', $ENV{HTTPS});
#   &dump_var($$self{CONTENT}, 'ENV{HTTP_HTTPS}', $ENV{HTTP_HTTPS});
#   my $replicas = &fetch_replicas($$self{DBH}, 1212);
#   &dump_var($$self{CONTENT}, 'replicas', $replicas);

#   my ($resolved, $userdupes, $dbsdupes) = &resolve_data($$self{DBH}, 'test', '/Simon/Simon/*-1');

#   &dump_var($$self{CONTENT}, 'resolved', $resolved);

#   &dump_var($$self{CONTENT}, 'SecMod CertAuth', $$self{SECMOD}->isCertAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod PassAuth', $$self{SECMOD}->isPasswdAuthenticated());
#   &dump_var($$self{CONTENT}, 'SecMod Forename', $$self{SECMOD}->getForename());
#   &dump_var($$self{CONTENT}, 'SecMod Surname', $$self{SECMOD}->getSurname());
#   &dump_var($$self{CONTENT}, 'SecMod Username', $$self{SECMOD}->getUsername());
#   &dump_var($$self{CONTENT}, 'SecMod DN', $$self{SECMOD}->getDN());
#   &dump_var($$self{CONTENT}, 'SecMod CERT', $$self{SECMOD}->getCert());

#   &dump_var($$self{CONTENT}, 'SecMod Roles', $$self{SECMOD}->getRoles());

#   &dump_var($$self{CONTENT}, 'authorized nodes', [ $self->fetch_nodes(web_user_auth=>'Site Admin||Data Manager') ]);

#   &dump_var($$self{CONTENT}, 'SecMod Node Map', {$$self{SECMOD}->getPhedexNodeToSiteMap()});
  
#   &dump_var($$self{CONTENT}, 'SecMod CERN Site Admins', [$$self{SECMOD}->getUsersWithRoleForSite('Site Admin', 'CERN')]);

#   &dump_var($$self{CONTENT}, 'SecMod Admins', [$$self{SECMOD}->getUsersWithRoleForGroup('Admin', 'phedex')]);


}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration
  my $config = &read_config();
  #eval "use CGI::Carp qw(fatalsToBrowser)";

  # Set debug mode
  $TESTING = $$config{TESTING_MODE} ? 1 : 0;
  $TESTING_MAIL = $$config{TESTING_MAIL} || undef;
  
  # Set DBSLookup path
  $DBS_LOOKUP = $$config{DBS_LOOKUP} || undef;

  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Grab the database name from the path info
  $db = "prod" if ! $db || ! exists $$config{INSTANCES}{$db};
  
  # Get the scope object for the page.
  no strict "refs";
  my $type = "Web25::Info::Main";
  $type = "Web25::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web25::$cgipage\::"}{INDEX}
	&& exists ${"Web25::$cgipage\::"}{new});

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type);
  $type =~ s!^Web25::!!;
  param('page', $type);
  
  # Initialize the SecurityModule
  unless ($cgipage =~ /^XML/) {
      my %args;
      if ($$config{SECMOD_CONFIG}) {
	  # If a config file is given, we use that
	  $args{CONFIG} = $$config{SECMOD_CONFIG};
      } else {
	  # Otherwise we check for a "SecurityModule" section in DBParam, and use the defaults
	  my $dbparam;
	  eval {
	      $dbparam = &parseDatabaseInfo($$config{DBPARAM}, 'SecurityModule');
	  };
	  if ($@ || !$dbparam) {
	      die "no way to initialize SecurityModule:  either configure secmod-config ",
	      "or provide SecurityModule section in the DBParam file",
	      ($@ ? ": parse error: $@" : ""), "\n";
	  }
	  $args{DBNAME} = $$dbparam{DBH_DBNAME};
	  $args{DBUSER} = $$dbparam{DBH_DBUSER};
	  $args{DBPASS} = $$dbparam{DBH_DBPASS};
	  $args{LOGLEVEL} = ($$config{SECMOD_LOGLEVEL} || 3);
	  $args{REVPROXY} = $$config{SECMOD_REVPROXY} if $$config{SECMOD_REVPROXY};
      }
      $$page{SECMOD} = new CMSWebTools::SecurityModule::Oracle({%args});
  }

  # Generate the page
  $page->generate($config, $db);
}

# Parses DBParam file, returns a configuration object
# TODO:  Should just use Toolkit/Common/UtilsDB
sub parseDatabaseInfo
{
    my ($file, $section) = @_;
    my $self = {};
    $$self{DBCONFIG} = $file.':'.$section;

    $$self{DBH_LIFE} = 86400;
    $$self{DBH_AGE} = 0;
    if ($$self{DBCONFIG} =~ /(.*):(.*)/)
    {
	$$self{DBCONFIG} = $1;
	$$self{DBSECTION} = $2;
    }

    my $insection = $$self{DBSECTION} ? 0 : 1;
    open (DBCONF, "< $$self{DBCONFIG}")
	or die "$$self{DBCONFIG}: $!\n";

    while (<DBCONF>)
    {
	chomp; s/#.*//; s/^\s+//; s/\s+$//; s/\s+/ /g; next if /^$/;
	if (/^Section (\S+)$/) {
	    $insection = ($1 eq $$self{DBSECTION});
	} elsif (/^Interface (\S+)$/) {
	    $$self{DBH_DBITYPE} = $1 if $insection;
	} elsif (/^Database (\S+)$/) {
	    $$self{DBH_DBNAME} = $1 if $insection;
	} elsif (/^AuthDBUsername (\S+)$/) {
	    $$self{DBH_DBUSER} = $1 if $insection;
	} elsif (/^AuthDBPassword (\S+)$/) {
	    $$self{DBH_DBPASS} = $1 if $insection;
	} elsif (/^AuthRole (\S+)$/) {
	    $$self{DBH_DBROLE} = $1 if $insection;
	} elsif (/^AuthRolePassword (\S+)$/) {
	    $$self{DBH_DBROLE_PASS} = $1 if $insection;
	} elsif (/^ConnectionLife (\d+)$/) {
	    $$self{DBH_LIFE} = $1 if $insection;
	    $$self{DBH_CACHE} = 0 if $insection && $1 == 0;
	} elsif (/^LogConnection (on|off)$/) {
	    $$self{DBH_LOGGING} = ($1 eq 'on') if $insection;
	} elsif (/^LogSQL (on|off)$/) {
	    $ENV{PHEDEX_LOG_SQL} = ($1 eq 'on') if $insection;
	} elsif (/^SessionSQL (.*)$/) {
	    push(@{$$self{DBH_SESSION_SQL}}, $1);
	} else {
	    die "$$self{DBCONFIG}: $.: Unrecognised line\n";
	}
    }
    close (DBCONF);

    die "$$self{DBCONFIG}: database parameters not found\n"
	if (! $$self{DBH_DBITYPE} || ! $$self{DBH_DBNAME}
	    || ! $$self{DBH_DBUSER} || ! $$self{DBH_DBPASS});

    die "$$self{DBCONFIG}: role specified without username or password\n"
	if ($$self{DBH_DBROLE} && ! $$self{DBH_DBROLE_PASS});
    return $self;
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  $config_file =~ s/DEVNAME/$ENV{PHEDEX_DEV}/;
  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^([-a-zA-Z0-9]+):\s+(\S+)$/)
    {
	my $name = uc $1;
	my $value = $2;
	$name =~ s/-/_/g;
	
	$$config{$name} = $value;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE CONNECTION);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
      my $dbparam_config = &parseDatabaseInfo($$config{DBPARAM}, $$info{CONNECTION});
      $$info{DBPARAM} = $dbparam_config;
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme();
exit(0);
