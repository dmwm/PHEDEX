#!/usr/bin/env perl

# NOTE: Taint mode under mod_perl is actually enabled by PerlSwitches
# in the apache configuration.  CGI.pm under mod_perl does NOT taint
# the output of params(), so using taint mode as an enforcement of
# validating user input is not possible without replacing the use of
# params() in this code to something like Apache::Request.

our $TESTING = 0;
our $TESTING_MAIL = undef;
our $DBS_LOOKUP = undef;

#use PHEDEX::Web::FrontendAuth;
use PHEDEX::Web::LocalAuth;
use PHEDEX::Core::SQL;
use Data::Dumper;
use POSIX qw(SIGALRM);

######################################################################
package Web25::Common; use strict; use warnings; use base "Exporter";
use CGI qw(:standard unescape Vars);
use PHEDEX::Web::Util;
use Net::hostent;
require Socket;
use POSIX qw(strftime mktime);
use Mail::RFC822::Address 'validlist';

our @EXPORT = qw(allparams validate_all urlencode dblink toclink pagelink
		 alert warning breakAtSlash note help
		 age format_num format_percent format_size format_timespan shorten
		 badcolor warncolor pendcolor goodcolor altcolor
		 dbexec dbprep dbbindexec dbinlist makeObjWithAttrs
		 timeSeries formatTime timegm sizeValue
		 auth_help_msg auth_help_warning auth_help_popup
		 fetch_nodes fetch_groups fetch_dbses fetch_identity
                 send_email
		 yesno striplabels
		 dump_params dump_var
		 parse_userdata dbs_lookup resolve_data fetch_replicas
);

# Various useful colours
our $badcolor = '#ff9e9e';
our $warncolor = '#ffd89e';
our $pendcolor = '#ccccff'; # ececff
our $goodcolor = '#ccffcc';
our $altcolor = '#f0f0f0';

# Return a hash of all parameters
sub allparams
{
    my %params = Vars();
    foreach my $key (keys %params) {
	my @vals = split("\0", $params{$key});
	$params{$key} = \@vals if ($#vals > 0);
    }
    return \%params;
}

# Validates all parameters
sub validate_all
{
    my ($self,%spec) = @_;
    my $params = &allparams();
    # FIXME:  the 'graph' key needs special treatment. If we are switching pages, it will be set to an invalid
    # value, and must take the default value instead. This is a bit of a hack, but there you go...
    if ( $self->{GRAPHS} )
    {
      if ( !$params->{graph} || !$self->{GRAPHS}{$params->{graph}} ) {
        $params->{graph} = $self->{DEFAULT_GRAPH};
      }
    }
    # the following are allowed on any page and set by this application
    # FIXME:  avoid this if possible.  save into $self instead of push into param() ?
    my @tosave = qw(page view);
    my %save;
    foreach my $p (keys %$params) {
	$save{$p} = delete $params->{$p} if grep $_ eq $p, @tosave;
    }
    %save = &validate_params(\%save, allow => \@tosave);

    # the 'action' and 'actionvalue' fields need to be used to build a real
    # entry in the params, so it can be correctly validated. But only for
    # 'rate' and 'inject_now'!
    if ( $params->{action} &&
        ($params->{action} eq 'rate' || $params->{action} eq 'inject_now')
       ) {
      $params->{$params->{action}} = $params->{actionvalue};
    }

    return &validate_params
	($params, %spec,
	 delete_empty => 1,   # HTML forms send empty strings for empty text fields
	 stack_skip => 1),    # report errors as coming from one call above this
	%save;                # tack on the saved common parameters to the output
}

# Encode arguments into a URL query string.
sub urlencode
{
  eval "use CGI '-oldstyle_urls'";
  my %args = @_; return new CGI (\%args)->query_string();
}

# Generate a HTML <a> link for a database instance.
sub dblink
{
  my ($self, $dbname, $db) = @_;
  return "<a href='" . $self->myurl('db' => $$db{ID})
    . "' title='$$db{TITLE} database instance'>$$db{TITLE}</a>";
}

# Generate a HTML <a> link for a category.  For now this is just a
# link to the first page of the category.
sub toclink
{
  my ($self, $category) = @_;

  # Scan pages for this category
  no strict "refs";
  my @pages = ();
  my $scope = \%{*{$category}{PACKAGE} . "::"};
  foreach (keys %$scope)
  {
    next if ! /::$/;
    next if ! exists ${$$scope{$_}}{INDEX};
    push(@pages, ${$$scope{$_}}{INDEX});
  }

  @pages = sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @pages;
  return &pagelink($self, $pages[0], ${$$category}{TITLE});
}

# Generate a HTML <a> link for a page.
sub pagelink
{
  my ($self, $page, $label) = @_;
  my $title = "";
  my $url = ${$$page}{LINK};
  my $name = *{$page}{PACKAGE}; $name =~ s/Web25:://;
  $label = ${$$page}{TITLE} if ! defined $label;

  # If the page has a title, stuff into a link attribute.
  if (${$$page}{LINK_TITLE})
  {
    $title = " title='@{[&escapeHTML(${$$page}{LINK_TITLE})]}'";
  }

  # If the page has a URL, convert relative one; otherwise generate a URL.
  if ($url && $url !~ /^[a-z]+:/ && substr($url,0,1) ne '/') 
  {
    $url = "$$self{CONFIG}{SERVICE_PATH}/$url";
  }
  elsif (! $url)
  {
    $url = $self->myurl("page" => $name);
  }

  # Return final link.
  return "<a href='$url'$title>" .  &escapeHTML($label) . "</a>";
}

# Convert a time difference into human-friendly short age string.
sub age
{
  my ($diff, $precision) = @_;
  $precision = 'minute' if !defined $precision;
  if (! grep ($precision eq $_, qw(second minute)) ) {
      die "Bad args to age()\n";
  }

  my $str = "";
  if ( $diff < 0 ) {
    $str = '-';
    $diff = abs($diff);
  }

  if ($precision ne 'minute' &&  abs($diff) <= 3600) {
      $str .= sprintf("%dm", $diff / 60);
      $diff %= 60;
      $str .=  sprintf("%02d", $diff);
      return $str;
  }

  if (abs($diff) >= 86400)
  {
    $str .= sprintf("%dd", $diff / 86400);
    $diff %= 86400;
  }
  $str .= sprintf("%dh", $diff / 3600);
  $diff %= 3600;
  $str .= sprintf("%02d", $diff / 60);
  return $str;
}

# Convert a time span into human-friendly long string.
sub format_timespan
{
  my $span = shift;
  if ($span >= 86400)
  {
    $span /= 86400;
    return $span == 1 ? "day" : "$span days";
  }
  elsif ($span >= 3600)
  {
    $span /= 3600;
    return $span == 1 ? "hour" : "$span hours";
  } elsif ($span >= 60) {
    $span /= 60;
    return $span == 1 ? "minute" : "$span minutes";
  } else {
    return $span == 1 ? "second" : "$span seconds";
  }
}

sub breakAtSlash
{
  my ($val) = @_;
  return unless $val;
  my $agent = $ENV{HTTP_USER_AGENT} || "";
  $val =~ s,/,/&\#8203;,g if ($agent =~ /Mozilla/ && $agent !~ /MSIE/);
  return $val;
}

# Generate an alert into the output.
sub alert
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    "<p><b>Error:</b> ", @_, "</p></div></center>\n";
}

# Generate a warning into the output.
sub warning
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='warning'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate a note into the output.
sub note
{
  my $self = shift(@_);
  print { $$self{CONTENT} }
    "<center><div class='note'>",
    "<p>", @_, "</p></div></center>\n";
}

# Generate hide/show help
sub help
{
    my ($linktext, $helpsubject, @help) = @_;
    my $id = 'help'.rand();
    my @ret = ("<a class='help' href='#' onclick='return hideshow(\"$id\")'>$linktext</a>",
	       "<div id='$id' style='display:none' class='help'>",
	       "<a href='#' class='closelink' onclick='return hideshow(\"$id\")'>[close]</a>",
	       "<p class='title'>$helpsubject</p>",
	       "<p class='body'>",
	       @help,
	       "</p>",
	       "</div>");
    return wantarray ? @ret : join '', @ret;
}


# Format a number as a string.  Zero is converted into a dash.
sub format_num
{
  my ($n) = @_;
  return $n ? "$n" : '&#8211;';
}

# Format number as percent.  Zero is converted into a dash.
sub format_percent
{
  my ($n) = @_;
  return $n ? sprintf("%.1f %%", $n*100) : '&#8211;';
}

# Format a file size as a string.  The value is automatically
# abbreviated with a k/M/G/T/P/E suffix, either the first that
# applies or a minimum scale requested by the caller.  The default
# precision is one decimal point, but the caller can change this.
sub format_size {
  my ($bytes, $nodash, $precision, $minscale) = @_;
  if ( !defined $bytes ) { return $nodash ? undef : '&#8211;'; }

  my $onescale = 0;
  if (defined $minscale && $minscale =~ /^=/) {
      $minscale =~ s/=//; $onescale = 1;
  }

  my @bounds = ([  10**3, 'k' ], [  10**6, 'M' ], [  10**9, 'G' ],
		[ 10**12, 'T' ], [ 10**15, 'P' ], [ 10**18, 'E' ]);
  my ($val, $unit, $minus) = ($bytes, '', $bytes < 0 ? "-" : "");
  do { $val = -$val; $bytes = -$bytes; } if $minus;
  while (@bounds && ($bytes >= $bounds [0][0] || defined $minscale))
  {
    $val = $bytes / $bounds[0][0];
    $unit = $bounds[0][1];
    if (defined $minscale && $minscale eq $unit) {
	undef $minscale;
	last if $onescale;
    }
    shift (@bounds);
  }

  $precision = "1" if ! defined $precision;
  return $bytes || $nodash
    ? sprintf("%s%.${precision}f %sB", $minus, $val, $unit)
    : '&#8211;';
}

# Returns a clipped version of a long string with a toggle control to expand the string
sub shorten {
    my ($tag, $id, $width, $string) = @_;
    return $string;  #TODO:  Actually get this working.
    my $uniq_id = $tag.'_'.$id;
    my $twidth = $width+2;
    return "<div id='$uniq_id' style='width:${twidth}em' class='short'><span class='short' style='width:${width}em;'>$string</span>".
	"<a class='shorttoggle' href='#' onclick='return shortlong(this,\"$uniq_id\",${width})'>...</a></div>";
}

# Tidy up SQL statement
sub dbsql
{
  my ($sql) = @_;
  $sql =~ s/--.*//mg;
  $sql =~ s/^\s+//mg;
  $sql =~ s/\s+$//mg;
  $sql =~ s/\n/ /g;
  return $sql;
}

# Simple utility to prepare a SQL statement
sub dbprep
{
  my ($dbh, $sql) = @_;
  return $dbh->prepare (&dbsql ($sql));
}

# Simple utility to prepare, bind and execute a SQL statement.
sub dbexec
{
  my ($dbh, $sql, %params) = @_;
  my $stmt = &dbprep ($dbh, $sql);
  my $rv = &dbbindexec ($stmt, %params);
  return wantarray ? ($stmt, $rv) : $stmt;
}

# Simple bind and execute a SQL statement.
sub dbbindexec
{
  my ($stmt, %params) = @_;
  my $isarray = 0;
  while (my ($param, $val) = each %params)
  {
    if (ref $val eq 'ARRAY')
    {
      $stmt->bind_param_array ($param, $val);
      $isarray++;
    }
    elsif (ref $val)
    {
      $stmt->bind_param_inout ($param, $val, 4096);
    }
    else
    {
      $stmt->bind_param ($param, $val);
    }
  }

  return $isarray
    ? $stmt->execute_array({ ArrayTupleResult => [] })
    : $stmt->execute();
}

# Retrun an sql fragment and a bind hash for an SQL "IN" list
sub dbinlist
{
    my ($prefix, @binds) = @_;
    my $in_list = join(', ', map { ":${prefix}_".($_+1) } (0..$#binds));                                                            
    my %in_binds = map { (":${prefix}_".($_+1) => $binds[$_]) } (0..$#binds); 
    return $in_list, %in_binds;
}


# Convenience wrapper for automatically constructing an object
# with requested set of attributes.
sub makeObjWithAttrs
{
  my ($dbh, $kind, $link, $obj, @attrs) = @_;
  my ($tname, $sname) = ("t_$kind", "seq_$kind");
  my @objfields = keys %$obj;
  my %objattrs = map { (":attr_$_" => $$obj{$_}) } @objfields;

  my $objsql =
    "insert into $tname ("
    . join(", ", "id", @objfields)
    . ")\n values ("
    . join(", ", "$sname.nextval", map { ":attr_$_" } @objfields)
    . ")\n returning id into :id";
  my $id = undef;
  &dbexec($dbh, $objsql, ":id" => \$id, %objattrs);

  $tname .= "_attr"; $sname .= "_attr";
  while (@attrs)
  {
    my ($name, $value) = splice(@attrs, 0, 2);
    &dbexec($dbh, qq{
      insert into $tname (id, $link, name, value)
      values ($sname.nextval, :Id, :name, :value)},
      ":id" => $id, ":name" => $name, ":value" => $value);
  }

  return $id;
}

# Print a help message about authentication requirements
# Takes a hash of $power => [@requirements]
# The first entry of @requirements should be the authentication level,
# the rest are the required roles for $power
sub auth_help_msg 
{
    my ($self, %powers) = @_;

    my $cert_login_url = $self->myurl("secure" => 1);
    my $passwd_login_url = $self->myurl("secure" => 1, "SecModPwd" => 1);

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';
    my $contact_mail = "mailto:$$self{CONFIG}{FEEDBACK_MAIL}";

    my %auth_words = ( 'cert' => 'grid certificate authentication',
		       'passwd' => 'password authentication',
		       'anyauth' => 'to log in via grid certificate or password');
    my $msg = '';
    my %help;
    sub or_list {
	my $last = pop @_;
	return join(', ', @_)." or $last";
    }

    foreach my $power (keys %powers) {
	my @requirements = @{$powers{$power}};
	my $auth_level = shift @requirements;
	$help{$auth_level} = 1;
	$msg .= "You need <b>$auth_words{$auth_level}</b>";
	if (@requirements) {
	    @requirements = map { "<b>'$_'</b>" } @requirements;
	    $help{'sitedb'} = 1;
	    $msg .= ' and to be a '.&or_list(@requirements);
	}
	$msg .= " in order to $power.<br/>  ";
    }
    $msg .= "<br/>";

    if (exists $help{'passwd'} || exists $help{'anyauth'}) {
	$msg .= "Passwords are managed via <a href='$sitedb_url'>SiteDB</a> ".
	    "and are synced with the CMS hypernews passwords.  ";
    }

    if (exists $help{'cert'} || exists $help{'anyauth'}) {
	$msg .= "You can go <a href='$gridcert_help_url'>here</a> to find help on obtaining a grid certificate.  ";
    }

    if (exists $help{'sitedb'}) {
	$msg .= "Authorization roles are handled by <a href='$sitedb_url'>SiteDB.</a> ";
    }

    my $login_msg;
    if (exists $help{'anyauth'} || (exists $help{'cert'} && exists $help{'passwd'})) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a> ".
	    "or <a href='$passwd_login_url'>password</a>";
    } elsif (exists $help{'cert'}) {
	$login_msg = "logged in <a href='$cert_login_url'>with your certificate</a>";
    } else {
	$login_msg = "logged in <a href='$passwd_login_url'>with your password</a>";
    }

    $msg .= "If you think you have the necessary rights in SiteDB ".
	"and are $login_msg but you are still ".
	"having problems with this page, try this:".
	"<ul style='text-align:left'>".
	"<li>Verify that <a href='https://cmsweb.cern.ch/auth/trouble'>you are known to SiteDB</a></li>".
	"<li>If you are, then verify that <a href='/phedex/datasvc/perl/prod/auth'>you have the correct authorisation</a></li>".
	"<li>If both those conditions are satisfied, and you still get this message, please <a href='$contact_mail'>contact the PhEDEx developers</a>, and include the results from those tests.</li>".
	"</ul>  ";

    return $msg;
}

sub auth_help_popup 
{
    my ($self, %powers) = @_;
    print {$$self{CONTENT}} &help('Privileged Activities Help', 'Privileged Activities', $self->auth_help_msg(%powers), "<br/>");
}

sub auth_help_warning
{
    my ($self, %powers) = @_;
    $self->warning($self->auth_help_msg(%powers));
}


# Returns a list of nodes.
# If argument 'with_ids' is true, returns a hash of node_name => node_id
# else it returns an array of nodes
#
# If web_user_auth is set with the name of some role (e.g. 'Data
# Manager'), we check the security module to find out if the user has
# that role, find out for which sites they have that role, and return
# a list of nodes associated with those sites.
#
# web_user_auth can be set with multiple roles separated by '||', for
# which all authorized nodes among those roles will be returned.
# (e.g. web_user_auth => 'Data Manager||Site Admin')
#
# The role 'Admin' need not be specified in web_user_auth.  If
# the user is a Admin then all nodes are always returned.
#
# Otherwise it returns from t_adm_node table, which contains all nodes.
# The default behavior is to return an array of all nodes from t_adm_node.
sub fetch_nodes
{
# TW Need to move to PHEDEX::Web::Util
    return PHEDEX::Web::Util::fetch_nodes(@_);
}

# Returns a list of groups.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_groups
{
    my ($self, %args) = @_;
    my %groups;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_adm_group});
    while (my ($group, $group_id) = $q->fetchrow()) {
	$groups{$group} = $group_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %groups;
    } else {
	return keys %groups;
    }
}

# Returns a list of DBSes.
# If argument 'with_ids' is true, then return a hash of name => id
# else return an array of DBS names
sub fetch_dbses
{
    my ($self, %args) = @_;

    my %dbses;
    my $q = &dbexec($$self{DBH}, qq{select name, id from t_dps_dbs});
    while (my ($dbs, $dbs_id) = $q->fetchrow()) {
	$dbses{$dbs} = $dbs_id;
    }
    
    if (exists $args{with_ids} && $args{with_ids}) {
	return %dbses;
    } else {
	return keys %dbses;
    }
}


# Tries to resolve the user's identity and returns it.  Also logs the
# identity to the t_adm_identity table, if it is not already there.
# Note:  does not commit this logging activity, this is left to the function caller
sub fetch_identity
{
    my ($self, $secmodUser) = @_;

    my $id = {};
    my @to_sync;

    if (! $secmodUser ) {
	if (! $$self{SECMOD}->isAuthenticated() || !$$self{SECMOD}->isKnownUser() ) { return; }

	#$$id{SECMOD_ID} = $$self{SECMOD}->getID();
	$$id{NAME} = $$self{SECMOD}->getUsername();
	$$id{EMAIL} = $$self{SECMOD}->getEmail();

	if ($$self{SECMOD}->isCertAuthenticated()) {
        #@to_sync = qw(SECMOD_ID NAME EMAIL DN CERTIFICATE);
        @to_sync = qw(NAME EMAIL DN CERTIFICATE);
	    $$id{DN} = $$self{SECMOD}->getDN();
	    $$id{CERTIFICATE} = $$self{SECMOD}->getCert();
	} elsif ($$self{SECMOD}->isPasswdAuthenticated()) {
        #@to_sync = qw(SECMOD_ID NAME EMAIL USERNAME);
        @to_sync = qw(NAME EMAIL USERNAME);
	    $$id{USERNAME} = $$self{SECMOD}->getUsername();
	}
    } else {
	$$id{SECMOD_ID} = $$secmodUser{ID};
	$$id{NAME} = $$secmodUser{FORENAME} .' '. $$secmodUser{SURNAME};
	$$id{EMAIL} = $$secmodUser{EMAIL};
	$$id{DN} = $$secmodUser{DN};
	$$id{USERNAME} = $$secmodUser{USERNAME};
    #@to_sync = qw(SECMOD_ID NAME EMAIL DN USERNAME);
    @to_sync = qw(NAME EMAIL DN USERNAME);
    }
    my $now = time();

    # Look up a logged identity by either the SecurityModule ID or the DN
    my $q = &dbexec($$self{DBH},
            qq{ select id, secmod_id, name, email, dn, certificate, username
                from t_adm_identity where secmod_id = :secmod_id or dn = :dn
                or username = :username
                order by time_update desc },
                ':secmod_id' => $$id{SECMOD_ID},
                ':username' => ($$id{USERNAME} || 'dummy'),
                ':dn' => ($$id{DN} || 'dummy')
		    );

    my $logged_id = $q->fetchrow_hashref();

    my $synced = ($logged_id ? 1 : 0);
    foreach my $param (@to_sync) {
	last if !$synced;
	no warnings;  # we need to compare undef values too
	$synced &&= $$logged_id{$param} eq $$id{$param};
    }

    if ($logged_id && $synced) {
	# If everything is logged and up-to-date, return the identity information
	return $logged_id;
    } elsif ($logged_id && !$synced) {
	# If it is logged, but out of date, update it then return the information by recursing
	my $sql = qq{ update t_adm_identity set };
	my @params = map { "$_ = :$_" } (@to_sync, "TIME_UPDATE");
	$sql .= join(', ', @params);
	$sql .= qq{ where id = :id };
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;
	$binds{':ID'} = $$logged_id{ID};

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    } else {
	# If it is not logged, log it then recurse
	my $sql = qq{ insert into t_adm_identity };
	$sql .= '('.join(', ', "ID", @to_sync, "TIME_UPDATE").') ';
	$sql .= 'values ('.join(', ', "seq_adm_identity.nextval", map { ":$_" } (@to_sync,'TIME_UPDATE')).')';
	my %binds = map { (":$_" => $$id{$_}) } @to_sync;
	$binds{':TIME_UPDATE'} = $now;

	&dbexec($$self{DBH}, $sql, %binds);
	return $self->fetch_identity($secmodUser);
    }
}

sub send_email
{
    my (%args) = @_;

    # Required arguments
    foreach (qw(subject from to message)) {
	return 0 unless exists $args{$_};
    }

    # Make to and cc arrays unique
    foreach (qw(to cc)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    my %unique;
	    $unique{$_} = 1 foreach @{$args{$_}};
	    $args{$_} = [keys %unique];
	}
    }

    # Ensure names are not duplicated from to to cc
    if (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	&& ref $args{to} eq 'ARRAY') {
	my @uniquecc;
	foreach my $mail (@{$args{cc}}) {
	    push @uniquecc, $mail unless grep $_ eq $mail, @{$args{to}};	    
	}
	$args{cc} = [ @uniquecc ];
    } elsif (exists $args{cc} && ref $args{cc} eq 'ARRAY'
	     && ref $args{to} ne 'ARRAY') {
	$args{cc} = [ grep $_ ne $args{to}, @{$args{cc}} ];
    } elsif (exists $args{cc}
	     && ref $args{to} eq 'ARRAY') {
	delete $args{cc} if grep $_ eq $args{cc}, @{$args{to}};
    } elsif (exists $args{cc}) {
	delete $args{cc} if $args{cc} eq $args{to};
    }
    
    foreach (qw(from to cc replyto)) {
	if (exists $args{$_} && ref $args{$_} eq 'ARRAY') {
	    $args{$_} = join(', ', @{$args{$_}});
	} elsif ( exists $args{$_} && ! $args{$_} ) {
	    $args{$_} = '';
	}
    }
    
    foreach (qw(from to cc replyto)) {
	next unless exists $args{$_};
	return 0 unless &validlist($args{$_});
    }

    # For debugging without bothering people
    if ($TESTING) {
	$args{subject} = "TESTING:  $args{subject}";
	$args{message} .= "\n\nTO:  $args{to}\n\n"; $args{to} = $TESTING_MAIL;
	if ($args{cc}) {$args{message} .= "\n\nCC:  $args{cc}\n\n"; delete $args{cc};}
    }

    (open (MAIL, "| /usr/sbin/sendmail -t")
     && (print MAIL
 	 "Subject: $args{subject}\n",
 	 "From: $args{from}\n",
 	 (exists $args{replyto} ? "Reply-To:  $args{replyto}\n" : ''),
 	 "To: $args{to}\n",
 	 (exists $args{cc} ? "Cc: $args{cc}\n" : ''),
 	 "\n",
 	 $args{message},
 	 "\n" )
     && close(MAIL))
 	or do { return 0; };
    
    return %args;
}

sub yesno 
{ 
    $_ = shift @_;
    return undef unless $_;
    s/^y$/Yes/; s/^n$/No/; 
    return $_; 
}

sub striplabels 
{ 
    my @stripped =  map { s:<[/]*label>::g; $_; } @_; 
    return wantarray ? @stripped : shift @stripped;
}

sub dump_params
{
    my $fh = shift @_;
    print { $fh } "<pre>$_:\n", Dumper(param($_)), "</pre>" foreach param();

}

sub dump_var
{
    my ($fh, $name, $var) = @_;
    my $out = Dumper($var);
    $out =~ s/\n//g;
    print { $fh } "<pre>$name:\n", Dumper($var), "</pre>";
}

# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
  my ($first, $range, $now) = @_;
  $now ||= time();
  my @series = ();
  $first = int($first);

  if ($range eq 'hour') {
    # Convert first time to UTC hour in units of half a day.  Then
    # make a time series of hours until end of current 4 hours.
    my $low = int($first / 3600);
    my $high = int($now / 3600) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
    }
  } elsif ($range eq 'day') {
    # Convert first time to UTC day at 00:00.  Then make a
    # time series of days until end of today.
    my $low = int($first / 86400);
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; ++$low) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
    }
  } elsif ($range eq 'week') {
    # Convert first time to previous Monday.  Then make a
    # time series of weeks until we pass today.
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $low = int($first/86400) - $diff{$wday};
    my $high = int($now / 86400) + 1;
    for ( ; $low < $high; $low += 7) {
      push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
    }
  } elsif ($range eq 'month') {
    # Convert first time to first of the month.  Then convert
    # into a time-series of months.  This is a bit dodgy, we
    # go by day so we don't need to worry about month dates.
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
    my $start = int(($first - ($mday-1)*86400)/86400);
    my $limit = int($now / 86400) + 1;
    while ($start < $limit)
    {
      my $low = $start;
      my ($prevyear, $prevmon) = ($year, $mon);
      while ($year == $prevyear && $mon == $prevmon)
      {
	($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
	  = gmtime ((++$start) * 86400);
      }
      push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
    }
  }

  return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
  my ($time, $range) = @_;
  return undef unless ($time && $range);
  return undef if ($time <= 0);
  if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
  elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
  elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
  elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
  elsif ($range eq 'stamp') { return strftime ('%Y-%m-%d %H:%M:%S UTC', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
  my @args = @_;
  my $t1 = mktime (@args);
  my @gmt = gmtime ($t1);
  my $t2 = mktime (@gmt);
  return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
  my ($value) = @_;
  if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
  {
    my %scale = ('k' => 10**3,  'M' => 10**6,  'G' => 10**9,
		 'T' => 10**12, 'P' => 10**15, 'E' => 10**18);
    $value = $1 * $scale{$2};
  }
  return $value * 1.0;
}

# Takes an array of user data clobs and parses out single dataset and block globs
# Returns a hash of key:  glob pattern value: item type (DATASET or BLOCK)
sub parse_userdata
{
    my ($self, @userdata) = @_;
    my %parsed;
    foreach my $string (@userdata) {
	$string =~ s/^\s+//;  $string =~ s/\s+$//;
	my @data = split(/\s+/, $string);
	foreach my $item (@data) {
	    if ($item =~ m<^/[^/]+/[^/]+(/[^/]+|\#[^\#]+)$>) {
		$parsed{$item} = ($1 =~ /\#/ ? 'BLOCK' : 'DATASET');
	    } else {
		$parsed{$item} = undef;
	    }
	}
    }
    return %parsed;
}

sub dbs_lookup
{
    my ($dbs, $pattern) = @_;

    ### Security:  Strict list of characters allowed to go to shell
    my $reg = qr/[^\w\.\*\-\#\/\?=:\+\&]/;
    foreach (@_) {
	if (/$reg/) {
	    die "Invalid string '$_' given to dbs_lookup()";
	}
    }
        
    if ($dbs =~ /^https/) {
	# remove secure connection
	$dbs =~ s/^https/http/;
	$dbs =~ s|:\d+/|/|;
	$dbs =~ s/_writer//;
    }

    my $dbslookup = $DBS_LOOKUP || '/bin/false';
    my $dbscmd = "$dbslookup -u '$dbs' -d '$pattern'";
    my $dbsresults = `$dbscmd`;
    warn "DBSLookup results:  ", $dbsresults, "\n" if $TESTING;

    my @paths;
    if ($dbsresults) {
	foreach (split "\n", $dbsresults) {
	    push @paths, $_ if /^\//;
	}
    }
    return @paths;
}



# Resolve user datasets;  Search DPS and DBS for glob patterns
# Fill data object with results:
# $$resolved{$userglob} = [ { params }, ... ]
# Where { params } contains:
#   DBS = dbs the data was found in PhEDEx, not necessarily the one the user specified
#   LEVEL = 'BLOCK' or  'DATASET'
#   DATASET = Dataset name
#   BLOCK = Block name.  undef if LEVEL = DATASET
#   ID = The dps unique id for item
#   FILES = Number of files
#   BYTES = Data size
#   DPS_ISKNOWN = 'y' or 'n'
#   DBS_ISKNOWN = 'y' or 'n'
sub resolve_data
{
    my ($dbh, $userdbs, $static, @userdata) = @_;

    my $resolved = {};
    my $userdupes = {};
    my $dbsdupes = {};
    my $all = {};

    foreach my $level (qw(DATASET BLOCK)) {
	$$all{$level} = [];
    }

    # We assume the user is giving us wildcard searches
    # So first we turn the wildcard searches into compiled regexps and
    # SQL like patterns
    my %has = ( DATASET => 0, BLOCK => 0);
    my %userglob_re;
    my %userglob_like = ( DATASET => [], BLOCK => [] );
    foreach my $userglob (@userdata) {
	$$resolved{$userglob} ||= [];

	my $level = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
	$has{$level}++;

	my $re = $userglob;
	$re =~ s:\*+:[^/\#]+:g;                              # simple glob to regex, only * is supported
	$re .= '#[^/\#]+' if $static && $level eq 'DATASET'; # turn dataset match into block match if static
	$userglob_re{$userglob} = qr/^$re$/;                 # compile regexp

	my $like = $userglob;
	$like =~ s:\*+:%:g;                                  # glob to sql like, only * is supported
	push @{$userglob_like{$level}}, $like;
    }

    # Now we look for matching data in TMDB using the SQL like patterns
    # We order by ID so we can check for redundant DBS items later
    my $all_items = {};
    if ($has{DATASET} && !$static) {
	my %binds;
	my $ds_lookup = $userglob_like{DATASET};

	my $sql =  qq{
	   select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset,
                  nvl(sum(b.files),0) files, nvl(sum(b.bytes),0) bytes
	     from t_dps_dataset ds
   	     join t_dps_dbs dbs on dbs.id = ds.dbs
             left join t_dps_block b on b.dataset = ds.id
	 }
	. 'where ('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'ds.name', @$ds_lookup).')'
        . qq{ group by dbs.id, dbs.name, ds.id, ds.name
	      order by ds.id };
	
	$all_items->{DATASET} = &dbexec($dbh, $sql, %binds)->fetchall_arrayref({});
    }
    
    if ($has{BLOCK} || ($has{DATASET} && $static)) {
	my %binds;
	my $b_lookup = $userglob_like{BLOCK};
	my $ds_lookup = $userglob_like{DATASET};

	my $sql = qq{
	   select dbs.id dbs_id, dbs.name dbs, ds.id dataset_id, ds.name dataset,
	          b.id block_id, b.name block, b.files, b.bytes
	     from t_dps_block b
	     join t_dps_dataset ds on b.dataset = ds.id
	     join t_dps_dbs dbs on ds.dbs = dbs.id
            where
	};

	my @filters;
	if ($has{BLOCK}) {
	    push @filters,
	    '('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'b.name', @$b_lookup).')';
	}
	if ($has{DATASET} && $static) {
	    push @filters,
	    '('.&PHEDEX::Core::SQL::filter_or_like($dbh, undef, \%binds, 'ds.name', @$ds_lookup).')';
	}

	$sql .= join ' or ', @filters;
	$sql .= " and b.is_open = 'n'";
	$sql .= ' order by b.id';

	$all_items->{BLOCK} = &dbexec($dbh, $sql, %binds)->fetchall_arrayref({});
    }

    # Now we go through all the data we just found and use the regexps
    # patterns we made to find what data matched what user request.
    # We need to do this because we want to be able to tell the user
    # which of their strings did not match anything

    foreach my $level (keys %$all_items) {
	my $resultset = $$all_items{$level};
	my $lastid = -1;
	foreach my $row (@$resultset) {
	    my $id = $$row{$level.'_ID'};
	    my $name = $$row{$level};

	    # DBS redundancy checking
	    if ($id == $lastid) {
		$$dbsdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;

	    # Search the TMDB for the user's glob
	    foreach my $userglob (@userdata) {
		my $globlevel = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
		next if (!$static && $level ne $globlevel);
		next unless $name =~ $userglob_re{$userglob};

		push @{$$all{$level}}, $id;

		push @{$$resolved{$userglob}},  { DBS => $$row{DBS},
						  LEVEL => $level,
						  DATASET => $$row{DATASET},
						  BLOCK   => $$row{BLOCK},
						  FILES   => $$row{FILES},
						  BYTES   => $$row{BYTES},
						  REPLICAS => [],
						  DPS_ISKNOWN => 'y',
						  DBS_ISKNOWN => 'y', # XXX This is assuming DPS and DBS are in sync
						  ID => $id };
	    }
	}
    }

    # Lookup in DBS items not found in TMDB. TODO: Put some limit on
    # this.  We are able to look up 1000's of items from TMDB, but
    # getting data from DBS is slower and the user will not know why
    # their search failed
    my $undef_id = 0;
    foreach my $userglob (@userdata) {
	if ($userdbs && ! @{$$resolved{$userglob}}) {
	    my @dbsdata = dbs_lookup($userdbs, $userglob);
	    my $globlevel = ($userglob =~ m/\#/ ? 'BLOCK' : 'DATASET');
	    foreach my $name (@dbsdata) {
		$undef_id++;
		push @{$$resolved{$userglob}}, { DBS => $userdbs,
						 LEVEL => $globlevel,
						 DATASET => ($globlevel eq 'DATASET' ? $name : undef),
						 BLOCK   => ($globlevel eq 'BLOCK' ? $name : undef),
						 DPS_ISKNOWN => 'n',
						 DBS_ISKNOWN => 'y',
						 ID => 'undef'.$undef_id };
	    }
	}
    }

    # Look for data which the user has requested in duplicate
    my $lastid = -1;
    foreach my $level (qw(DATASET BLOCK)) {
	foreach my $id (sort @{$$all{$level}}) {
	    if ($id == $lastid) {
		$$userdupes{$level}{$id} = 1;
	    }
	    $lastid = $id;
	}
    }

    # Attach replicas and subscriptions to resolved data.  We use the IDs from the data
    # we successfully looked up in TMDB to do this efficiently
    my $all_replicas = {};
    my $all_subscriptions = {};
    foreach my $level (qw(DATASET BLOCK)) {
	my @ids = @{$$all{$level}};
	while ( my @batch = splice @ids, 0, 1000 ) { # query groups of 1000 items
	    my $replicas = &fetch_replicas($dbh, $level, @batch);
	    foreach my $rep (@$replicas) {
		$all_replicas->{$level}->{ $rep->{ $level.'_ID' } } ||= [];
		push @{ $all_replicas->{$level}->{ $rep->{ $level.'_ID' } } }, $rep;
	    }
	    my $subscriptions = &fetch_subscriptions($dbh, $level, @batch);
	    foreach my $subsc (@$subscriptions) {
		$all_subscriptions->{$level}->{ $subsc->{ $level.'_ID' } } ||= [];
		push @{ $all_subscriptions->{$level}->{ $subsc->{ $level.'_ID' } } }, $subsc;
	    }
	}
    }

    foreach my $userglob (@userdata) {
	foreach my $item (grep $_->{DPS_ISKNOWN} eq 'y', @{$$resolved{$userglob}}) {
	    $item->{REPLICAS} = $all_replicas->{$item->{LEVEL}}->{$item->{ID}};
	    $item->{SUBSCRIPTIONS} = $all_subscriptions->{$item->{LEVEL}}->{$item->{ID}};
	}
    }
    
    # Return our results
    if (wantarray) {
	return ($resolved, $userdupes, $dbsdupes);
    } else {
	return $resolved;
    }
}

# returns all subscriptions matching the given datasets or blocks and
# their completion status
sub fetch_replicas
{
    my ($dbh, $level, @items) = @_;
    return undef unless ($dbh && $level && @items);

    my $block_select = '';
    my $block_group_by = '';
    my %binds;
    my $where;
    if ($level eq 'DATASET') {
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'ds.id', @items).')';
    } elsif ($level eq 'BLOCK') {
	$block_select = 'b.id block_id, ';
	$block_group_by = ', b.id';
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'b.id', @items).')';
    }

    my $q = &dbexec($dbh, qq{
	select n.id node_id, n.name node_name, ds.id dataset_id,
               $block_select
               nvl(sum(br.node_files),0) files, nvl(sum(br.node_bytes),0) bytes,
	       sign(sum(decode(br.is_custodial, 'y', 1, 0))) is_custodial
         from t_dps_dataset ds
         join t_dps_block b on b.dataset = ds.id
         join t_dps_block_replica br on br.block = b.id
         join t_adm_node n on n.id = br.node
        where (br.node_files != 0)
          and $where
	  group by n.id, n.name, ds.id $block_group_by }, %binds);

    return $q->fetchall_arrayref({});
}

sub fetch_subscriptions
{
    my ($dbh, $level, @items) = @_;
    return undef unless ($dbh && $level && @items);

    my %binds;
    my $where;
    if ($level eq 'DATASET') {
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'sb.dataset', @items).')';
    } elsif ($level eq 'BLOCK') {
	$where = '('.&PHEDEX::Core::SQL::filter_or_eq($dbh, undef, \%binds, 'sb.id', @items).')';
    }

    my $q = &dbexec($dbh, qq{
	select NVL2(s.block, 'BLOCK', 'DATASET') subs_lvl,
	       NVL2(s.block, s.block, s.dataset) subs_item_id,
	       sb.dataset dataset_id, sb.id block_id,
	       n.id node_id, n.name node_name,
	       s.is_move, s.is_custodial
	  from t_dps_subscription s
          join t_dps_block sb on sb.id = s.block or sb.dataset = s.dataset
          join t_adm_node n on s.destination = n.id 
	 where $where }, %binds);

    return $q->fetchall_arrayref({});
}

# Given a list of dataset IDs and/or block IDs, calculate the number of files and bytes total
sub calculate_size
{
    my ($self, %args);

    my ($datasets, $blocks) = @args{qw(datasets blocks)};
    unless (($datasets && ref $datasets =~ /^ARRAY/) ||
	    ($blocks && ref $blocks =~ /^ARRAY/)) {
	die "calculate size called without dataset or block arrays";
    }

    my @where;
    my %binds;
    if ($datasets) {
	my ($ds_list, %ds_binds) = &dbinlist('ds', @{$datasets});
	push @where, $ds_list;
	$binds{$_} = $ds_binds{$_} foreach keys %ds_binds;
    }

    if ($blocks) {
	my ($b_list, %b_binds) = &dbinlist('b', @{$blocks});
	push @where, $b_list;
	$binds{$_} = $b_binds{$_} foreach keys %b_binds;
    }
    
    my $where_str = join ' or ', @where;
    my $sql = qq{ select sum(b.files), sum(b.bytes)
                    from t_dps_dataset ds
                    join t_dps_block b on b.dataset = ds.id
		    where $where_str };

    my ($files, $bytes) = &dbexec($$self{DBH}, $sql, %binds)->fetchrow();

    return ($files, $bytes);
}

1;

######################################################################
# A tool to create paged results given an SQL query
package Web25::QueryPager;
use strict; use warnings;
use CGI qw(param);
use POSIX qw(ceil);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{RESULTS_PER_PAGE} = 10;
  $$self{BINDS} = {};

  bless $self, $class;
  return $self;
}

# Initialize with
#  $webself  :  A reference to a Web25 object
#  $select   :  SQL to pageinate
#  $binds    :  (Optional, default null)  Hashref of bind parameters for $select
#  $results_per_page  :  (Optional, default 10)  Number of results to show per page
#  $rank_col  :  (Optional, default null) column to group results by
#  $filters  :  (Optional, default null)  hashref of column_name => regexp to filter to post-filter results
sub init
{
    my ($self, $webself, $select, $binds, $results_per_page, $rank_col, $filters) = @_;
    $self->process_filters($filters) if $filters;

    $$self{WEB} = $webself;
    $$self{DBH} = $$webself{DBH};
    $$self{SELECT} = $select;
    $$self{BINDS} = $binds if $binds;
    $$self{RESULTS_PER_PAGE} = $results_per_page if $results_per_page;
    $$self{RANK_COL} = $rank_col;
    $$self{FILTERS} = $filters if $filters && %{$filters};
    $$self{TOTAL_RESULTS} = $self->count_results();
    $$self{TOTAL_PAGES} = $self->total_pages();
    $$self{CURRENT_PAGE} = param('page_num') || 1;
    if ($$self{CURRENT_PAGE} <= 0 
	|| $$self{CURRENT_PAGE} > $$self{TOTAL_PAGES}) {
	$$self{CURRENT_PAGE} = 1;
    }

    if (!$$self{FILTERS}) {
	if (!$$self{RANK_COL}) {
	    $$self{PAGED_SQL} = qq[select * from ( select r.*, rownum as result_number
						   from ($$self{SELECT}) r 
						   where rownum <= :end_result ) 
				   where :start_result <= result_number ];
	} else {
	    $$self{PAGED_SQL} = qq[select * from 
				   (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) result_number
				    from ($$self{SELECT}) results )
				   where result_number >= :start_result and result_number <= :end_result];
	}
	my $start_result = $self->page_to_result();
	my $end_result = $start_result + $$self{RESULTS_PER_PAGE} - 1;
	$$self{BINDS}{':start_result'} = $start_result;
	$$self{BINDS}{':end_result'} = $end_result;
    } else {
	if (@{$$self{FILTERED_RESULTS}}) {
	    my $start_result = $self->page_to_result();
	    my @page_results = splice @{$$self{FILTERED_RESULTS}}, $start_result - 1, $$self{RESULTS_PER_PAGE};
	    my ($result_list, %result_binds) = &dbinlist('result_id', @page_results);
	    $$self{BINDS}{$_} = $result_binds{$_} foreach keys %result_binds;
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where r.rowid in ($result_list)];
	} else {
	    $$self{PAGED_SQL} = qq[select r.*, rownum as result_number, r.rowid
		  	             from ($$self{SELECT}) r
			            where 1 = 0];
	}
    }
}


sub get_total_results
{
    my ($self) = @_;
    return $$self{TOTAL_RESULTS};
}

# Returns the pager widget
sub pager
{
    my ($self) = @_;

    my $current_page = $$self{CURRENT_PAGE};
    my $total_pages = $$self{TOTAL_PAGES};

    return if $total_pages == 1;

    my @pager_html;

    push @pager_html, "<div class='pager'>Page $current_page of $total_pages:  ";
   
    if ($current_page > 1) {
	push @pager_html, $self->page_link(1, '[First]'), " \n";
	push @pager_html, $self->page_link(($current_page-1), '[Prev]'), " \n";
    }

    for (my $i = ($current_page-5); $i <= $current_page+5; $i++) {
	next if ($i < 1 || $i > $total_pages);

	if ($i != $current_page) {
	    push @pager_html, $self->page_link($i, $i), " \n";
	} else {
	    push @pager_html, $self->page_link($i, "<strong><big>$i</big></strong>"), " \n";
	}
    }

    if ($current_page < $total_pages) {
	push @pager_html, $self->page_link(($current_page+1), '[Next]'), " \n";
	push @pager_html, $self->page_link($total_pages, '[Last]'), " \n";
    }

    push @pager_html, "</div>";
    return @pager_html;
}

# Returns a query handle with 1 page's worth of results
sub paged_result
{
    my ($self) = @_;
    my $t1 = time();
    my $q = &dbexec($$self{DBH}, $$self{PAGED_SQL}, %{$$self{BINDS}});
    my $t2 = time();
    $$self{TIME_RESULT} = $t2 - $t1;
    return $q;
}

### Private functions ###

sub process_filters
{
    my ($self, $filters) = @_;
    foreach (keys %{$filters}) {
	my $f = $$filters{$_};
	if (!defined $f ||
	    $f eq '' ||
	    $f eq '.*') {
	    delete $$filters{$_};
	}
    }
}

# Return a link to a page
sub page_link
{
    my ($self, $page_num, $linktext) = @_;
# Using this method screws up when using https which seems like a CGI bug
# unfortunately this binds us to using the myurl() function...
#     my @ignore = qw(page);
#     my $cgi = new CGI;
#     $cgi->delete(@ignore);
#     $cgi->param('page_num', $page_num);
#     my $url = $cgi->self_url(-secure=>1);
    my $url = $$self{WEB}->myurl('page_num' => $page_num);
    return "<a href='$url'>$linktext</a>";
}

sub total_pages
{
    my $self = shift @_;
    my ($total_results, $results_per_page) = ($$self{TOTAL_RESULTS}, $$self{RESULTS_PER_PAGE});
    if ($total_results < 1) { $total_results = 1; }
    return POSIX::ceil($total_results/$results_per_page);
}

sub page_to_result
{
    my $self = shift @_;
    my ($current_page, $results_per_page) = ($$self{CURRENT_PAGE}, $$self{RESULTS_PER_PAGE});
    return ( ($current_page - 1 ) * $results_per_page + 1 );
}

sub count_results
{
    my $self = shift @_;

    my $t1 = time();
    my $num_results;
    if (!$$self{FILTERS}) {
	# No post-processing required, get results from sql query
	my $sql;
	if (!$$self{RANK_COL}) {
	    $sql = qq[select count(*) as num_results from ($$self{SELECT})];
	} else {
	    $sql = qq[select max(rank) from 
		      (select results.*, dense_rank() over (order by results.$$self{RANK_COL}) rank
                       from ($$self{SELECT}) results)];
	}
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	($num_results) = $q->fetchrow();
    } else {
	# Full get all results, applying filters to get count, and caching rowid
	my $t1 = time();
	$$self{FILTERED_RESULTS} = [];
	my $sql = qq[select r.*, rownum as result_number, r.rowid
		       from ($$self{SELECT}) r ];
	my $q = &dbexec($$self{DBH}, $sql, %{$$self{BINDS}});
	while (my $row = $q->fetchrow_hashref()) {
	    my $keep = 1;
	    foreach my $col (keys %{$$self{FILTERS}}) {
		$keep &&= ($$row{$col} =~ /$$self{FILTERS}{$col}/);
	    }
	    push @{$$self{FILTERED_RESULTS}}, $$row{ROWID} if $keep;
	}
	$num_results = scalar @{$$self{FILTERED_RESULTS}};
    }
    my $t2 = time();
    $$self{TIME_COUNT} = $t2 - $t1;

    return $num_results || 0;
}

1;

######################################################################
# A tool to print an html table
# many options for formatting cell data, row style and cell style
# based on given subrefs

package Web25::TableSpool;
use strict; use warnings;
use CGI qw(param escapeHTML);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{FH} = *STDOUT;
  $$self{STRIPE} = undef;
  $$self{ROWCNT} = 0;
  $$self{COLCNT} = 0;
  $$self{TABLECOLS}   = undef;
  $$self{TABLEHEAD}   = undef;
  $$self{TABLECLASS}  = undef;
  $$self{STRIPECLASS} = undef;
  $$self{DATAFORMATS} = undef;
  $$self{ROWFORMATS}  = undef;
  $$self{CELLFORMATS} = undef;
  $$self{PSEUDOCOLS}  = undef;
  $$self{QUERYCOLS}   = undef;
  $$self{STATCOLS}    = undef;
  $$self{STATS}       = undef;
  $$self{FILTERS}     = undef;

  bless $self, $class;
  return $self;
}

# Set filehandle to print to 
sub set_filehandle
{
    my ($self, $fh) = @_;
    $$self{FH} = $fh;
}

# $cols: array ref of DB_column_names to output (others are ignored)
sub set_tablecols
{
    my ($self, $cols) = @_;
    $$self{TABLECOLS} = $cols;
}

# Sets columns to display based on CGI query parameters
# takes a list of column descriptions of the form
# (label, querykey, columnkeys, is_default)
# If no specified query variables are found, the 'is_default' columns are shown
sub set_querycols
{
    my ($self, @column_descriptions) = @_;
    $$self{QUERYCOLS} = [@column_descriptions];
    my %checked_querykeys;
    my @foundcols;
    my @defaultcols;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	unless (exists $checked_querykeys{$querykey}) {
	    foreach my $param_columnkeys (param($querykey)) {
		push @foundcols, split( /:/, $param_columnkeys);
	    }
	}
	$checked_querykeys{$querykey} = 1;
	push @defaultcols, split( /:/, $columnkeys ) if $is_default;
    }

    if (@foundcols) { $self->set_tablecols([ @foundcols ]); }
    else { $self->set_tablecols([ @defaultcols ]); }
}


# $th : hash of DB_column_name=>Pretty_column_name for table headers
sub set_tablehead
{
    my ($self, $th) = @_;
    $$self{TABLEHEAD} = $th;
}

# $class :  CSS class for the HTML table
sub set_tableclass
{
    my ($self, $class) = @_;
    $$self{TABLECLASS} = $class;
}

# $stripe :  CSS class for striped rows
sub set_stripeclass
{
    my ($self, $class) = @_;
    $$self{STRIPECLASS} = $class;
}
# $dataformats : hash of DB_column_name=>formatting_subroutine($data, $rowref) for formatting data
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_dataformats
{
    my ($self, $df) = @_;
    $$self{DATAFORMATS} = $df;
}

# $cellformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the cell (<td>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_cellformats
{
    my ($self, $cf) = @_;
    $$self{CELLFORMATS} = $cf;
}

# $rowformats : hash of DB_column_name=>class_subroutine($data, $rowref) for formatting the row (<tr>)
# $data is the data of DB_column_name
# $rowref is a reference to the current row data
sub set_rowformats
{
    my ($self, $rf) = @_;
    $$self{ROWFORMATS} = $rf;
}

# $sc : hashref of DB_column_name =>function name
# function name may be SUM, COUNT or AVERAGE
sub set_statcols
{
    my ($self, $sc) = @_;
    $$self{STATCOLS} = $sc;
    $$self{STATS} = {};
    foreach my $name (keys %{$sc}) {
	die "TableSpool::set_statscols:  Unknown function requested" 
	    unless (grep $$sc{$name} eq $_, qw(SUM COUNT AVERAGE));
	$$self{STATS}{$name}{COUNT} = 0;
	$$self{STATS}{$name}{SUM}   = 0;
    }
}

# $f : hashref of DB_column_name => subref
# subref is passed the data of DB_column_name in $_[0], and the rest of the columns in $_[1]
# if the subroutine returns true the row is kept, otherwise this row is not printed
# works on pre-formatted data
sub set_filters
{
    my ($self, $f) = @_;
    $$self{FILTERS} = $f;
}

# Returns the earlier requested statistics
sub get_stats
{
    my ($self) = @_;

    my $res = {};
    foreach my $name (keys %{$$self{STATS}}) {
	next unless grep ($name eq $_, @{$$self{TABLECOLS}});
	my $func = $$self{STATCOLS}{$name};
	my $sum = $$self{STATS}{$name}{SUM};
	my $count = $$self{STATS}{$name}{COUNT};
	if ($func eq 'SUM') {
	    $$res{$name} = $sum;
	} elsif ($func eq 'COUNT') {
	    $$res{$name} = $count;
	} elsif ($func eq 'AVERAGE') {
	    $$res{$name} = sprintf("%.2f", $sum/$count) unless $count == 0;
	}
    }
    return keys %{$res} ? $res : undef;
}

# $pseudocols : hash with key 'name' (column name) and value 'generator' (sub ref)
# for generating a pseudocolumn in the table.  Requires 'name' to be in TABLEHEAD for output.
# 'generator' is passed the hash of the current row data, before any processing
sub add_pseudocolumn
{
    my ($self, $name, $generator) = @_;
    $$self{PSEUDOCOLS} = {} unless $$self{PSEUDOCOLS};
    $$self{PSEUDOCOLS}->{$name} = $generator;
}



# Print the beginning of the table
sub start
{
    my ($self) = @_;
    print { $$self{FH} }
    "<table ", $$self{TABLECLASS} ? "class='$$self{TABLECLASS}'" : '', ">\n";
}

# Print the title columns
sub head
{
    my ($self, @headers) = @_;

    if (@headers) {
	# Do nothing
    } elsif ($$self{TABLECOLS} && $$self{TABLEHEAD}) {
	foreach (@{$$self{TABLECOLS}}) {
	    my $colhead;
	    if (exists $$self{TABLEHEAD}{$_}) {
		$colhead = $$self{TABLEHEAD}{$_};
	    } else {
		$colhead = $_;
	    }
	    push @headers, $colhead;
	}
    } elsif ($$self{TABLECOLS}) {
	@headers = @{$$self{TABLECOLS}};
    }

    if (!@headers) {
	die "TableSpool::head called without any column information\n";
    }

    print { $$self{FH} } "<thead>\n";
    print { $$self{FH} } "<tr>";
    print { $$self{FH} } "<th> . &escapeHTML($_) . </th>" foreach (@headers);
    print { $$self{FH} } "</tr>\n";
    print { $$self{FH} } "</thead>\n";
    print { $$self{FH} } "<tbody>\n";

    $$self{COLCNT} = scalar @headers;
}

# Prints a row, taking either an array of data
# or a hashref of labled data (name=>val)
sub row
{
    my ($self, @row) = @_;

    if (ref $row[0] eq 'HASH') {
	$self->hash_row($row[0]);
    } else {
	if (ref $row[0] eq 'ARRAY') {
	    @row = @{$row[0]};
	}

	my $rowclass = '';
	if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	    $rowclass = " class='$$self{STRIPECLASS}'";
	}
	
	print { $$self{FH} } "<tr$rowclass>";
	print { $$self{FH} } "<td>$_</td>" foreach (@row);
	print { $$self{FH} } "</tr>";
	$$self{ROWCNT}++;
    }
    return $$self{ROWCNT};
}

sub rows
{
    my ($self, $row_ary) = @_;
    foreach my $row (@{$row_ary}) {
	$self->row($row);
    }
}

# Print a row from a hash applying all features
sub hash_row
{
    my ($self, $row, $rowclass) = @_;
    $rowclass = '' if !defined $rowclass;

    # Copy the row
    my $myrow = {%{$row}};

    # Add the pseudocolumns to the row
    if ($$self{PSEUDOCOLS}) {
	foreach my $name (keys %{$$self{PSEUDOCOLS}}) {
	    $myrow->{$name} = &{$$self{PSEUDOCOLS}->{$name}}(undef, $myrow);
	}
    }

    # Check filters
    if ($$self{FILTERS}) {
	foreach my $name (keys %{$$self{FILTERS}}) {
	    return 0 unless &{$$self{FILTERS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Format data row if format sub provided   
    if ($$self{ROWFORMATS}) {
	my $rowclass_ary = [];
	foreach my $name (keys %{$$self{ROWFORMATS}}) {
	    push @{$rowclass_ary}, &{$$self{ROWFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
	$rowclass = join(' ', $rowclass, @{$rowclass_ary});
    }

    # Format data cell if format sub provided
    my $cellclass_hash = {};
    if ($$self{CELLFORMATS}) {
	foreach my $name (keys %{$$self{CELLFORMATS}}) {
	    $cellclass_hash->{$name} = &{$$self{CELLFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Gather statistics for columns
    if ($$self{STATCOLS}) {
	foreach my $name (keys %{$$self{STATCOLS}}) {
	    # Get number
	    next unless defined $myrow->{$name};
	    my ($val) = ($myrow->{$name} =~ /([+-]?(\d+\.\d+|\d+\.|\.\d+|\d+)([eE][+-]?\d+)?)/);
	    $$self{STATS}{$name}{COUNT}++ if defined $val;
	    $$self{STATS}{$name}{SUM} += $val if defined $val;
	}
    }

    # Format data columns if format sub provided
    if ($$self{DATAFORMATS}) {
	foreach my $name (keys %{$$self{DATAFORMATS}}) {
	    $myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	}
    }

    # Print out the row with the appropriate classes
    if ($$self{STRIPECLASS} && $$self{ROWCNT}%2 != 0) {
	$rowclass .= ' '.$$self{STRIPECLASS};
    }

    if ($rowclass) { $rowclass = " class='$rowclass'"; }
  
    print { $$self{FH} } "<tr$rowclass>";

    foreach my $name (@{$$self{TABLECOLS}}) {
	my $cellclass = '';
	if (exists $cellclass_hash->{$name}) {
	    $cellclass = " class='".$cellclass_hash->{$name}."'";
	}
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td$cellclass>$val</td>";
    }
    print { $$self{FH} } "</tr>\n";
    $$self{ROWCNT}++;
    return $$self{ROWCNT};
}

# Prints a <tfoot> section and a single row - for stats.
sub footrow
{
    my ($self, $myrow) = @_;

    print { $$self{FH} } "<tfoot><tr>";
    foreach my $name (@{$$self{TABLECOLS}}) {
	my $val = defined $myrow->{$name} ? $myrow->{$name} : '';
	print { $$self{FH} } "<td>$val</td>";
    }
    print { $$self{FH} } "</tr></tfoot>";
}


# Finish, returns number of rows printed
sub finish
{
    my ($self) = @_;
    print { $$self{FH} } "</tbody>\n";

    my $results = $self->get_stats();

    if ($results) {
	my $myrow = {%{$results}};  # copy

	# Format data columns if format sub provided
	if ($$self{DATAFORMATS}) {
	    foreach my $name (keys %{$$self{DATAFORMATS}}) {
		next unless exists $myrow->{$name};
		$myrow->{$name} = &{$$self{DATAFORMATS}->{$name}}($myrow->{$name}, $myrow);
	    }
	}

	$self->footrow($myrow);
    }

    print { $$self{FH} } "</table>\n";
    return $$self{ROWCNT};
}

# Returns form inputs for column selection
# requires set_querycols
sub columns_form
{
    my ($self) = @_;

    my @checked;
    my @defaults;
    foreach my $desc (@{$$self{QUERYCOLS}}) {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	foreach my $param_columnkeys (param($querykey)) {
	    push @checked, $label if ($param_columnkeys eq $columnkeys);
	}
	push @defaults, $label if ($is_default);
    }

    unless (@checked) {
	@checked = @defaults;
    }


    my $form = "";
    $form .= "<p><i>Display Columns</i></p>\n";
    foreach my $desc (@{$$self{QUERYCOLS}})
    {
	my ($label, $querykey, $columnkeys, $is_default) = @{$desc};
	$form .= "<input type='checkbox' name='$querykey' value='$columnkeys'";
	$form .= (grep $_ eq $label, @checked) ? " checked='checked'" : "";
	$form .= " />&nbsp;$label<br/>\n";
    }
    
    return $form;
}

1;

######################################################################
# A simple class to print an HTML table of a DB query
package Web25::DBTable;
use strict; use warnings;
use base "Web25::TableSpool";

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  bless $self, $class;
  return $self;
}

# Output a table given a statement handle $sth,
# $sth : database handle to iterate on
sub output
{
    my ($self, $sth) = @_;

    if (! $$self{TABLECOLS}) {
	$self->set_tablecols($sth->{NAME});
    }

    if (! $$self{TABLEHEAD}) {
	my $th = {};
	$th->{$_} = $_ foreach (@{$sth->{NAME}});
	$self->set_tablehead($th);
    }

    $self->start();    
    $self->head();
    while (my $row = $sth->fetchrow_hashref()) {
	$self->row($row);
    }
    return $self->finish();
}

1;

######################################################################
package Web25::OptsPane;
use strict; use warnings;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = {};

  $$self{TABS} = [];
  $$self{HIDDEN} = [];
  $$self{TARGET} = "#";

  bless $self, $class;
  return $self;
}

sub set_form_target
{
    my ($self, $target) = @_;
    $$self{TARGET} = $target;
}

sub add_tab
{
    my ($self, $name, $form) = @_;
    my $id = scalar @{$$self{TABS}};
    push @{$$self{TABS}}, { id => $id, name => $name, form => $form };
}

sub add_hidden
{
    my ($self, $form) = @_;
    push @{$$self{HIDDEN}}, $form;
}

sub output
{
    my ($self) = @_;

    my $html = "";

    $html .= "<form method='get' action='$$self{TARGET}'>\n";

    $html .= "<div id='optsnav'>\n";
    foreach my $tab (@{$$self{TABS}}) {
	my $class = $tab->{id} == 0 ? 'raised' : 'lowered';
	$html .= "<div class='$class' onclick='return showtab($tab->{id})' id='optstab$tab->{id}'><a href='#'>$tab->{name}</a></div>\n";
    }
    $html .= "</div>\n";


    foreach my $tab (@{$$self{TABS}}) {
	my $display = $tab->{id} == 0 ? '' : 'style=\'display:none;\'';
	$html .= "<div class='optscontent' $display id='optspane$tab->{id}'>\n";
	$html .= $tab->{form};
	$html .= "</div>\n";
    }
    foreach my $hidden (@{$$self{HIDDEN}}) {
	$html .= $hidden;
    }

    $html .= "<div id='optsfoot'>\n";
    $html .= "<input type='submit' value='Cancel' onclick='return hideshow(\"opts\")'/>&nbsp;\n";
    $html .= "<input type='submit' value='Apply' />\n";
    $html .= "</div>\n";

    $html .= "</form>\n";


    return $html;
}

sub link
{
    my ($self, $linkname) = @_;
    "<a href='#' onclick='return hideshow(\"opts\")'>$linkname</a><br/>\n";
}

1;

######################################################################
package Web25::Page;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
use Digest::MD5;
import Web25::Common;

our $TEMPLATE_DEFAULT = <<'END_OF_TEMPLATE';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="PhEDEx, file transfer, transfer request" />
  <meta name="PhEDEx-tag" contents="PhEDEx-web @VERSION@" />
  @REFRESH@

<!--define basic CSS for the body here (fonts etc), so the page doesn't wobble when css files get loaded later.-->
  <style type='text/css' id='phedex-body-style'>
    body {
      margin:           0;
      margin-left:      1em;
      padding:          0;
      font-size:        80%;
      font-family:      'Lucida Grande', verdana, helvetica, arial, sans-serif;
      line-height:      1.6em;
    }
  </style>

  <link rel="stylesheet" href="@ROOTURL@style25.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-screen.css" type="text/css" />
  <link rel="stylesheet" href="@ROOTURL@nifty-print.css" type="text/css" media="print"/>
  <link rel="stylesheet" href="@ROOTURL@datasvc/app/yui/build/grids/grids-min.css" type="text/css"/>
  <link rel="shortcut icon" href="@ROOTURL@favicon.ico" />
  <script type="text/javascript" src="@ROOTURL@stripe.js"></script>
  <script type="text/javascript" src="@ROOTURL@nifty.js"></script>
  <script type="text/javascript"><!--
    function hideshow(item, show) {
      var obj = document.getElementById(item);
      if (obj == undefined) { return false; }
      if (obj.style.display == '' || show == 0)
      {
        obj.style.display = 'none';
      }
      else if (obj.style.display != '' || show == 1)
      {
        obj.style.display = '';
      }
      return false;
    }

function hideshowdropdown(dropdown) {
    var myindex  = dropdown.selectedIndex;
    var selvalue = dropdown.options[myindex].value;
    for (i in dropdown.options) {
	var op = dropdown.options[i].value;
	if (op != selvalue) {
	    hideshow(op, 0);
	} else {
	    hideshow(op, 1);
	}
    }
}

function shortlong(link,item,width) {
    var obj = document.getElementById(item);
    if (obj.style.width != width) {
	obj.style.width = (width+2) + "em";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = width + "em";
    } else {
        obj.style.width = "auto";
        content = obj.getElementsByTagName("span")[0];
        content.style.width = "auto"
    }
    return false;
}

    function showtab(tab) {
	var i=0;
	var tabobj;
	var paneobj;
	for (i=0;i<10;i++) {
	    tabobj = document.getElementById('optstab'+i);
	    paneobj = document.getElementById('optspane'+i);
	    if (tab == i) {
		tabobj.className = 'raised';
		paneobj.style.display = '';
	    } else {
		tabobj.className = 'lowered';
		paneobj.style.display = 'none';
	    }
        }
	return false;
    }

function select_all(form_id, name, value) {
    var formblock= document.getElementById(form_id);
    var forminputs = formblock.getElementsByTagName('input');
    for (i = 0; i < forminputs.length; i++) {
	if (forminputs[i].getAttribute('name') == name) {
	    if (value == '1') {
		forminputs[i].checked = true;
	    } else {
		forminputs[i].checked = false;
	    }
	}
    }
}

--></script>

  @HIGHCHARTS@
  @JQUERY@
  <title>@DBTITLE@ @PAGETITLE@ - CMS PhEDEx</title>

  <!-- Page-specific head elements -->
  @HEAD@
  <!-- /head -->
</head>

<body onload='
  stripe("#fff", "#edf3fe");
  if (! NiftyCheck()) return;
  Rounded("div.toc", "top", "transparent", "#e4f1db");
  // Rounded("div.menuopt li", "top", "transparent", "#e4f1db");
'>
<iframe id="yui-history-iframe" src="/phedex/datasvc/app/images/phedex-logo-small.gif" style='visibility:hidden'></iframe>
<input id="yui-history-field" type="hidden" style='visibility:hidden'>
<div id="page">
<div id="header">
 <!-- Logo and page title -->
 <div id="logo">
  <a href="@HOMEPAGE@" title="PhEDEx Home Page"
    ><img src="@ROOTURL@phedex-logo-small.gif" alt="PhEDEx" height="80" /></a>
 </div> <!-- /logo -->

 <div id="heading">
  <h1 class="title">@PAGEHEADING@</h1>
  <div class="pagenav">
   @TOCSELECTOR@
   @PAGESELECTOR@
  </div> <!-- /pagenav -->
 </div> <!-- /heading -->
</div> <!-- /header -->

<!-- main content -->
<div id="content">
@THIS_IS_A_TEST@
@SCHEMA_VERSION@
@CONTENT@ 
</div>
</div> <!-- /page -->

<!-- corner navigation panel -->
<div class="viewnav">
@DBSELECTOR@
@IDENTITY@
</div>

<!-- options panel -->
<div id="opts" style="display:none;">
@OPTIONS@
</div>

  <script type="text/javascript" src="@ROOTURL@datasvc/app/yui/build/yuiloader-dom-event/yuiloader-dom-event.js"></script>
  <script type="text/javascript" src="@ROOTURL@datasvc/app/js/phedex-base.js"></script>
  <script type="text/javascript" src="@ROOTURL@datasvc/app/js/phedex-loader.js"></script>
  <script type="text/javascript" src="@ROOTURL@datasvc/app/js/nextgen-override.js"></script>
</body>
</html>
END_OF_TEMPLATE

sub new
{
  my ($proto, %args) = @_;
  my $class = ref($proto) || $proto;
  my %params = ( CONFIG => undef,
		 DBID   => undef );
  my $self = {};
  while (my ($k, $v) = each %args) {
      $$self{$k} = $v if exists $params{$k};
  }
  bless $self, $class;
  return $self;
}

sub toc
{
  my ($self) = @_;
  my @result = ();
  foreach (keys %{Web25::})
  {
    next if ! /::$/;
    next if ! exists ${$Web25::{$_}}{TOC};
    push (@result, ${$Web25::{$_}}{TOC});
  }
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

sub index
{
  my ($self) = @_;
  my @result = ();

  # Get the type of dynamic type of this page and navigate to
  # the namespace scope just above it (e.g. Web25::Request::).
  no strict "refs";
  my $scope = ref $self;
  $scope =~ s/[^:]+$//;

  # Search the scope for sub-types with $INDEX.  These are
  # web pages we'll offer to make visible.
  foreach (keys %$scope)
  {
    push (@result, ${$$scope{$_}}{INDEX})
      if /::$/ && exists ${$$scope{$_}}{INDEX};
  }

  # Sort the pages by order tag.
  return sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} } @result;
}

# Return a hash of existing valid parameters
sub urlparams
{
  my ($self, @names) = @_;
  my %known = map { $_ => 1 } url_param();
  my %result = ();

  foreach my $name (@names)
  {
    $result{$name} = [ url_param($name) ]
      if exists $known{$name};
  }
  return %result;
}

# Return a URL to this page, i.e. a URL which would come back to this
# page, plus additional query parameters.  The page can be changed
# with "page" parametre and database instance with "db" parametre;
# these are automatically converted into script path components such
# that the final URL is "/path/to/script[/DB[/PAGE]][?QUERY]".
sub myurl
{
  my $self = shift(@_);

  my $curpage = param('page');
  my $curlayout = param('layout');
  my $currefresh = param('refresh');
  my $cursecure = $$self{SECMOD}->isSecure();
  my $curquery = query_string();
  my %args = ('db' => $$self{DBID},
	      ($cursecure ? ('secure' => 1) : ()),
	      ($curpage ? ('page' => $curpage) : ()),
	      ($curlayout ? ('layout' => $curlayout) : ()),
	      ($currefresh ? ('refresh' => $currefresh) : ()),
	      @_);
  my $page = $args{'page'}; delete $args{'page'};
  my $db = $args{'db'}; delete $args{'db'};
  my $secure = $args{'secure'}; delete $args{'secure'};
  my $fullurl = $args{'fullurl'}; delete $args{'fullurl'};

  my $newcgi = new CGI ("");
  $newcgi->param ($_, ref $args{$_} ? @{$args{$_}} : $args{$_}) for keys %args;
  my $url = $$self{CONFIG}{SERVICE_PATH};
  my $q = $newcgi->query_string();

  if (($cursecure || 0) != ($secure || 0) 
      || $fullurl) {
      $url = $$self{CONFIG}{$secure ? "SSL_SERVER_ROOT" : "SERVER_ROOT"} . $url;
  }

  $url .= "/$db";
  $url .= "/$page" if $page;
  $url .= "?$q" if $q;
  return $url;
}

sub generate
{
  my ($self) = @_;
  my $config = $$self{CONFIG};
  my $db = $$self{DBID};

  my $signup_url = $self->myurl('fullurl' => 1, 'secure' => 1, 'page'=>'Security::SignUp');
  my $caller_url = $self->myurl('fullurl' => 1);
  my $signout_url = $self->{CONFIG}{SSL_SERVER_ROOT} . '/auth/logout';

# Instead of calling SECMOD->init directly, trap errors with a timeout.
  my $mask      = POSIX::SigSet->new(&POSIX::SIGALRM);
  my $action    = POSIX::SigAction->new(sub { die "my private alarm" }, $mask);
  my $oldaction = POSIX::SigAction->new();
  POSIX::sigaction(&POSIX::SIGALRM, $action, $oldaction );
  eval {
      alarm 10;
      $$self{SECMOD}->init($self);
      alarm 0;
  };
  POSIX::sigaction(&POSIX::SIGALRM, $oldaction); # restore original
  if ( $@ and $@ =~ /my private alarm/ ) {
    my $feedbackurl =
      "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
      . "PhEDEx%20web%20(SiteDB)%20is%20inaccessible";
    print header(-type => 'text/html'),
      "<center><div class='alert' style='background-color:#FFF0F5;border:1px solid #DC143C; text-align:center; max-width:50%; magrin:1em; padding:1em'>\n",
      "<p>Timed out connecting to SiteDB, maybe there's a database problem?</p>\n",
      " Please try again at another time, or if the problem persists,",
      " <a href='$feedbackurl'>notify the administrators</a>.",
      "</p>",
      "</div></center>\n";
    return;
  }
  if ( $@ ) { die $@; }

  # Find the class scope index of this page instance.
  my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

  # Force redirect to https if using http
  if ($$index{SECURE} && !$$self{SECMOD}->isSecure() && param('page') !~ /^Security/) {
      print redirect(-uri => $self->myurl("fullurl" => 1, "secure" => 1));
      return;
  }
  
  # Check if the client's identity was verified
  if ($$self{SECMOD}->isAuthenticated())
  {
    my $name_display = '';
    if ($$self{SECMOD}->isKnownUser()) {
        $$self{USER_NAME} = $$self{SECMOD}->getUsername();
	$name_display = &escapeHTML($$self{USER_NAME});
	my $signout = '';
        $signout = " | <a href='$signout_url'>Sign out</a>" if $$self{SECMOD}->isPasswdAuthenticated();
	my $roles = $$self{SECMOD}->getRoles() || {};
	my $rolelist = '';
	foreach my $r (sort keys %$roles) {
	    foreach my $s (sort @{$roles->{$r}}) {
		$rolelist .= "$r of $s<br/>";
	    }
	}
	$$self{LOGIN_MESSAGE} = join ('',
	  ("<div class='userstate'>",
	   "<a href='#'",
	   " onclick='return hideshow(\"userstate\")'>$name_display</a>",
	   $signout,
	   " <br/>",
	   "  <div id='userstate' style='display:none'>",
	   "   <a class='closelink' href='#' onclick='return hideshow(\"userstate\")'>[close]</a>",
	   ($rolelist ? "<b>Roles:</b><br/>$rolelist" : "No roles"),
	   "</div>",
	   " </div>"));
    } else {
	$name_display = "<a href='$signup_url'>Unknown certificate</a>";
	$$self{LOGIN_MESSAGE} =
	    "<p>$name_display</p>";
    }
  }
  else { $$self{LOGIN_MESSAGE} = ''; }

  my $login_state = $$self{SECMOD}->getAuthnState();
  if    ($login_state eq 'cert')   { $login_state = 'Logged in via Certificate'; }
  elsif ($login_state eq 'passwd') { $login_state = 'Logged in via Password'; }
  if    ($login_state eq 'failed' || !$$self{SECMOD}->isKnownUser()) { $login_state = 'Not logged in'; }
  $$self{LOGIN_MESSAGE} .= "<p>$login_state</p>";
  
  # Check whether we are looking at our vs. global view
  my $otherurl;
  if (! $$self{SECMOD}->isAuthenticated() )
  {
      $$self{MY_VIEW} = 0;
      param('view', 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>global</strong></p>";
  }
    elsif (!param('view') || param('view') eq 'my')
  {
      $$self{MY_VIEW} = 1;
      $otherurl = $self->myurl('view' => 'global');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><strong>my</strong> | <a href='$otherurl'>global</a></p>";
  }
  else
  {
      $$self{MY_VIEW} = 0;
      $otherurl = $self->myurl('view' => 'my');
      $$self{VIEW_MESSAGE} = "<p><label>View:</label><a href='$otherurl'>my</a> | <strong>global</strong></p>";
  }


  # Select page we are visiting
  my %pagemap;
  my @pages = grep(${$$_}{LIST}, $self->index());
  foreach (@pages)
  {
    my ($name) = (*{$_}{PACKAGE} =~ /Web25::(.*)/);
    $pagemap{$_} = $name;
  }

  my $page = param('page');
  my @toc = $self->toc();
  my $cat = do {
    no strict "refs";
    my $scope = ref $self;
    $scope =~ s/[^:]+$//;
    exists $$scope{TOC} ? ${"${scope}TOC"} : undef
  };

  # Check if this is running against a test location and obnoxiously warn if so
  my $testwarn = "";
  my $pageheading = 'PhEDEx &#8211; CMS Data Transfers';
  if ($ENV{PHEDEX_DEV}) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $prod =~ s!/dev/$ENV{PHEDEX_DEV}/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a development server for <b>$ENV{PHEDEX_DEV}</b>. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>($ENV{PHEDEX_DEV}'s Development)</blink>";
  } elsif ($ENV{SCRIPT_NAME} =~ m!/test/!) {
      my $prod = $self->myurl();
      $prod =~ s!/test/!/!;
      $testwarn =
	  "<center><div class='warning'>"
	  . "Hoy!  The production server is <a href='$prod'>over this way</a>."
	  . " This is a test server for the developers. You might wish to update"
	  . " your bookmarks."
	  . "</div></center>";
      $pageheading .= " <blink style='color:red;'>(TEST)</blink>";
  } elsif ($TESTING) {
      $pageheading .= " <blink style='color:red;'>(TESTING MODE)</blink>";
  }

  # Initialise page template
  my $ndb = 0;
  my $replacements = {
    'HEAD' => '',
    'THIS_IS_A_TEST' => $testwarn,
    'CONTENT' => '',
    'PAGETITLE' =>
      ($cat ? $$cat{TITLE} . " &#8211; " . $$index{TITLE} : $$index{TITLE}),
    'PAGEHEADING' => $pageheading,
    'HOMEPAGE' => $self->myurl('page'=>'Info::Main'),
    'TIME'	=> strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime(time())),
    'DBTITLE' => $$config{INSTANCES}{$db}{TITLE},
    'ROOTURL' => "$$self{CONFIG}{SERVICE_PATH}/",
    'REFRESH' => (param('refresh') ? "<meta http-equiv='refresh' content='600'>" : ""),
    'DBSELECTOR' =>
      ("<div class='dbopt'>\n" .
       "<label>DB Instance:</label><strong>$$config{INSTANCES}{$db}{TITLE}</strong>&nbsp;" .
       "<a href='@{[$self->myurl('page'=>'DB')]}'" .
       " onclick='return hideshow(\"dbopts\")'>&#187;&#187;</a>\n" .
       "  <div id='dbopts' style='display:none'>\n" .
       "   <a class='closelink' href='#' onclick='return hideshow(\"dbopts\")'>[close]</a>\n" .
       join ("",
             map { &dblink ($self, $db, $_) . "<br />\n" }
	     sort { $$a{RANK} <=> $$b{RANK} }
	     grep($$_{ID} ne $db, values %{$$config{INSTANCES}})) .
       "  </div>\n" .
       " </div>"),
    'TOCSELECTOR' =>
      (@toc ?
       "<div class='catopt'>\n" .
       " <ul>\n" .
       join("", map { "  <li"
		      . ($cat && $$_ == $cat
			 ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
			 : (">" . &toclink($self, $_)))
		      . "</li>\n" } @toc) .
       "<li id='nextgen-link'><a title='Enter the next-gen website' href='/phedex/datasvc/app'>Next-gen website</a></li>" .
       "<li id='phedex-permalink-container' style='display:none'><a id='phedex-permalink' title='Permalink to this page\'s state' href='#'>Permalink</a></li>" .
       " </ul>\n" .
       "</div>" : ""),
    'PAGESELECTOR' =>
      (@pages ?
       "<div class='menuopt'>\n" .
       " <ul>\n" .
       join("",
	    map { "  <li" .
		  ("Web25::$page" eq *{$_}{PACKAGE}
		   ? (" class='selected'><span>" . &escapeHTML(${$$_}{TITLE}) . "</span>")
		   : (">" . &pagelink($self, $_)))
		  . "</li>\n" }
	    @pages) .
       " </ul>\n" .
       "</div>" : ""),
    'IDENTITY' =>
      (" <div>\n" .
       "$$self{LOGIN_MESSAGE}\n" .
       " </div>"),
    'MYPAGE' => "<div>$$self{VIEW_MESSAGE}</div>",
    'VERSION' => "$$self{CONFIG}{VERSION}",
    'SCHEMA_VERSION' => '',
    'HIGHCHARTS' => '',
    'JQUERY' => '',
  };

  # Hide these things on the password page
  if (param('page') =~ /^Security/) { 
      $$replacements{MYPAGE} = '';
      $$replacements{IDENTITY} = '';
      $$replacements{DBSELECTOR} = '';
      $$replacements{PAGESELECTOR} = '';
      $$replacements{TOCSELECTOR} = '';
      $$replacements{THIS_IS_A_TEST} = '';
  }

   if ( $self->{CONFIG}{TESTING_MODE} ) {
     $replacements->{JQUERY} = "<script src='http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.min.js'></script>\n";
     $replacements->{HIGHCHARTS} = "<script src='http://code.highcharts.com/highcharts.js'></script>\n" .
                                 "  <script src='http://code.highcharts.com/modules/exporting.js'></script>\n";
   }
  # Execute the desired page.  We save old STDOUT to print to it
  # later, then redirect the page routine's output to CONTENT.
  my ($output, $options, $head) = ("", "", "");
  open ($$self{HEAD}, ">", \$head);
  open ($$self{CONTENT}, ">", \$output);
  open ($$self{OPTIONS}, ">", \$options);
  eval
  {
    # Connect to the database, do the page, the disconnect
    if (! $$index{NOLOGIN})
    {
      eval
      {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;

	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}
      };
      if ($@)
      {
	my $msg = $@;
	my $feedbackurl =
	  "mailto:$$self{CONFIG}{FEEDBACK_MAIL}?subject="
	  . "PhEDEx%20web%20is%20inaccessible";

	print { $$self{CONTENT} }
	  "<center><div class='alert'>\n",
	  " <p>This PhEDEx instance is not available at this time.",
	  " Please try again at another time, or if the problem",
	  " persists and this is an instance you should be using,",
	  " please <a href='$feedbackurl'>notify the administrators</a>.",
	  "</p>",
          # "<p>The database error was: <i>", &escapeHTML($@), "</i></p>",
          "</div></center>\n";

	print STDERR "$0: Internal error: $msg\n";
	return;
      }

#     If we are testing, make sure the FrontendAuth module knows about it
      if ( $self->{CONFIG}{TESTING_MODE} ) {
        my @nodes = $self->fetch_nodes();
        $self->{SECMOD}->setTestNodes(\@nodes);
      }

      # Detect the schema version and pass it into the page
      my ($major,$minor,$revision);
      eval {
        ($major,$minor,$revision) = PHEDEX::Core::SQL::getSchemaVersion($self);
      };
      if ( $@ ) { $major = $minor = $revision = 0; }
      $self->{SCHEMA} = { MAJOR=>$major, MINOR=>$minor, REVISION=>$revision };
      $replacements->{SCHEMA_VERSION} =
"<script type='text/javascript'>
 PhedexPage = {
   TestingMode: $self->{CONFIG}{TESTING_MODE},
   SchemaVersion: { major:$major, minor:$minor, revision:$revision },
   DBInstance: '$self->{DBID}',
   Instances: [\n";
      my $insts = $self->{CONFIG}{INSTANCES};
      foreach( keys %{$insts} ) {
        $replacements->{SCHEMA_VERSION} .=
	 "{name:'" . $insts->{$_}{TITLE} . "', instance:'$_'},\n";
      }
      $replacements->{SCHEMA_VERSION} .= "   ]
  };
</script>";
    }

    $self->output();
     if ($$self{DBH})
     {
       $$self{DBH}->disconnect() if $$self{DBH};
       delete $$self{DBH};
     }
  };
  if ($@)
  {
    my $message = $@;
    my $id = Digest::MD5::md5_hex($message);
    my $time = &formatTime(time, 'stamp');
    warn "$time: error: id=$id $message\n";

    my $feedbackurl = $$self{CONFIG}{BUG_SUBMIT_URL};
    my ($key,$val);
    if ($message =~ /ORA-00942/) # table or view doesn't exist
    {
      print { $$self{CONTENT} }
        "<center><div class='warning'>\n",
        " <p>This PhEDEx instance is not capable of providing",
        " this feature.  Perhaps you meant to select another PhEDEx",
        " instance in the instance menu above?</p></div></center>\n";
    }
    elsif ($message =~ /The (\S+) parameter \((.*)\) to \S+ did not pass/) # validation problem
    {
	($key, $val) = ($1, $2);
	print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Input parameter for $key did not pass validation. Please correct the input, or ",
        " <a href='$feedbackurl'>submit a bug report</a>.</p>\n",
	" <p>(use the 'back' button of your browser to return to the form)</p>\n",
        " <p><i>Error time=$time id=$id</i></p>\n",
        "</div></center>\n";	
    }
    elsif ($message =~ /but was not listed in the validation options: (\w+)/)
    {
	$val = $1;
	print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Unknown input parameter ($val). Please correct the input, or ",
        " <a href='$feedbackurl'>submit a bug report</a>.</p>\n",
	" <p>(use the 'back' button of your browser to return to the form)</p>\n",
        " <p><i>Error time=$time id=$id</i></p>\n",
        "</div></center>\n";	
    }
    elsif ($message =~ /Invalid string (.*) given to dbs_lookup/)
    {
	$val = $1;
	print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>\"$val\" is not a valid dataset-name. Please correct the input and try again</p>\n",
	" <p>(use the 'back' button of your browser to return to the form)</p>\n",
        "</div></center>\n";	
    }
    elsif ($message =~ /^cannot request/ || $message =~ /^cannot create request/) # from PHEDEX::RequestAllocator::Core::validateRequest
    {
	$val = $1;
	print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>$message</p>\n",
	" <p>(use the 'back' button of your browser to return to the form)</p>\n",
        "</div></center>\n";	
    }
    else
    {
      print { $$self{CONTENT} }
        "<center><div class='alert'>\n",
        " <p>Apologies, looks like we have an internal server error,",
        " details of which below.  If the problem persists, please",
        " <a href='$feedbackurl'>submit a bug report</a>.</p>\n",
        " <p><i>Error time=$time id=$id</i></p>\n",
        "</div></center>\n";
    }
  }
  if ( $self->{REDIRECT} ) {
    redirect(-status => $self->{REDIRECT_STATUS} || 301, Location => $self->{REDIRECT});
    return;
  }
  close($$self{HEAD});
  close($$self{CONTENT});
  close($$self{OPTIONS});
  $$replacements{HEAD} = join("\n", $head);
  $$replacements{CONTENT} = join("\n", $output);
  $$replacements{OPTIONS} = join("\n", $options);

  # Instantiate the desired template and spit it out
  my $result = $TEMPLATE_DEFAULT;
  while (my ($key, $value) = each %$replacements)
  {
    $result =~ s/\@$key\@/$value/g;
  }

  print header(-type => 'text/html'), $result;
}

1;

######################################################################
package Web25::XML;
use strict; use warnings;
use base "Exporter";
use DBI;
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

sub new
{
    my ($proto, %args) = @_;
    my $class = ref($proto) || $proto;
    my %params = ( CONFIG => undef,
		   DBID   => undef );
    my $self = {};
    while (my ($k, $v) = each %args) {
	$$self{$k} = $v if exists $params{$k};
    }
    bless $self, $class;
    return $self;
}

sub generate
{
    my ($self) = @_;
    my $config = $$self{CONFIG};
    my $db = $$self{DBID};

    my $index = do { no strict "refs"; ${"@{[ref $self]}::INDEX"} };

    my ($output) = ("");
    open ($$self{CONTENT}, ">", \$output);
    eval
    {
	my $dbtns = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBNAME};
        my $dbuser = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBUSER};
        my $dbpass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBPASS};
	$$self{DBH} = DBI->connect ("DBI:Oracle:$dbtns", $dbuser, $dbpass,
	    		            { RaiseError=>1, AutoCommit =>0 });
        $$self{DBH}{FetchHashKeyName} = "NAME_uc";
        $$self{DBH}{private_self} = $self;
	
	if (exists $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE}) {
	    my $role_name = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE};
	    my $role_pass = $$config{INSTANCES}{$db}{DBPARAM}{DBH_DBROLE_PASS};
	    &dbexec($$self{DBH}, 
		    qq{set role $role_name identified by $role_pass });
	}

	$self->output();
	if ($$self{DBH})
	{
	    $$self{DBH}->disconnect() if $$self{DBH};
	    delete $$self{DBH};
	}
	close($$self{CONTENT});
    };
    if ($@) {
	my $message = $@;
	my $id = Digest::MD5::md5_hex($message);
	my $time = &formatTime(time, 'stamp');
	warn "$time: error: id=$id $message\n";

	print {$$self{CONTENT}} "<error id='$id' time='$time'/>";
    }

    my $root = $$index{ROOT} ? $$index{ROOT} : 'data';
   
    print header(-type => 'text/xml', -encoding=>'ISO-8859-1');
    print "<?xml version='1.0' encoding='ISO-8859-1'?>\n";
    print "<$root>";
    print $output;
    print "</$root>";
}

1;

######################################################################
package Web25::XML::TransferStatus;
use strict; use warnings;
use base "Web25::XML";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { ROOT => 'ajax-response' };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my %params = $self->validate_all
	( allow => [qw(dataset se_name id_suffix)],
	  required => [qw(dataset se_name)],
	  spec  => {
	      dataset   => { using => 'dataset', multiple => 1 },
	      se_name   => { using => 'hostname', multiple => 1 },
	      id_suffix => { regex => qr/^[A-Za-z0-9]+$/ }
	  }
	 );
    my @datasets = $params{dataset};
    my @se_names = $params{se_name};
    my $id_suffix = $params{id_suffix};

    my $multiple_se = 0;
    if (grep(/^\*$/, @se_names) || scalar @se_names > 1) {
	$multiple_se = 1;
    }

    # Get the number of files at an se
    # If the site has MSS, return the MSS rows only
    my $sql = qq{ select n.name node, n.se_name se_name, ds.name,
		  sum(br.node_files) node_files, sum(b.files) total_files
		      from t_dps_block_replica br
		      join t_adm_node n on n.id = br.node
                 left join t_adm_node m on m.se_name = n.se_name
                                       and m.kind = 'MSS'
		      join t_dps_block b on b.id = br.block
		      join t_dps_dataset ds on ds.id = b.dataset
		      where (m.id is null or n.kind = 'MSS')
                        and WHERE
		      group by n.name, n.se_name, ds.name
		      order by n.name, ds.name
		  };

    my @where;
    my %binds;
    if (grep /^\*$/, @se_names) {
	push @where, "n.se_name is not null";
    } else {
	my ($se_list, %se_binds) = &dbinlist('se_name', @se_names);
	push @where, "n.se_name in ($se_list)";
	$binds{$_} = $se_binds{$_} foreach keys %se_binds;
    }
    my ($ds_list, %ds_binds) = &dbinlist('ds', @datasets);
    push @where, "ds.name in ($ds_list)";
    $binds{$_} = $ds_binds{$_} foreach keys %ds_binds;

    my $where_str = join ' and ', @where;
    $sql =~ s/WHERE/$where_str/m;

    my $sth = &dbexec($$self{DBH}, $sql, %binds);
    my $nrows = 0;
    my $responses = {};
    while (my ($node, $se_name, $dataset, $node_files, $total_files) = $sth->fetchrow()) {
	$nrows++;
	my $id;
	if ($multiple_se) {
	    $id = join ':', 'multiple', $dataset;
	} else {
	    $id = join ':', $se_names[0], $dataset;
	}
	$id .= ':'.$id_suffix if $id_suffix;

	my $ratio = sprintf("%.1f", ($node_files / $total_files) * 100);
	my $color;
	if ($ratio == 0) { $color = 'red'; } 
	elsif ($ratio == 100) { $color = 'green'; } 
	else { $color = 'orange'; }

	my $line = "<div name='phedex_transfer_status' style='color:$color;'>".
	    "$node ($se_name) $node_files / $total_files (${ratio}%)".
	    "</div>";

	$$responses{$id}{$line} = 1;
    }

    if ($nrows) {
	foreach my $id (keys %{$responses}) {
	    print {$$self{CONTENT}}	"<response type='object' id='$id'>";
	    foreach my $line (keys %{$$responses{$id}}) {
		print {$$self{CONTENT}} $line;
	    }
	    print {$$self{CONTENT}} "</response>";
	}
    } else {
	# make fake result sets when there are no results
	# so Valentin's framework doesn't choke...
	foreach my $dataset (@datasets) {
	    my $id;
	    if ($multiple_se) {
		$id = join ':', 'multiple', $dataset;
	    } else {
		$id = join ':', $se_names[0], $dataset;
	    }
	    $id .= ':'.$id_suffix if $id_suffix;
	print {$$self{CONTENT}}	"<response type='object' id='$id'>No results</response>";
	}
    }

}

1;

######################################################################
package Web25::Security::SignUp;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 0, NOLOGIN => 1, TITLE => "Sign-Up" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    my $caller_url = param('caller_url');

    my $sitedb_url = $$self{CONFIG}{SITEDB_URL} || 'blank';
    my $sitedb = "<a href='$sitedb_url'>SiteDB</a>";
    my $gridcert_help_url = $$self{CONFIG}{GRIDCERT_HELP_URL} || 'blank';

    my $dn = $$self{SECMOD}->getBrowserDN();
    my $dn_ok = ($dn && $dn ne '(null)') ? 1 : 0;

    print {$$self{CONTENT}} 
    "<h1>Have You Signed Up?</h1><br/>",
    "<p class='blocktext'>You need to sign up with CMS Web Services in order to log in ",
    "and use privileged features.  Signing up can be done via ",
    "$sitedb.</p>",
    "<p class='blocktext'>Signing up means ensuring that $sitedb has your certificate DN ",
    "(Distinguished Name) and/or hypernews username/password properly ",
    "associated with your identity.</p>",
    "<p class='blocktext'>If you have already signed up with SiteDB, it ",
    "is possible that your certificate or password information is out ",
    "of date there.  In that case go back to $sitedb and update your ",
    "information.</p>",
    "<p>For your information, the DN your browser presents is:</p>",
    ($dn_ok ? "<p>$dn</p>" : "<p><b>No certificate presented by your browser!</b></p>");

    if (!$dn_ok) {
	print {$$self{CONTENT}}
	"<p>For information on obtaining and loading certificates into ",
	"your browser, please visit <a href='$gridcert_help_url'>this ",
	"page</a>";
    }
}

1;

######################################################################
package Web25::Error;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 999, ORDER => 999, NOLOGIN => 1, TITLE => "Error" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  print { $$self{CONTENT} }
    "<center><div class='alert'>",
    $self->{ERROR_MSG},
    "</div></center>";
}

1;

######################################################################
package Web25::Info::Main;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
import Web25::Common;
our $INDEX = { LIST => 1, ORDER => 0, NOLOGIN => 1, TITLE => "Overview" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  no strict "refs";
  foreach my $toc ($self->toc())
  {
    next if ! ${$$toc}{LIST};
    my $type = *{$toc}{PACKAGE};
    print { $$self{CONTENT} }
      (${$$toc}{ORDER} % 3 ? "" : "<p style='clear: left'></p>\n"),
      "<div class='toc'>\n",
      " <h2>", &escapeHTML(${$$toc}{TITLE}), "</h2>\n",
      " <ul>\n";

    my @pages = ();
    my $scope = "${type}::";
    foreach (keys %$scope)
    {
      next if ! /::$/;
      next if ! exists ${$$scope{$_}}{INDEX};
      push(@pages, ${$$scope{$_}}{INDEX});
    }

    print { $$self{CONTENT} }
      map { "  <li>" . &pagelink($self, $_) . "</li>\n" }
      sort { ${$$a}{ORDER} <=> ${$$b}{ORDER} }
      grep (${$$_}{LIST}, @pages);

    print { $$self{CONTENT} } " </ul>\n</div>";
  }
}

1;

######################################################################
package Web25::Info; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 0, TITLE => "Info" }; 1;

package Web25::Activity; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 1, TITLE => "Activity" }; 1;

package Web25::Data; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 2, TITLE => "Data" }; 1;

package Web25::Request; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 3, TITLE => "Requests" }; 1;

package Web25::Components; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 4, TITLE => "Components" }; 1;

package Web25::Reports; use strict; use warnings; use base "Exporter";
our $TOC = { LIST => 1, ORDER => 5, TITLE => "Reports" }; 1;


######################################################################
package Web25::Info::About; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 1, TITLE => "About",
	       LINK => "about.html",
	       LINK_TITLE => "General Information" };
1;

package Web25::Info::Documentation; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Documentation",
	       LINK => "documents.html",
	       LINK_TITLE => "READMEs and Other Documentation" };
1;

package Web25::Info::Presentations; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Presentations",
	       LINK => "presentations.html",
	       LINK_TITLE => "PhEDEx Presentations" };
1;

package Web25::Info::HyperNews; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 4, TITLE => "HyperNews Forum",
	       LINK => "https://hypernews.cern.ch/HyperNews/CMS/get/phedex.html",
	       LINK_TITLE => "Mailing List and HyperNews Forum" };
1;

package Web25::Info::Support; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Support Tracker",
	       LINK => "https://ggus.eu/?mode=ticket_cms",
	       LINK_TITLE => "Support Tracker" };
1;

package Web25::Info::Developers; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Developers",
	       LINK => "developers.html",
	       LINK_TITLE => "Developer info" };
1;

package Web25::Info::Datasvc; use strict; use warnings; use base "Exporter";
our $INDEX = { LIST => 1, ORDER =>7, TITLE => "Data Service",
	       LINK => "datasvc/doc",
	       LINK_TITLE => "Data Service" };
1;

######################################################################
package Web25::Request::Page;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard);
use POSIX qw(strftime);
import Web25::Common;

use PHEDEX::Core::Identity;
use PHEDEX::RequestAllocator::Core;
use PHEDEX::RequestAllocator::SQL;

our @reqstates = (
  { STATE => 0, RANK => 0, LABEL => "Pending approval" },
  { STATE => 2, RANK => 3, LABEL => "Partially refused" },
  { STATE => 3, RANK => 4, LABEL => "Partially approved" },
  { STATE => 4, RANK => 9, LABEL => "Refused" },
  { STATE => 5, RANK => 5, LABEL => "Approved" }
);
our %reqstatenames  = map { ($$_{STATE} => $$_{LABEL}) } @reqstates;
our %reqstatevalues = map { ($$_{LABEL} => $$_{STATE}) } @reqstates;
our %reqactionnames = ( subscribe => 'Transfer Approved',
			nosubscribe => 'Transfer Refused',
			moveconfirm => 'Move Approved',
			nomoveconfirm => 'Move Refused',
			delete => 'Deletion Approved',
			nodelete => 'Deletion Refused' );

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub logClientInfo
{
    my ($self, $user_email) = @_;

    my $auth = $self->{SECMOD}->getAuthnState();
    $auth = $auth eq 'cert' ? 'CERTIFICATE' : 
	$auth eq 'passwd' ? 'PASSWORD' : die "not authenticated in logClientInfo";
        
    # Write information about the Client
    my $id_params = &PHEDEX::Core::Identity::getIdentityFromSecMod( $self, $self->{SECMOD} );
    my $identity = &PHEDEX::Core::Identity::fetchAndSyncIdentity( $self,
								  AUTH_METHOD => $auth,
								  %$id_params );
    my %client_attr;
    $client_attr{"Remote host"} = $ENV{HTTP_X_FORWARDED_FOR};
    $client_attr{"User agent"} = user_agent();
    $client_attr{'User email'} = $user_email if $user_email && $user_email ne $$identity{EMAIL};
    my $client_id = &PHEDEX::Core::Identity::logClientInfo($self,
							   $identity->{ID},
							   %client_attr);
    return $client_id;
}

sub getClientData 
{
    my ($self, $clientid) = @_;
    my $clientinfo = &PHEDEX::Core::Identity::getClientInfo($self, $clientid);
    my $identity = &PHEDEX::Core::Identity::getIdentityFromDB($self, $clientinfo->{IDENTITY});
    return { CONTACT_ATTR => $clientinfo, IDENTITY => $identity };
}

sub formatClientData
{
    my ($self, $data) = @_;
    my @html;
    
    my %nice_names = ('NAME' => 'Name',
		      'DN' => 'Distinguished name',
		      'USERNAME' => 'User name',
		      'EMAIL' => 'E-mail');
    if ( $data->{IDENTITY}->{CERTIFICATE} ) {
	push @html, "<label>Certificate:</label>",
	"<div class='labeled' style='height:100px;overflow:scroll;'><pre>", 
	$data->{IDENTITY}->{CERTIFICATE},
	"</pre></div><br/>";
    }
    foreach my $name (qw(NAME DN USERNAME EMAIL)) {
	push @html, "<label>$nice_names{$name}:</label><span class='labeled'>", 
	    ($data->{IDENTITY}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    foreach my $name (sort keys %{$data->{CONTACT_ATTR}}) {
	next if $name eq 'IDENTITY';
	push @html, "<label>$name:</label><span class='labeled'>", 
	($data->{CONTACT_ATTR}->{$name} or 'Unknown'), "</span><br/>";
    }
    
    return @html;
}

sub getRequestData
{
    my ($self, $rid) = @_;
    $$self{DBH}->{LongReadLen} = 1_000_000;
    $$self{DBH}->{LongTruncOk} = 1;

    my $data = {};
    $data = &dbexec($$self{DBH}, qq{
	select r.id, rt.name type, r.created_by creator_id, r.time_create, rdbs.name dbs, 
	       rc.comments
	  from t_req_request r
          join t_req_type rt on rt.id = r.type
          join t_req_dbs rdbs on rdbs.request = r.id
     left join t_req_comments rc on rc.id = r.comments
	  where r.id = :request }, ':request' => $rid)->fetchrow_hashref();
    
    $$data{CREATOR_DATA} = $self->getClientData($$data{CREATOR_ID});
    
    $$data{NODES} = &dbexec($$self{DBH}, qq{
	select n.name node, n.id node_id,
               case when rn.point = 's' then 'Source Node'
                    when rn.point = 'd' then 'Destination Node'
                    else 'Node' end point,
               rd.decision, rd.decided_by, rd.time_decided, rc.comments
          from t_req_node rn
          join t_adm_node n on n.id = rn.node
     left join t_req_decision rd on rd.request = rn.request and rd.node = rn.node
     left join t_req_comments rc on rc.id = rd.comments
	  where rn.request = :request }, ':request' => $rid)->fetchall_hashref('NODE');

    my ($n, $n_pend, $n_appr, $n_dis) = (0, 0, 0, 0);
    foreach my $node (values %{$$data{NODES}}) {
	$n++;
	if (!$$node{DECISION}) { $n_pend++; }
	elsif ($$node{DECISION} eq 'y') { $n_appr++; }
	elsif ($$node{DECISION} eq 'n') { $n_dis++; }
	$$node{DECIDER_DATA} = $self->getClientData($$node{DECIDED_BY}) if $$node{DECIDED_BY};
    }

    my ($state);
    if    ($n == $n_appr)  { $state = 'Approved'; }
    elsif ($n == $n_dis)   { $state = 'Disapproved'; }
    elsif ($n == $n_pend)  { $state = 'Pending approval'; }
    elsif ($n_appr !=0)    { $state = 'Partially approved'; }
    elsif ($n_dis !=0)     { $state = 'Partially disapproved'; }
    $$data{REQUEST_STATE} = $state;
    $$data{REQUEST_NEEDS_ADMIN} = $n_pend;
 
    my $time_start;
    if ($$data{TYPE} eq 'xfer') {
	$$data{XFER_DATA} = &dbexec($$self{DBH}, qq{
	    select rx.priority, rx.is_custodial, rx.is_move, rx.is_static,
	           rx.is_transient, rx.is_distributed, 
	           g.id user_group_id, g.name user_group, rx.data, rx.time_start, rx.data
	      from t_req_xfer rx
	      left join t_adm_group g on g.id = rx.user_group
	     where rx.request = :request
	 }, ':request' => $rid)->fetchrow_hashref();
        $time_start = $data->{XFER_DATA}{TIME_START};
    } elsif ($$data{TYPE} eq 'delete') {
	$$data{DELETE_DATA} = &dbexec($$self{DBH}, qq{
	    select rd.rm_subscriptions, rd.data
	      from t_req_delete rd
	     where rd.request = :request
	 }, ':request' => $rid)->fetchrow_hashref();
    }

    my $sql = qq{
	select 'DATASET' lvl, rds.name, ds.id, nvl(sum(b.files),0) files, nvl(sum(b.bytes),0) bytes
	  from t_req_dataset rds left join t_dps_dataset ds on ds.id = rds.dataset_id
                                 left join t_dps_block b on b.dataset = ds.id
         where rds.request = :request };
    my %p = ( ':request' => $rid );
    if ( $time_start ) {
      $sql .= qq { and b.time_create >= :time_create };
      $p{':time_create'} = $time_start;
    }
    $sql .= qq {
         group by rds.name, ds.id
        union
        select 'BLOCK' lvl, rb.name, b.id, b.files, b.bytes
          from t_req_block rb left join t_dps_block b on b.id = rb.block_id
         where rb.request = :request
    };
    if ( $time_start ) {
      $sql .= qq { and b.time_create >= :time_create };
      $p{':time_create'} = $time_start;
    }
    $sql .= qq {
        union
        select 'FILE' lvl, rf.name, f.id, 1 files, f.filesize bytes
          from t_req_file rf left join t_dps_file f on f.id = rf.file_id
         where rf.request = :request
     };
     $$data{DATA} =  &dbexec($$self{DBH},$sql, %p)->fetchall_hashref([qw(LVL ID)]);

     my ($total_files, $total_bytes) = (0, 0);
     foreach my $lvl (keys %{$$data{DATA}}) {
 	foreach my $item (values %{$$data{DATA}{$lvl}}) {
	    $total_files += $$item{FILES} || 0;
 	    $total_bytes += $$item{BYTES} || 0;
 	}
     }
     $$data{REQUEST_FILES} = $total_files;
     $$data{REQUEST_BYTES} = $total_bytes;

    return $data;
}

sub getRequestTitle
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	return "Transfer Request : ".$self->getRequestTypeSummary($data);
    } elsif ($$data{TYPE} eq 'delete') {
	return "Deletion Request";
    } else {
	return "Unknown Request";
    }
}

sub getRequestTypeSummary
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my $kind = $$data{XFER_DATA}{IS_MOVE} eq 'y' ? 'Move' : 'Replication';
	my %priority_names = (0 => 'High', 1 => 'Normal', 2 => 'Low');
	my $priority = $priority_names{ $$data{XFER_DATA}{PRIORITY} };
	my $custodial = $$data{XFER_DATA}{IS_CUSTODIAL} eq 'y' ? ' Custodial ' : ' ';
	return "$priority Priority$custodial$kind";
    } elsif ($$data{TYPE} eq 'delete') {
	return $$data{DELETE_DATA}{RM_SUBSCRIPTIONS} eq 'y' ? 'Deletion' : 'Retransfer';
    } else {
	return undef;
    }
}

sub printRequest
{
    my ($self, $rid, @auth_nodes) = @_;

    my $data = $self->getRequestData($rid);

    print { $$self{CONTENT} }
    # Request box
    "<div class='nice paramblock lev1 Request::View::Id' id='Request::View::Id::",$rid,"'>",
    "<h1>Request $rid : ", $self->getRequestTitle($data), "</h1>",
    # Requestor hideaway box
    "<label>Requestor:</label>", "<div class='labeled'>",
    "<a href='#' onclick='return hideshow(\"creator$rid\")'>",
    ($$data{CREATOR_DATA}{IDENTITY}{NAME} or 'Unknown'), 
    ( $$data{COMMENTS} ? " (comments)" : ''), "</a>",
    " at ", &formatTime($$data{TIME_CREATE}, 'stamp'), "<br/>",
    "<div id='creator$rid' class='hideaway' style='display:none;'>";
    
    #Creation comments
    if ($$data{COMMENTS}) {
	print { $$self{CONTENT} }
	"<label>Comments:</label>", "<div class='labeled comment'>",
	&escapeHTML($$data{COMMENTS}), "</div><br/>";
    }

    print { $$self{CONTENT} }
    $self->formatClientData($$data{CREATOR_DATA}),
    "</div></div><br/>";

    # Request state
    print { $$self{CONTENT} }
    "<label>State:</label>", "<span class='labeled'>", 
    $$data{REQUEST_STATE}, "</span><br/>";

    my ($time_start_label,$time_start);
    if ($$data{TYPE} eq 'xfer') {
	print { $$self{CONTENT} }
	"<label>Group:</label>", "<span class='labeled'>", 
	($$data{XFER_DATA}{USER_GROUP} || 'undefined'), "</span><br/>";
        $time_start = $data->{XFER_DATA}{TIME_START};
	if ( $time_start ) {
          $time_start_label = scalar gmtime($time_start) . ' UTC';
        } else {
          $time_start_label = 'all data (no start-time specified)';
        }
	print { $$self{CONTENT} }
	"<label>Data Injected After:</label>", "<span class='labeled'>",$time_start_label, "</span><br/>";
    }

    # Data hideaway box
    my $data_label;
    if ($$data{REQUEST_FILES} == 0 && $$data{REQUEST_BYTES} == 0) {
	$data_label = "No longer available in TMDB";
	if ($time_start) { $data_label = "No data available since specified start-time"; }
    } else {
	$data_label = "$$data{REQUEST_FILES} files, ". &format_size($$data{REQUEST_BYTES});
    }

    print { $$self{CONTENT} }
    "<label>Data:</label>", "<div class='labeled'>",
    "<a href='#' onclick='return hideshow(\"data$rid\")'>",
    $data_label, "</a><br/>",
    # Data details (hidden at first)
    "<div id='data$rid' class='hideaway' style='display:none;'>",
    "<label class='inline'>DBS URL:</label>", $$data{DBS}, "<br/>";

    my $data_items = $data->{XFER_DATA}{DATA} || $data->{DELETE_DATA}{DATA};
    $data_items =~ s%\n% %g;
    $data_items =~ s% +%<br />%g;
    print { $$self{CONTENT} } "<div><label class='inline'>Original request string:</label><br/>",
			        "<div class='labeled databox tinytext'>$data_items</div>",
			      '</div><br/>';
    print { $$self{CONTENT} } "<label class='inline'>Currently matched data:</label>";
    $self->printDataTable($data);
    print { $$self{CONTENT} } "</div></div><br/>";

    # Nodes
    my $nodes = {}; # point => [ array of node objects ]
    my $admin = 0;
    my $reEval = 0;
    foreach my $node (sort keys %{$$data{NODES}}) {
	my $o = $$data{NODES}{$node};
	$admin = 1 if (!$$o{DECISION} && grep($$o{NODE} eq $_, @auth_nodes));
	$reEval = ( $$o{DECISION} &&
		    $$o{DECISION} eq 'y' &&
		    $$o{POINT} eq 'Destination Node' &&
		    $$data{TYPE} eq 'xfer' &&
		    $$data{XFER_DATA}{IS_STATIC} eq 'n' &&
		    $$data{XFER_DATA}{DATA} =~ /\*/ ? 1 : 0);
	$admin = 1 if ($reEval && grep($$o{NODE} eq $_, @auth_nodes));
	$$nodes{ $$o{POINT} } ||= [];
	push @{ $$nodes{$$o{POINT}} }, $o;
    }

    my $approve_url = $self->myurl('page' => 'Request::Admin');
    print { $$self{CONTENT} } "<form method='post' action='$approve_url'>" if $admin;
    foreach my $point ( sort keys %$nodes ) {
	print { $$self{CONTENT} }
	"<label>${point}s:</label>", "<div class='labeled'>";
	foreach my $o (@{$$nodes{$point}}) {
	    my $node_admin = ($admin && grep($$o{NODE} eq $_, @auth_nodes) ? 1 : 0);
	    my $decision_text = '';

	    if (!$$o{DECISION} && $node_admin) {
		my @controls;
		my %labels = ('approve' => 'approve', 'disapprove' => 'disapprove', 'null' => 'do nothing');
		foreach my $action (qw(approve disapprove null)) {
		    my $sel = $action eq 'null' ? "checked='checked'" : '';
		    push @controls, "<input $sel name='admin-$$o{NODE}' value='$action' type='radio'/> ".
			$labels{$action};
		}
		$decision_text = "<span class='warn'><b>admin</b></span> : " . join(' ', @controls);
	    } elsif (!$$o{DECISION}) {
		$decision_text = "<span class='warn'>pending approval</span>";
	    } else {
		my $decider_ref = "nodedec$rid-".$$o{NODE_ID};
		my @controls;
		if ($reEval && $$o{DECISION} eq 'y') {
		    # user can disapprove after the fact if the request is a re-evaluate candidate
		    push @controls, "<input name='admin-$$o{NODE}' value='stopeval' type='checkbox'/> stop evaluating"
			if $reEval;
		}

		$decision_text = 
		    join('', ($$o{DECISION} eq 'y' ? "<span class='good'>approved</span> by " 
			      : "<span class='bad'>disapproved</span> by "),
			 "<a href='#' onclick='return hideshow(\"$decider_ref\")'>",
			 $$o{DECIDER_DATA}{IDENTITY}{NAME},
			 ( $$o{COMMENTS} ? " (comments)" : ''),
			 "</a></span>",
			 ' at ', &formatTime($$o{TIME_DECIDED}, 'stamp'),
			 # Request change controls
			 ( $node_admin && @controls ? 
			    ("  :  ", @controls)
			   : ''),
			 "<div id='$decider_ref' class='hideaway' style='display:none;'>",
			 # Creation comments
			 ( $$o{COMMENTS} ? 
			   "<label>Comments:</label><div class='labeled comment'>$$o{COMMENTS}</div><br/>" : ''),
			 $self->formatClientData($$o{DECIDER_DATA}),
			 "</div>");
	    }
	    print { $$self{CONTENT} } "$$o{NODE} : $decision_text<br/>";
	}
	print { $$self{CONTENT} } "</div><br/>";
    }
    if ($admin) {
	print { $$self{CONTENT} }
	"<label>Comment:<br/><span class='note'>(Optional)</span></label>",
	textarea(-name=>'comments', -rows=>5, -cols=>60, -class=>'labeled'), "<br/>",
	"<label>&nbsp;</label>",
	hidden('admin_request', $rid),
	submit(-value=>"Submit Changes for \#$rid", -class=>'labeled'), "<br/>",
	"</form>";
    }
 
    # Request-specific data
    print { $$self{CONTENT} }
    "<label>Details:</label>", "<span class='labeled'>",
    "<a href='#' onclick='return hideshow(\"details$rid\")'>",
    $self->getRequestTypeSummary($data), "</a></span><br/>",
    "<div id='details$rid' class='hideaway' style='display:none;'>";
    $self->printRequestSpecific($data);
    print { $$self{CONTENT} } "</div>";

    # Request infomation link, if anything has been approved yet
    if ( $$data{REQUEST_STATE} =~ /approved/i ) {
	print { $$self{CONTENT} }
	"<label>Link:</label>", "<span class='labeled'>",
	$self->getRequestSpecificLink($data),
	"</span><br/>";
    }

    print { $$self{CONTENT} } "</div>";
}


sub printDataTable
{
    my ($self, $data) = @_;
    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(LVL NAME FILES BYTES)]);
    $table->set_tablehead({LVL => 'Data Level', 
			   NAME => 'Data Item',
			   FILES => 'Files',
			   BYTES => 'Size'});
    $table->set_dataformats({ LVL => sub { ucfirst lc $_[0] },
			      BYTES => sub { &format_size($_[0], 1, 2, 'G') }});
    $table->set_statcols({FILES => 'SUM', BYTES => 'SUM'});
    $table->start();
    $table->head();
     foreach my $lvl (keys %{$$data{DATA}}) {
 	foreach my $item (values %{$$data{DATA}{$lvl}}) {
	    $table->row($item);
 	}
     }
    $table->finish();
}



sub printRequestSpecific
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my $spec = $$data{XFER_DATA};
	my %labels = ( PRIORITY => 'Priority',
		       IS_CUSTODIAL => 'Custodial',
		       IS_MOVE => 'Move',
		       IS_STATIC => 'Static',
		       IS_TRANSIENT => 'Transient',
		       IS_DISTRIBUTED => 'Distributed',
		       DATA => 'Requested Data' );
	my %priority_names = (0 => 'High', 1 => 'Normal', 2 => 'Low');
	print { $$self{CONTENT} }
	"<label>$labels{PRIORITY}:</label><span class='labeled'>$priority_names{$$spec{PRIORITY}}</span><br/>";
	foreach my $key (qw(IS_CUSTODIAL IS_MOVE IS_STATIC)) { # TODO:  omitted keys have no function yet...
	    print { $$self{CONTENT} }
	    "<label>$labels{$key}:</label><span class='labeled'>", &yesno($$spec{$key}), "</span><br/>";
	}
	$$spec{DATA} =~ s/ +/<br\/>/g;
    } elsif ($$data{TYPE} eq 'delete') {
	my $spec = $$data{DELETE_DATA};
	my %labels = ( RM_SUBSCRIPTIONS => 'Remove Subscriptions?',
		       DATA => 'Requested Data' );
	foreach my $key (qw(RM_SUBSCRIPTIONS)) { # TODO:  omitted keys have no function yet...
	    print { $$self{CONTENT} }
	    "<label>$labels{$key}:</label><span class='labeled'>", &yesno($$spec{$key}), "</span><br/>";
	}
    } else {
	print { $$self{CONTENT} } 'N/A';
    }
}

sub getRequestSpecificLink
{
    my ($self, $data) = @_;
    if ($$data{TYPE} eq 'xfer') {
	my @nodes = map { $$_{NODE_ID} } grep $$_{POINT} eq 'Destination Node', values %{$$data{NODES}};
	my $url = $self->myurl(page =>'Data::Subscriptions',
			       reqfilter => $$data{ID},
			       node => \@nodes);
	return ("<a href='$url'>Subscriptions Page</a>");
    } elsif ($$data{TYPE} eq 'delete') {
	my $url = $self->myurl(page =>'Activity::Deletions',
			       reqfilter => $$data{ID},
			       node => '.*');
	return ("<a href='$url'>Deletions Page</a>");
    } else {
	return ("N/A");
    }
}

1;

######################################################################
package Web25::Request::Main;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 0, TITLE => "Overview",
	       LINK_TITLE => "Quick overview of transfer requests",
	       SECURE => 0 };
use CGI qw(:standard);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my ($n_req) = &dbexec($$self{DBH}, qq{
      select count(*) n_requests
	from t_req_request
    })->fetchrow();

  print {$$self{CONTENT}} "<h1>Requests Overview</h1>";
  print {$$self{CONTENT}} "<p>There are <b>$n_req</b> Requests.</p>";

  my $q = &dbexec($$self{DBH}, qq{
     select n.name node, rt.name type, nvl(rd.decision,'PEND'), count(*) n_req
       from t_req_request r
       join t_req_type rt on rt.id = r.type
       join t_req_node rn on rn.request = r.id
       join t_adm_node n on n.id = rn.node
  left join t_req_decision rd on rd.request = rn.request
                             and rd.node = rn.node
  group by n.name, rt.name, nvl(rd.decision,'PEND')
  order by n.name
});

  print {$$self{CONTENT}}
  "<h2>Overview By Node</h2>",
  "<p><b>Legend:</b>  ", 
  "xfer = Transfer Request, ",
  "del = Delete Request, ",
  "pend = Pending Approval, ",
  "appr = Approved, ",
  "dis = Disapproved</p>";

  my $overview = {};
  while (my ($node, $type, $decision, $n_req) = $q->fetchrow()) {
   #   print {$$self{CONTENT}} "<p>$node $type $decision $n_req</p>";
      $$overview{$node}{$type}{$decision} = $n_req;
  }

  my %dec_switch = ('y' => 'appr',
		    'n' => 'dis',
		    'PEND' => 'pend');
  my @dec_order = qw(PEND y n);
  my $n_cols = 4;
  my $col = 0;
  print {$$self{CONTENT}} "<table class='data'>";
  foreach my $node (sort keys %{$overview}) {
      print {$$self{CONTENT}} "<tr>" if $col == 0;
      print {$$self{CONTENT}} "<td style='padding:1em;'><center><b>$node</b></center>";
      foreach my $type (sort keys %{$$overview{$node}}) {
	  my $o = $$overview{$node}{$type};
	  print {$$self{CONTENT}} "<b>$type:</b>  ";
	  my @decisions;
	  foreach my $dec (@dec_order) {
	      my $n = $$o{$dec} || 0;
	      my $state = $dec_switch{$dec};
	      my $url = $self->myurl('page' => 'Request::View',
				     'nodes' => $node,
				     'type' => $type,
				     'state' => $state);
	      my $link = "<a href='$url'>$n</a>";
	      push @decisions, "$link $state";
	  }
	  print {$$self{CONTENT}} 
	  join(', ', @decisions), "<br/>";
      }
      print {$$self{CONTENT}} "</td>";
      if ($col == $n_cols-1) {
	  print {$$self{CONTENT}} "</tr>";
	  $col = 0;
      } else {
	  $col++;
      }
  }

  if ($col != $n_cols-1) {
      while ($col < $n_cols-1) {
	  print {$$self{CONTENT}} "<td>&nbsp;</td>";
	  $col++;
      }
      print {$$self{CONTENT}} "</tr>";
  }
      
  print {$$self{CONTENT}} "</table>";

}

1;

######################################################################
package Web25::Request::View;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 1, ORDER => 2, TITLE => "View/Manage Requests",
	       LINK_TITLE => "Browse requests",
	       SECURE => 0 };
use CGI qw(:standard unescape);
import Web25::Common;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(request type nodes state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Request::View" &&
			    $args{"page"} ne "Request::Admin"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;

    my @types = qw(any xfer delete);
    my %types = ( any => 'any type', xfer => 'transfer', delete => 'deletion' );
    my @states = qw(any pend appr dis);
    my %states = ( any => 'any requests', pend => 'pending approval', appr => 'approved', dis => 'disapproved');

    my %params = $self->validate_all
	( allow => [qw(page_num request type nodes state)],
	  spec => {
	      page_num => { using => 'pos_int' },
	      request  => { using => 'pos_int_list' },
	      type     => { allowing => \@types },
	      nodes    => { using => 'regex' },
	      state    => { allowing => \@states },
	  }
	 );
# Explicit checking of arguments
  foreach ( qw( nodes ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }

    my $request = $params{request};
    my $type    = $params{type};
    my $nodes   = $params{nodes};
    my $state   = $params{state};

    my $viewurl = $self->myurl();
    print {$$self{CONTENT}}
    "<div id='xRequest::View'></div>",
    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View request \#s </label>",
    textfield(-name=>'request', -default=>$request, -class=>'labeled'),
    "<label class='inline'>",&help("[?]", "Request Numbers", 
	  "Input a space separated list of request numbers to display"), "</label>",
    submit(-value=>'Submit', -class=>'labeled'), 
    "</form><br clear='all'/>",

    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View </label>",
    popup_menu(-name=>'type', -values=>\@types,
	       -labels=>\%types,
	       -class=>'labeled'),
    "<label class='inline'> requests for nodes </label>",
    textfield(-name=>'nodes', -default=>$nodes, -class=>'labeled'),
    popup_menu(-name=>'state', -values=>\@states,
	       -labels=>\%states,
	       -class=>'labeled'),
    submit(-value=>'Submit', -class=>'labeled'), "</form><br clear='all'/>";


    my @auth_nodes;
    if ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	@auth_nodes = sort $self->fetch_nodes(web_user_auth => 'Data Manager');	
    } elsif (!$$self{SECMOD}->isAuthenticated() ||
	     $$self{SECMOD}->isPasswdAuthenticated()) {
	$self->auth_help_popup('approve requests' => ['cert', 'Data Manager', 'Admin']);
    }

    my @where;
    my %binds;

    if ($request) {
	my @requests = grep(/^\d+$/, split(/\s*,*\s+/, $request));
	my ($req_list, %req_binds) = &dbinlist('request', @requests);
	$binds{$_} = $req_binds{$_} foreach keys %req_binds;
	push @where, "r.id in ($req_list)";
    }

    if ($type && $type ne 'any') {
	push @where, 'rt.name = :type';
	$binds{':type'} = $type;
    }

    if ($nodes) {
	my @nodes;
	my %all_nodes = $self->fetch_nodes(with_ids => 1);
	foreach my $filter (split /\s+/, $nodes) {
	    push @nodes, grep(/$filter/, keys %all_nodes);
	}
	my ($node_list, %node_binds) = &dbinlist('node', @all_nodes{@nodes});
	$binds{$_} = $node_binds{$_} foreach keys %node_binds;
	push @where, "rn.node in ($node_list)" if %node_binds;
    }
    
    if ($state) {
	if    ($state eq 'pend') { push @where, "rd.decision is null"; }
	elsif ($state eq 'appr') { push @where, "rd.decision = 'y'"; }
	elsif ($state eq 'dis')  { push @where, "rd.decision = 'n'"; }
    }

    my $where_str = '';
    $where_str = 'where '.join(' and ', @where) if @where;
    
    my $sql = qq{
      select distinct r.id, r.time_create
      from t_req_request r
      join t_req_type rt on rt.id = r.type
      join t_req_node rn on rn.request = r.id
      left join t_req_decision rd on rd.request = r.id
                                 and rd.node = rn.node
      $where_str
      order by r.time_create desc
    };

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, \%binds,  10);
    my $n_requests = $pager->get_total_results();

    if (! $n_requests) {
	print { $$self{CONTENT} } "<p>No requests to show.</p>";
	return;
    }

    print {$$self{CONTENT}} $pager->pager();
    my $qreq = $pager->paged_result();
    while (my ($rid) = $qreq->fetchrow()) {
	$self->printRequest($rid, @auth_nodes);
    }
    print {$$self{CONTENT}} $pager->pager();

}

1;

######################################################################
package Web25::Request::CreateTools;
use strict; use warnings;
use base "Exporter";
import Web25::Common;
use CGI qw(:standard);
use Mail::RFC822::Address 'validlist';

our @EXPORT = qw(get_request_nodes
                 create_check_type
		 create_check_access
		 create_check_identity
		 create_check_email
		 create_check_comments
		 create_check_dbs
		 create_check_data
		 create_check_nodes
		 create_check_options
);

sub get_request_nodes
{
    my ($self) = shift @_;
    my %nodes = $self->fetch_nodes(with_ids=>1);
    if ($$self{DBID} eq 'prod') {
	foreach my $node (keys %nodes) {
	    delete $nodes{$node} if ($node =~ /(.*)_(Buffer|Stage)$/ && exists $nodes{"$1_MSS"});
	}
    }
    return sort keys %nodes;
}

sub create_check_type
{
    my ($self, $bad, $type) = @_;
    unless (grep $type eq $_, qw(xfer delete)) {
	alert($self, "Invalid request type.");
	$$bad = 1;
	return undef;
    }
    return $type;
}

sub create_check_access
{
  my ($self, $bad) = @_;
  return if $$bad;

  if (request_method() ne 'POST')
  {
    alert($self, "This form can only be accessed with 'POST' method.");
    $$bad = 1;
  }
}

sub create_check_identity
{
  my ($self, $bad) = @_;
  return if $$bad;

  # Make sure this page can be used
  if (! $$self{SECMOD}->isAuthenticated() || ! $$self{SECMOD}->isKnownUser()) {
      $self->auth_help_warning('create a transfer request' => ['anyauth']);
      $$bad = 1;
      return;
  }
}

sub create_check_email
{
  my ($self, $bad, $email) = @_;
  return undef if $$bad;

  if (! $email)
  {
    alert($self, "No requestor e-mail, please supply one.");
    $$bad = 1;
    return undef;
  }

  my ($nrvalidmails, @emails) = validlist ($email);
  if ($email ne '' && ! $nrvalidmails)
  {
    alert($self, "Requestor e-mail &ldquo;@{[&escapeHTML($email)]}&rdquo; is",
	  " not a valid RFC822 e-mail address or address list.");
    $$bad = 1;
  }

    return $$bad ? undef : $email;
}

sub create_check_comments
{
  my ($self, $bad, $comments) = @_;
  return undef if $$bad;
  return $comments;
}

sub create_check_dbs
{
  my ($self, $bad, $dbs) = @_;
  return undef if $$bad;
  if (! $dbs)
  {
    alert($self, "No DBS selected, please choose a value.");
    $$bad = 1;
    return undef;
  }

  if ($dbs !~ m|^[-=+_:/?&;.a-zA-Z0-9]+$|)
  {
    alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	  " contains unsafe characters.");
    $$bad = 1;
  }

  my $SAFE_HOST = "[-A-Za-z0-9_+.]+";
  my $SAFE_PATH = "[-A-Za-z0-9_+.:/&%;]*";
  if ($dbs !~ m,^https?://($SAFE_HOST)(:\d+)?/($SAFE_PATH)\?.*instance=$SAFE_PATH$,)
  {
      my @dbses = $self->fetch_dbses();
      if (! grep($_ eq $dbs, @dbses))
    {
      alert($self, "The DBS contact &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " is not a URL for a DBS service.  Please use a URL of",
	    " the form http://server/path?instance=name.");
      $$bad = 1;
    }
  }
  else
  {
    my $hostname = $1;
    my ($name,$aliases,$addrtype,$length,@addrs)
      = CORE::gethostbyname($hostname);
    if (! $name)
    {
      alert($self, "The host name of the DBS service, &ldquo;",
	    &escapeHTML($hostname), "&rdquo;, did not resolve.",
	    " Please make sure the host is accessible.");
      $$bad = 1;
    }

    my $info = qx(wget -qO- '$dbs;api=listPrimaryDatasets;pattern=/zilch');
    if (! $info || $info !~ /<dbs>/s)
    {
      alert($self, "The DBS contact, &ldquo;", &escapeHTML($dbs), "&rdquo;",
	    " does not respond to aliveness check.  Please make sure",
	    " the contact URL points to a correct service.");
      $$bad = 1;
    }
  }

  return $$bad ? undef : $dbs;
}

sub create_check_data
{
  my ($self, $bad, $data) = @_;
  return undef if $$bad;

  my %userdata = $self->parse_userdata($data);
  if (! %userdata) {
    alert($self, "No data specified.");
    $$bad = 1;
  }

  foreach my $data (keys %userdata) {
      if (! $userdata{$data} ) {
	  $self->alert("The data pattern &ldquo;@{[&escapeHTML($data)]}&rdquo;",
		       " does not match pattern of type /PRIMARY/TIER/DATASET or /PRIMARY/DATASET#BLOCK.");
	  $$bad = 1;
      }
  }

  return $$bad ? undef : keys %userdata;
}

sub create_check_nodes
{
  my ($self, $bad, @nodes) = @_;
  return undef if $$bad;

  if (! @nodes)
  {
    alert($self, "No nodes selected, please select some.");
    $$bad = 1;
    return undef;
  }

  my @possible_nodes = $self->get_request_nodes();

  foreach my $node (@nodes)
  {
    if (! grep ($_ eq $node, @possible_nodes))
    {
      alert($self, "Node name &ldquo;@{[&escapeHTML($node)]}&rdquo;",
	    " is not known to PhEDEx.");
      $$bad = 1;
  }
}

return $$bad ? undef : sort @nodes;
}

sub create_check_options
{
  my ($self, $bad, $type) = @_;
  return undef if $$bad;

  my $opts = {};

  my %groups = $self->fetch_groups(with_ids=>1);
  my @possible_groups = ('undefined', keys %groups);

  if ($type eq 'xfer') {
      foreach ('is_move', 'is_static', 'is_custodial') {
	  if (!defined param($_) || param($_) !~ /^[yn]$/) {
	      $self->alert("Option '$_' missing or illegal value");
	      $$bad = 1;
	      return ();
	  }
      }
  
      if (!defined param('priority') || param('priority') !~ /^[012]$/) {
	  $self->alert("Option 'priority' missing or illegal value");
	  $$bad = 1;
	  return ();
      }
      
      if (!defined param('group') || ! grep $_ eq param('group'), @possible_groups) {
	  $self->alert("Option 'group' is missing or illegal value");
	  $$bad = 1;
	  return ();
      }

      return ( 'is_move' => param('is_move'),
	       'is_static' => param('is_static'),
	       'priority' => param('priority'),
	       'is_custodial' => param('is_custodial'),
	       'user_group' => param('group')
	       );
  } elsif ($type eq 'delete') {
      foreach ('rm_subscriptions') {
	  if (!defined param($_) || param($_) !~ /^[yn]$/) {
	      $self->alert("Option '$_' missing or illegal value");
	      $$bad = 1;
	      return ();
	  }
      }
      return ('rm_subscriptions' => param('rm_subscriptions') );
  } else {
      $self->alert("Invalid request type '$type'");
      $$bad = 1;
      return ();
  }
}

1;

######################################################################
package Web25::Request::Create;
use strict; use warnings;
use base "Web25::Request::Page";
import Web25::Request::CreateTools;
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Create Request",
	       LINK_TITLE => "Create a new request",
	       SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $bad = 0;

  &create_check_identity($self, \$bad);
  return if $bad;

  print { $$self{CONTENT} } "<div id='Request::Create'></div>";
}

1;

######################################################################
package Web25::Request::Admin;
use strict; use warnings;
use base "Web25::Request::Page";
our $INDEX = { LIST => 0, ORDER => 100, TITLE => "Administer Request",
	       LINK_TITLE => "Administer Requests",
	       SECURE => 1 };
use CGI qw(:standard unescape);
use POSIX qw(strftime);
import Web25::Common;
use PHEDEX::Web::API::UpdateRequest;

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(request type nodes state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Request::View" &&
			    $args{"page"} ne "Request::Admin"));

  # If argsonly is set, do not add the saved parameters
  return $self->SUPER::myurl(%args) if delete $args{argsonly};

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
    my ($self) = @_;
    
    # Check access method
    if (request_method() ne 'POST') {
	$self->alert("This form can only be accessed with the POST method");
	return;
    }

    # Check authentication and authorization
    unless ($$self{SECMOD}->isCertAuthenticated() &&
	    ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	     $$self{SECMOD}->hasRole('Data Manager'))) {
	$self->alert("This form may only be accessed by Data Managers with certificate authentication.");
	return;
    }
    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'Data Manager', with_ids => 1);

    my %node_actions;
    foreach my $key (grep /^admin-/, param()) {
	my $node = $key;
	$node =~ s/^admin-//;
	unless (grep($node eq $_, keys %auth_nodes)) {
	    $self->alert("You don't have permission to approve requests for $node");
	    return;
	}
	my $action = param($key);
	unless (grep $action eq $_, qw(approve disapprove null stopeval)) {
	    $self->alert("Invalid action '$action' for node '$node'");
	    return;
	}
	$node_actions{$node} = $action;
    }

    # Check parameters
    my $rid = param('admin_request');

    my $comments = unescape(param('comments'));
    my $now = time ();

    unless ($rid && %node_actions) {
	$self->alert("Missing parameters");
	return;
    }

    # Go to work
    my $data = $self->getRequestData($rid);

    # Check that the request has some data
    if ( ! (keys %{$$data{DATA}{DATASET}} || keys %{$$data{DATA}{BLOCK}}) ) {
      if ( $data->{XFER_DATA} && $data->{XFER_DATA}{TIME_START} ) {
#	$self->alert("No data injected since the start-time you specified (",
#		     strftime ("%Y-%m-%d %H:%M:%S GMT", gmtime($data->{XFER_DATA}{TIME_START})),
#		     "). There may be data injected in the future, in which case you would get it if this request is approved");
      } else {
	$self->alert("Request has no data");
	return;
      }
    }

    # Check that each of the nodes is part of this request
    foreach my $node (keys %node_actions) {
	if (!exists $$data{NODES}{$node}) {
	    $self->alert("Node $node isn't part of request \#$rid");
	    return;
	} elsif (defined $$data{NODES}{$node}{DECISION} && $node_actions{$node} ne 'stopeval') {
	    $self->alert("Request \#$rid has already been adminned for ${node}!");
	    return;
	}
    }

    my $client_id = $self->logClientInfo();
    my $comments_id;

    my $ok = 1;
    my $changes = 0;
    my @results;
    foreach my $node (sort keys %node_actions) {
	my $action = $node_actions{$node};
	my $node_id = $auth_nodes{$node};
	my $node_obj = $$data{NODES}{$node};

	if ($action eq 'null') {
	    push @results, "No action taken for $node";
	} elsif ($action eq 'disapprove') {
	    $ok &&= $self->disapprove($data, $node_obj, $now, $rid, $comments);
	    push @results, "Disapproved request \#$rid for $node";
	    $changes++;
	} elsif ($action eq 'approve') {
	    $ok &&= $self->approve($data, $node_obj, $now, $rid, $comments);
	    push @results, "Approved request \#$rid for $node";
	    $changes++;
	} elsif ($action eq 'stopeval') {
	    $ok &&= $self->markRequestUndone($rid, $node_id);
	    $ok &&= $self->markRequestDone($rid, $node_id, 'n', $client_id, $now, $comments_id);
	    push @results, "Disapproved request \#$rid for $node to stop request re-evaluation";
	    $changes++;
	}
    }

    if ($ok) {
        if ( $changes ) {
          $$self{DBH}->commit();
          $self->send_request_update_email($rid, \%node_actions, $comments);
          print {$$self{CONTENT}} 
          "<h1>Request Updated</h1>",
          "<p>", join('<br/>', @results), "</p>",
          "<p class='blocktext'>Your changes to request \#$rid ",
          "have been applied and an update email was sent to the ",
          "requestor as well as the Data Managers/Site Admins of the ",
          "relevant sites.</p>";
        } else {
          print {$$self{CONTENT}} 
          "<h1>No changes made!</h1>",
          "<p>No sites were approved or disapproved in this update, therefore ",
          "no action was taken, and no email will be sent.</p>",
          "<p>You need to actually approve or disapprove a request for at least one site ",
          "before any action will be recorded in the database</p>";
        }
    } else {
	$$self{DBH}->rollback();
	print {$$self{CONTENT}} "<h1>Error</h1>";
	$self->alert("Problem writing request, transaction rolled back.  ",
		     "Please report this problem to the PhEDEx administrators");
    }
    
    $self->printRequest($rid);

    my $viewurl = $self->myurl(page => "Request::View");
    print {$$self{CONTENT}} "<p><a href='$viewurl'>View requests</a></p>";
}

sub disapprove
{
  my ($self, $data, $node_obj, $time, $rid, $comments) = @_;
  my %h = (
	    request  => $rid,
	    node     => $node_obj->{NODE},
	    decision => 'disapprove'
	  );
  if ( $comments ) { $h{comments} = $comments; }
  my ($error,$message);
  eval {
    $message = PHEDEX::Web::API::UpdateRequest::invoke($self,%h);
  };
  if ( $@ ) { $message = $@; }
  if ( $message && ref($message) ne 'HASH' ) {
    ($error,$message) = PHEDEX::Web::Util::decode_http_error($@);
    die $message;
  }
  return 1;
}

sub approve
{
  my ($self, $data, $node_obj, $time, $rid, $comments) = @_;
  my %h = (
	    request  => $rid,
	    node     => $node_obj->{NODE},
	    decision => 'approve'
	  );
  if ( $comments ) { $h{comments} = $comments; }
  my ($error,$message);
  eval {
    $message = PHEDEX::Web::API::UpdateRequest::invoke($self,%h);
  };
  if ( $@ ) { $message = $@; warn "UpdateRequest: $@\n"; }
  if ( $message && ref($message) ne 'HASH' ) {
    ($error,$message) = PHEDEX::Web::Util::decode_http_error($@);
    die $message;
  }
  return 1;
}

sub unsubscribe
{
  my ($self, $rid, $node_id, $time) = @_;
  &PHEDEX::RequestAllocator::Core::deleteSubscriptionsForRequest($self, $rid, $node_id, $time);
  return 1;
}

sub delete
{
    my ($self, $rid, $node_id, $time) = @_;

    &PHEDEX::RequestAllocator::Core::addDeletionsForRequest($self, $rid, $node_id, $time);

    return 1;
}

sub markRequestDone
{
    my ($self, $rid, $node_id, $decision, $client_id, $time, $comments_id) = @_;

    my $rv = &PHEDEX::RequestAllocator::Core::setRequestDecision($self, $rid, $node_id, $decision,
								 $client_id, $time, $comments_id);
    
    return $rv;
}

sub markRequestUndone
{
    my ($self, $rid, $node_id) = @_;

    my $rv = &PHEDEX::RequestAllocator::Core::unsetRequestDecision($self, $rid, $node_id);

    return $rv;
}


sub send_request_update_email
{
    my ($self, $rid, $node_actions, $comments) = @_;

    my $data = $self->getRequestData($rid);

    # Build list action descriptions
    my $action_desc = '';
    my ($site,$node);
    foreach $node (keys %$node_actions) {
	my $action = $$node_actions{$node};
	if ($action eq 'null') {
	    next;
	} elsif ($action eq 'disapprove' || $action eq 'stopeval') {
	    $action_desc .= "$node => Disapproved";
	} elsif ($action eq 'approve') {
	    $action_desc .= "$node => Approved";
	}
	$action_desc .= "\n";
    }

    # A list of nodes that have been acted on
    my @action_nodes = sort grep($$node_actions{$_} ne 'null', keys %$node_actions);

    # Get a list of the sites involved in this request update
    my %node_sites = $$self{SECMOD}->getPhedexNodeToSiteMap();
    my %sites;  # for unique list
    foreach $node (@action_nodes) {
	$sites{ $node_sites{$node} } = 1 if exists $node_sites{$node};
    }
    
    # Get the list of Data Managers affected by this request
    my @data_managers;
    foreach $site (keys %sites) {
	push @data_managers, $$self{SECMOD}->getUsersWithRoleForSite('Data Manager', $site);
    }

    # Get the list of Site Admins affected by this request
    my @site_admins;
    foreach $site (keys %sites) {
	push @site_admins, $$self{SECMOD}->getUsersWithRoleForSite('Site Admin', $site);
    }

    my $creator_name = $$data{CREATOR_DATA}{IDENTITY}{NAME};
    my $creator_email = $$data{CREATOR_DATA}{IDENTITY}{EMAIL};
    my $detail_url = $self->myurl(page => 'Request::View',
				  argsonly => 1,
				  request => $rid,
				  fullurl => 1);
    my $admin_email = $$self{SECMOD}->getEmail();
    my $msg_comments = ($comments ? "\nThe person who handled this had the following comments:\n\n\"$comments\"\n" 
			: '');
    my @cc = map { $$_{EMAIL} } @data_managers, @site_admins;
    my $nodes_str = join(', ', sort grep($$node_actions{$_} ne 'null', keys %$node_actions));
    my $newstate = $$data{REQUEST_STATE};

    my $message=<<ENDEMAIL;
Dear $creator_name,

Your request \#$rid has been acted on by $$self{USER_NAME} for $nodes_str.  The actions taken were:

$action_desc
$msg_comments
This request is now $newstate.

To review details of the request, please go to:

$detail_url

To inquire further about this request, you may reply to this email.

This message has also been CCed to the Data Managers and Site Admins of the sites involved.

Yours truly,
  PhEDEx transfer request webpage

ENDEMAIL

&send_email(subject => "PhEDEx Request Update (request \#$rid)",
	    to => [ $creator_email ],
	    cc => [ @cc ],
	    from => "PhEDEx Web Requests <$$self{CONFIG}{FEEDBACK_MAIL}>",
	    replyto => [ $admin_email ],
	    message => $message
	    ) or $self->alert("Sending request email to admins failed, sorry");;

    return 1;
}

1;

######################################################################
package Web25::Components::Status;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Status",
	       LINK_TITLE => "View recently active PhEDEx components" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %offline_thresholds = ( 'FileDownload' => 60*140,
			     'FileExport'   => 60*140,
			     'InfoFileSize' => 60*140,
			     'LoadTestInjector' => 60*140,
			     'LoadTestCleanup' => 60*140,
			     'BlockDownloadVerifyInjector' => 60*140,
			     'OTHER'        => 60*140 );
  
  
  my $now = time ();
  my $query = &dbexec($$self{DBH}, qq{
      select n.name, a.name, ast.label, ast.time_update
	  from t_agent_status ast
	  join t_adm_node n on n.id = ast.node
	  join t_agent a on a.id = ast.agent});

  my (%agents, %status);
  while (my $row = $query->fetchrow_arrayref)
  {
      my ($node, $agent, $label, $contact) = @$row;
      $status{$node}{$agent}{$label} = $contact;
      $agents{$agent} = 1;
  }

  my @infrastructure = grep exists $agents{$_}, qw(FileRouter FileIssue FilePump);
  my @workflow = grep exists $agents{$_}, qw(RequestAllocator BlockAllocator BlockMonitor BlockDelete
					     BlockActivate BlockDeactivate);
  my @support = grep exists $agents{$_}, qw(BlockDownloadVerifyInjector InfoFileSize InfoStatesClean
					    InvariantMonitor PerfMonitor LoadTestInjector LoadTestCleanup);
  my @site = grep exists $agents{$_}, qw(FileDownload FileExport FileStager FileRemove BlockDownloadVerify Watchdog AgentFactory);

  my @other;
  foreach my $agent (keys %agents) {
      push @other, $agent unless grep $agent eq $_, @infrastructure, @workflow, @support, @site;
  }

  foreach my $item ([ "Infrastructure", @infrastructure ],
		    [ "Workflow", @workflow ], ["Support", @support],
		    [ "Site", @site ], ["Other", @other])
  {
      my ($type, @agents) = @{$item};

      next unless @agents;

      my @nodes;
      if ($type =~ /(Site|Other)/) {
	  @nodes = sort keys %status;
      } else {
	  push @nodes, 'PhEDEx Central';
      }

      print { $$self{CONTENT} }
      "<p><table class='striped'>\n",
      "<tbody>\n",
      "<tr class='selected'>\n",
      " <td align='center' colspan='" . (scalar @agents + 1) . "'>$type Agents</td>\n",
      "</tr>\n",
      "<tr class='selected'>\n",
      " <th>Node</th>\n",
      (map { " <th>$_</th>\n" } @agents),
      "</tr>\n";

      foreach my $node (@nodes)
      {
	  next if $type =~ /(Site|Other)/ && ! grep (defined $status{$node}{$_}, @agents);

	  print { $$self{CONTENT} } "<tr>\n", " <td>$node</td>\n";
	  foreach my $agent (@agents)
	  {
	      my ($check_node,$check_time);
	      if ($node eq 'PhEDEx Central') {
                  my $check_time_max = 0;
		  foreach my $n (sort keys %status) {
		      if ( exists $status{$n}{$agent} ) {
                        $check_time = (sort { $a <=> $b } values %{$status{$n}{$agent}})[0];
                        if ( $check_time > $check_time_max ) {
                          $check_time_max = $check_time;
                          $check_node = $n;
                        }
                      }
		  }
	      } else {
		  $check_node = $node;
	      }

	      my $offline = ( $offline_thresholds{$agent} || $offline_thresholds{OTHER} );
	      my $active = $offline / 3;

	      my @labels = keys %{$status{$check_node}{$agent}};
	      if (!@labels)
	      {
		  print { $$self{CONTENT} } " <td>&nbsp;</td>\n";
		  next;
	      }	

	      my $nagents = scalar @labels;
	      my %upstatus;
	      my $nup = 0;
	      my $recent_contact = 0;
	      my $recent_agent = $labels[0];
	      foreach my $label (@labels) {
		  my $contact = $status{$check_node}{$agent}{$label};
		  my $ago = &age($now - $contact);
		  if ($contact > $recent_contact) {
		      $recent_contact = $contact;
		      $recent_agent = $label;
		  }
		  
		  if (($now - $contact) < $active) {
		      $upstatus{$label} = { STATUS => 'UP', COLOR => $goodcolor};
		      $nup++;
		  } elsif (($now - $contact) < $offline) {
		      $upstatus{$label} = { STATUS => "UP ($ago ago)", COLOR => $goodcolor};
		      $nup++;
		  } else {
		      $upstatus{$label} = { STATUS => "DOWN ($ago ago)", COLOR => $badcolor};
		  }
	      }
	      my $overall_status = $upstatus{$recent_agent}{STATUS};
	      my $color = $upstatus{$recent_agent}{COLOR};
	      my $upratio = '';
	      if ($nagents > 1) {
		  $upratio = "<br/>(${nup}/${nagents} agents)";
	      }

	      print { $$self{CONTENT} } "<td align='center' bgcolor='$color'>$overall_status $upratio</td>";

	  }
	  print { $$self{CONTENT} } "</tr>\n";
      }
      print { $$self{CONTENT} } "</tbody>\n", "</table>\n";
  }
}

1;

######################################################################
package Web25::Components::Agents;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Processes",
	       LINK_TITLE => "View details about PhEDEx processes" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

    my $now = time();

    # Group by host, 
    my $sql = qq[ select s.time_update time_update,
                         n.name node_name, 
                         s.host_name,
                         s.directory_path,
                         a.name agent_name,
                         v.filename,
                         v.release,
                         v.revision,
                         v.tag,
                         s.label agent_label,
                         s.process_id pid,
                         s.worker_id, 
                         s.queue_pending q_pend,
                         s.queue_received q_recv,
                         s.queue_work q_work,
                         s.queue_completed q_comp,
                         s.queue_bad q_bad,
                         s.queue_outgoing q_out,
                         s.state state
 		    from t_agent_status s
                    join (select host_name, agent, label, process_id, min(node) node
			         from t_agent_status group by host_name, agent, label, process_id) s_sub
                      on s_sub.host_name = s.host_name and s_sub.agent = s.agent 
                     and s_sub.label = s.label and s_sub.node = s.node
		     and s_sub.process_id = s.process_id
		    join t_adm_node n on s.node = n.id
                    join t_agent a on s.agent = a.id
                    left join t_agent_version v on v.agent = a.id and v.node = n.id and v.filename = a.name
		   order by n.name, s.host_name, s.directory_path, s.label, s.worker_id ];
    my $q = &dbexec($$self{DBH}, $sql);

    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{ CONTENT });
    
    $dbtable->set_querycols( [('Age', 'pcolumn', 'TIME_UPDATE', 1)],
			     [('Node', 'pcolumn', 'NODE_NAME', 1)],
			     [('Host', 'pcolumn', 'HOST_NAME', 1)],
			     [('Path', 'pcolumn', 'DIRECTORY_PATH', 1)],
			     [('Agent Name', 'pcolumn', 'AGENT_NAME', 1)],
			     [('File and Version Columns', 'pcolumn', 'FILENAME:RELEASE:REVISION:TAG', 0)],
			     [('Agent Label', 'pcolumn', 'AGENT_LABEL', 1)],
			     [('Process', 'pcolumn', 'PID', 1)],
			     [('Worker', 'pcolumn', 'WORKER_ID', 1)],
			     [('Queue State Columns', 'pcolumn', 'Q_PEND:Q_RECV:Q_WORK:Q_BAD:Q_OUT', 1)] 
			     );
    $dbtable->set_tablehead({
	TIME_UPDATE => 'Age',
	NODE_NAME => 'Node',
	AGENT_NAME => 'Agent Name',
	AGENT_LABEL => 'Agent Label',
	PID => 'Process',
	HOST_NAME => 'Host',
	WORKER_ID => 'Worker',
	Q_PEND => 'Pending',
	Q_RECV => 'Received',
	Q_WORK => 'Work',
	Q_COMP => 'Completed',
	Q_BAD => 'Bad',
	Q_OUT => 'Outgoing',
	FILENAME => 'Filename',
	DIRECTORY_PATH => 'Path',
	RELEASE => 'Version Release',
	REVISION => 'Version Revision',
	TAG => 'Version Tag'
	});

    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    $dbtable->set_dataformats({
	TIME_UPDATE => sub { &age($now - $_[0]) }
    });

    my $nullsub = sub { $_[0] ? 'goodbg' : '' };
    $dbtable->set_cellformats({
	TIME_UPDATE => sub { $now - $_[0] <= (1.5)*3600 ? '' : 'alarm' },
	P_ID => sub { $_[1]->{STATE} ? '' : 'alarm' },
	Q_PEND => $nullsub,
	Q_RECV => $nullsub,
	Q_WORK => $nullsub,
	Q_COMP => $nullsub,
	Q_BAD => $nullsub,
	Q_OUT => $nullsub
    });

    my $nrows = $dbtable->output($q);
    if ($nrows == 0) {
	$self->alert("No process data available.");
    }

    #  Options form
    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = $dbtable->columns_form();
    $optspane->add_tab('Columns', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Components::Links;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Links",
	       LINK_TITLE => "View PhEDEx Topology" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;

    my $from_filter = param('from_filter') || '.*';
    my $to_filter = param('to_filter') || '.*';
    my $andor = param('andor') || 'and';

    print {$$self{CONTENT}}
    "<form method='get' action='#' class='nice'>",
    "<label class='inline'>Show links matching from </label>",
    textfield(-name=>'from_filter', -value=>$from_filter, -class=>'labeled'),
    popup_menu(-name=>'andor',
	       -values=>['and', 'or'],
	       -class=>'labeled'),
    "<label class='inline'>to</label>",    
    textfield(-name=>'to_filter', -value=>$to_filter, -class=>'labeled'),
    submit(-name=>'Update', -class=>'labeled'), "<br/>",
    "</form>";

    my @legend = (['Link exists and is valid', 'green'],
		  ['Link exists, but agents are down', 'red'],
		  ['Link exists, but is excluded', 'orange'],
		  ['Link is deactivated', 'purple'],
		  ['Link does not exist', 'white'],
		  ['Self-reference', 'black']);
    
    print {$$self{CONTENT}} 
    "<table style='float:left;border: 1px solid black;margin-bottom:3px;'><tr><th colspan='2' align='center'>Legend</th></tr>";
    foreach my $pair (@legend) {
	my ($def, $color) = @{$pair};
	print {$$self{CONTENT}}
	"<tr><td><div style='border:1px solid black;width:40px;background-color:$color;'>&nbsp;</div></td>",
	"<td>$def</td></tr>";
    }
    print {$$self{CONTENT}} "</table>";

    print {$$self{CONTENT}}
    "<p style='float:left;width:35em;margin-left:1em;'>",
    "This page displays links between nodes in PhEDEx.  Valid links ",
    "are required for transfers to be possible.  ",
    "Links are invalid when the source/destination node agents are down or they actively ",
    "exclude the other node with the -ignore/-accept options.  ",
    "Links may also be deactivated by the PhEDEx administrators.  ",
    "<b>Warning:</b> Nodes that have never connected to the database are marked as excluded, which is not correct.",
    "</p><br clear='all'/>";
    $from_filter = qr/$from_filter/;
    $to_filter = qr/$to_filter/;

    my $sql = qq{ select fn.name from_node, tn.name to_node, l.is_active, fn.kind from_kind, tn.kind to_kind,
		         xso.time_update source_update, xso.protocols source_protos,
		         xsi.time_update sink_update,   xsi.protocols sink_protos
		    from t_adm_link l
		    join t_adm_node fn on fn.id = l.from_node
		    join t_adm_node tn on tn.id = l.to_node
		    left join t_xfer_source xso
		      on xso.from_node = fn.id
		     and xso.to_node = tn.id
		    left join t_xfer_sink xsi
		      on xsi.from_node = fn.id
		     and xsi.to_node = tn.id
		    where not fn.name like 'X%' and
                          not tn.name like 'X%'
	       };
    my $now = time();
    my $downtime = 5400 + 15*60;  # Hour and a half (real expiration) + 15 minutes grace time
    my $links = &dbexec($$self{DBH}, $sql)->fetchall_arrayref();
    my %link_params;

    my (%from_nodes, %to_nodes);
    foreach my $link (@{$links}) {
	my ($from, $to, $is_active, $from_kind, $to_kind, 
	    $xso_update, $xso_protos, $xsi_update, $xsi_protos) = @{$link};
	my $key = $from.'-->'.$to;
	$link_params{$key} = { EXISTS => 1,
			       IS_ACTIVE => $is_active,
			       XSI_UPDATE => $xsi_update,
			       XSO_UPDATE => $xso_update,
			       FROM_KIND => $from_kind,
			       TO_KIND => $to_kind,
			       XSO_PROTOS => $xso_protos,
			       XSI_PROTOS => $xsi_protos
			       };

	# Explain why links are valid or invalid.  For now we benefit
	# from the fact the xfer_source/xfer_sink tables are never
	# cleaned up.  Exclusion deletes from xfer_source, and
	# xfer_sink, so if there is an old update we know the agent is
	# down, if there is no entry, we know the node has been
	# excluded.  It would be nice to do a more explicit check for
	# this but for now the logic is ok.
	if ($from_kind eq 'MSS' && $to_kind eq 'Buffer') { # Staging link
	    $link_params{$key}{VALID} = 1;
	    $link_params{$key}{REASON} = 'Staging link OK';
	} elsif ($from_kind eq 'Buffer' && $to_kind eq 'MSS') { # Migration link
	    if (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Migration agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Migration agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'Migration link OK';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	} else { # WAN link
	    if (!$xso_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Source agent excluded';
	    } elsif ($xso_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Source agent down';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
	    } elsif (!$xsi_update) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{EXCLUDED} = 1;
		$link_params{$key}{REASON} = 'Destination agent excluded';
	    } elsif ($xsi_update <= ($now - $downtime)) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = 'Destination agent down';
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    } else {
		$link_params{$key}{VALID} = 1;
		$link_params{$key}{REASON} = 'WAN Link OK';
		$link_params{$key}{XSO_AGE} = &age($now - $xso_update);
		$link_params{$key}{XSI_AGE} = &age($now - $xsi_update);
	    }
	}

 	# Check active state
 	if ($link_params{$key}{IS_ACTIVE} ne 'y') {
 	    $link_params{$key}{VALID} = 0;
 	    $link_params{$key}{REASON} = "Link is deactivated";
 	}
	
	# Check protocols
	if ($link_params{$key}{VALID}) {
	    my @from_protos = split(/\s+/, $xso_protos || '');
	    my @to_protos   = split(/\s+/, $xso_protos || '');
	    my $match = 0;
	    foreach my $p (@to_protos) {
		next if ! grep($_ eq $p, @from_protos);
		$match = 1;
		last;
	    }
	    unless ($match) {
		$link_params{$key}{VALID} = 0;
		$link_params{$key}{REASON} = "No matching protocol";
	    }
	}

	my $from_match =  ($from =~ /$from_filter/);
	my $to_match = ($to =~ /$to_filter/);
	if (($andor eq 'and' && ($from_match && $to_match)) ||
	    ($andor eq 'or'  && ($from_match || $to_match))) {
	    $from_nodes{$from} = 1;
	    $to_nodes{$to} = 1;
	}
    }
    my @from_nodes = sort keys %from_nodes;
    my @to_nodes = sort keys %to_nodes;

    my $table = new Web25::TableSpool;
    $table->set_filehandle($$self{CONTENT});
    $table->set_tableclass('data dense rspace');
    $table->set_tablecols(['FROM_NODE', @to_nodes]);
    $table->set_tablehead({'FROM_NODE' => 'From Node &darr; To Node &rarr;'});
    $table->set_cellformats({FROM_NODE => sub { 'head' }});
    
    $table->start();
    $table->head();
    
    foreach my $from (@from_nodes) {
	my $row = {};
	foreach my $to (@to_nodes) {
	    $$row{FROM_NODE} = $from;
	    my $key = $from.'-->'.$to;
	    my $link = $link_params{$key};
	    my $color;
	    if ($from eq $to) { 
		$color = 'black';
	    } elsif ( $$link{EXISTS} && 
		      $$link{IS_ACTIVE} ne 'y' ) {
		$color = 'purple';
	    } elsif ($$link{EXISTS} 
		     && $$link{VALID}) {
		$color = 'green';
	    } elsif ($$link{EXCLUDED}) {
		$color = 'orange';
	    } elsif ( $$link{EXISTS} ) {
		$color = 'red';
	    } else {
		$color = 'white';
	    }
	    # Tooltips only for existing links, for performance reasons
	    my $tooltip = $$link{EXISTS} ? $self->get_tooltip($key, $link, $now) : '';
	    my $cell = "<div class='ttp' style='background-color:$color;'>&nbsp;$tooltip</div>"; 
	    $$row{$to} = $cell;
	}
	$table->row($row);
    }
    
    $table->finish();
}

sub get_tooltip
{
    my ($self, $key, $link, $now) = @_;
    $key =~ s/-->/ &rarr; /;
    my $msg = '';
    my $color = $$link{VALID} ? 'green' : 'red';
    if ($$link{EXISTS}) {
	$msg .= "<p>$$link{REASON}</p>";
	$msg .= "<p>Source update:  $$link{XSO_AGE} ago</p>" if $$link{XSO_AGE};
	$msg .= "<p>Destination update:  $$link{XSI_AGE} ago</p>" if $$link{XSI_AGE};
    } else {
	$msg = $$link{COMMENT};
    }
    return "<div class='tt'><p><b>$key</b></p><span style='color:$color;'>$msg</span></div>";
}

1;

######################################################################
package Web25::Activity::Rate;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Rate",
	       LINK_TITLE => "Show recent transfer rates in tabular form" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(span errors tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::TransferRate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  @save = qw(andor tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::TransferDetails");
  @save = qw(tofilter fromfilter) 
      if $args{"page"} && ($args{"page"} eq "Activity::ErrorInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my @spans = qw(h 2h d w m);
  my %params = $self->validate_all
      (
       allow => [qw(span errors tofilter fromfilter andor)],
       spec  => 
       {
	   span       => { allowing => \@spans, default => $spans[0] },
	   errors     => { using => 'onoff' },
	   tofilter   => { using => 'regex', default => '.*' },
	   fromfilter => { using => 'regex', default => '.*' },
	   andor      => { using => 'andor', default => 'or' },
       }
       );
# Explicit checking of arguments
  foreach ( qw( fromfilter tofilter ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }

  my $now = time();
  my %spans = (h => [ 'Last hour', $now, 3600 ],
	       '2h' => [ 'Last 2 hours', $now, 3600*2 ],
	       d => [ 'Last day', $now, 86400 ],
	       w => [ 'Last 7 days', int($now/86400)*86400, 7*86400 ],
	       m => [ 'Last 30 days', int($now/86400)*86400, 30*86400 ]);
  
  my %stats = ();
  my $span       = $params{span};
  my $errors     = $params{errors} ? "checked='checked'" : "";
  my $tofilter   = $params{tofilter};
  my $fromfilter = $params{fromfilter};
  my $andor      = $params{andor};

  my $q = &dbexec($$self{DBH}, qq{
    select
      f.name from_node,
      t.name to_node,
      nvl(sum(h.done_files),0) done_files,
      nvl(sum(h.done_bytes),0) done_bytes,
      nvl(sum(h.fail_files),0) fail_files,
      nvl(sum(h.expire_files),0) expire_files
    from t_history_link_events h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    $stats{$span}{N}{$key} = $row;
  }

  $q = &dbexec($$self{DBH}, qq{
    select /*+ index(h PK_HISTORY_LINK_STATS) */
      f.name from_node,
      t.name to_node,
      nvl(avg(h.param_rate),0) param_rate,
      nvl(avg(h.param_latency),0) param_latency
    from t_history_link_stats h
      join t_adm_node f on f.id = h.from_node
      join t_adm_node t on t.id = h.to_node
    where h.timebin > :old
    group by f.name, t.name},
    ":old" => $spans{$span}[1]-$spans{$span}[2]);
  while (my $row = $q->fetchrow_hashref())
  {
    my $key = "$$row{TO_NODE} $$row{FROM_NODE}";
    next if ! exists $stats{$span};
    $stats{$span}{N}{$key}{PARAM_RATE} = $$row{PARAM_RATE};
    $stats{$span}{N}{$key}{PARAM_LATENCY} = $$row{PARAM_LATENCY};
  }

  $stats{$span}{T}{1} = { DONE_FILES => 0, DONE_BYTES => 0, FAIL_FILES => 0, EXPIRE_FILES => 0 };
  print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<label for='span'>Time span</label>\n",
    "<select name='span' onchange='submit()'>",
    (map { (" <option", ($span eq $_ ? " selected='selected'" : ""),
	    "  value='$_'>$spans{$_}[0]</option>") } @spans),
    "</select>\n",
    "&nbsp;<input type='checkbox' name='errors' $errors>\n",
    "<label for='errors'>Include links with nothing but errors</label> ",
    "<input type='submit' value='Update'></p>\n",
    "<p>\n",
    ( $self->{CONFIG}{TESTING_MODE} ? "<div id='Activity::Rate'>\n" : ''),
    "<table class='striped'>",
#    "<thead>\n",

    "<tr class='selected'>\n",
    " <th colspan='10'>",
    "Last @{[&format_timespan($spans{$span}[2])]}",
    "</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>To</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From</th>\n",
    " <th rowspan='2'>Files</th>\n",
    " <th rowspan='2'>Total Size</th>\n",
    " <th rowspan='2'>Rate</th>\n",
    " <th rowspan='2'>Errors</th>\n",
    " <th rowspan='2'>Expired</th>\n",
    " <th rowspan='2'>Avg. Est. Rate</th>\n",
    " <th rowspan='2'>Avg. Est. Latency</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "<th>",
    "<select name='andor' onchange='submit()'>",
    " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
    "  value='and'>and</option>",
    " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
    "  value='or'>or</option>",
    "</select>",
    "</th>",
    " <th>",
    textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	      -title=>("Regular expression to match against node or link names. "
		       ."Only those matching the expression will be shown.")),
    "</th>\n",
    "</tr>\n",
#   "</thead>\n",
    "<tbody>\n";

  foreach my $kind (qw(N T))
  {
      no warnings 'uninitialized'; # XXX being lazy here...
      foreach my $row (sort { 
	                       $$b{DONE_BYTES} <=> $$a{DONE_BYTES}
			    || $$b{FAIL_FILES} <=> $$a{FAIL_FILES}
			    || $$b{EXPIRE_FILES} <=> $$a{EXPIRE_FILES}
			    || $$a{TO_NODE} cmp $$b{TO_NODE}
			    || $$a{FROM_NODE} cmp $$b{FROM_NODE} }
		     values %{$stats{$span}{$kind}})
    {
      next if ($kind eq 'N'
	       && ($fromfilter || $tofilter)
	       && ($andor eq 'or'
		   ? ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			|| ($tofilter && $$row{TO_NODE} =~ /$tofilter/))
		   : ! (($fromfilter && $$row{FROM_NODE} =~ /$fromfilter/)
			&& ($tofilter && $$row{TO_NODE} =~ /$tofilter/))));
      next if $kind eq 'N' && ! $errors && ! $$row{DONE_FILES};
      next if $kind eq 'N' && ! $$row{DONE_FILES} && ! $$row{FAIL_FILES} && ! $$row{EXPIRE_FILES};
      my $bps = $$row{DONE_BYTES} / $spans{$span}[2];

      my $errorcolumn = &format_num($$row{FAIL_FILES});
      if ($$row{FAIL_FILES} && $$row{FROM_NODE} && $$row{TO_NODE}) {
	  my $errorurl = $self->myurl(page => 'Activity::ErrorInfo',
				      fromfilter => $$row{FROM_NODE},
				      tofilter => $$row{TO_NODE});
	  $errorcolumn = "<a href='$errorurl'>$errorcolumn</a>";
      }

      print { $$self{CONTENT} }
	"<tr>",
	($$row{FROM_NODE}
	 ? "<td>$$row{TO_NODE}</td><td>&nbsp;</td><td>$$row{FROM_NODE}</td>"
	 : "<td colspan='3'>Total</td>"),
	"<td align='right'>@{[&format_num($$row{DONE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{DONE_BYTES})]}</td>",
	"<td align='right'>", ($bps >= 0 ? &format_size($bps) . '/s' : &format_num(0)), "</td>",
	"<td align='right'>$errorcolumn</a></td>",
	"<td align='right'>@{[&format_num($$row{EXPIRE_FILES} || 0)]}</td>",
	"<td align='right'>@{[&format_size($$row{PARAM_RATE} || 0)]}/s</td>",
	"<td align='right'>@{[&age($$row{PARAM_LATENCY} || 0)]}</td>",
	"</tr>\n";

      if ($kind eq 'N')
      {
	$stats{$span}{T}{1}{DONE_FILES} += $$row{DONE_FILES};
	$stats{$span}{T}{1}{DONE_BYTES} += $$row{DONE_BYTES};
	$stats{$span}{T}{1}{FAIL_FILES} += $$row{FAIL_FILES};
	$stats{$span}{T}{1}{EXPIRE_FILES} += $$row{EXPIRE_FILES};
      }
    }
  }
  print { $$self{CONTENT} } "</tbody></table></div></p></form>\n";
}

1;

######################################################################
package Web25::Activity::PlotPage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);
use File::Temp ':mktemp';

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);

  $$self{PERIOD_ORDER} = [ qw(l12h l24h l48h l72h l96h l132h l7d l14d l30d l45d l90d l120d
			    l6w l26w l52w ad aw am) ];
  $$self{PERIODS} = {
      "l12h" => [ "12:hour", "Last 12 Hours" ],
      "l24h" => [ "24:hour", "Last 24 Hours" ],
      "l48h" => [ "48:hour", "Last 48 Hours" ],
      "l72h" => [ "72:hour", "Last 72 Hours" ],
      "l96h" => [ "96:hour", "Last 96 Hours" ],
      "l132h" => [ "132:hour", "Last 132 Hours" ],
      "l7d" => [ "7:day", "Last 7 Days" ],
      "l14d" => [ "14:day", "Last 14 Days" ],
      "l30d" => [ "30:day", "Last 30 Days" ],
      "l45d" => [ "45:day", "Last 45 Days" ],
      "l90d" => [ "90:day", "Last 90 Days" ],
      "l120d" => [ "120:day", "Last 120 Days" ],
      "l6w" => [ "6:week", "Last 6 Weeks" ],
      "l26w" => [ "26:week", "Last 26 Weeks" ],
      "l52w" => [ "52:week", "Last 52 Weeks" ],
      "ad" => [ "0:day", "Daily Since Start" ],
      "aw" => [ "0:week", "Weekly Since Start" ],
      "am" => [ "0:month", "Monthly Since Start" ] };

  $$self{GRAPHTOOL} = "$$self{CONFIG}{GRAPHTOOL_URL}";
  $$self{DEFAULT_PERIOD} = 'l96h';
  $$self{DEFAULT_GRAPH} = undef;
  $$self{GRAPH_ORDER} = [];
  $$self{GRAPHS} = {};
  $$self{ENTITY_ORDER} = [qw(dest src link)];
  $$self{ENTITIES} = {dest => 'Destination', src => 'Source', link => 'Link'};
  $$self{DEFAULT_ENTITY} = 'dest';
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(period graph entity src_filter dest_filter no_mss upto);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Activity::RatePlots"
        && $args{"page"} ne "Activity::QueuePlots"
        && $args{"page"} ne "Activity::QualityPlots");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my %params = $self->validate_all
      (
       allow => [qw(period graph entity src_filter dest_filter no_mss upto)],
       spec  => 
       {
	   period     => { allowing => [keys %{$$self{PERIODS}}],
			   default  => $$self{DEFAULT_PERIOD}
		       },
	   graph      => { allowing => [keys %{$$self{GRAPHS}}],
			   default  => $$self{DEFAULT_GRAPH}
		       },
	   entity     => { allowing => [keys %{$$self{ENTITIES}}],
			   default  => $$self{DEFAULT_ENTITY}
		       },
	   src_filter  => { using => 'regex' },
	   dest_filter => { using => 'regex' },
	   no_mss      => { using => 'boolean', default => 'true' },
	   upto        => { using => 'time' },
	   timestamp   => { using => 'pos_int' },
       }
       );
# Explicit checking of arguments
  foreach ( qw( dest_filter src_filter ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }

  my $page = $params{page};
  my $period = $params{period};
  my $graph = $params{graph};
  my $entity = $params{entity};
  my $src_filter = $params{src_filter};
  my $dest_filter = $params{dest_filter};
  my $no_mss = $params{no_mss};
  my $upto = $params{upto};

  my $dest_filter_name = 'destination';
  if (exists $$self{DEST_ONLY_GRAPHS}
      && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      $$self{ENTITY_ORDER} = ['dest'];
      $$self{ENTITIES} = { dest => 'Node' };
      $dest_filter_name = 'node';
  }

  my $formurl = $self->myurl();

  print { $$self{CONTENT} } 
  "<form method='get' action='$formurl' class='nice'>\n",
  "<label for='graph' class='inline'>Graph</label>\n",
  popup_menu(-name=>'graph', -onchange=>'submit()',
	     -values=>$$self{GRAPH_ORDER},
	     -labels=>$$self{GRAPHS},
	     -class=>'labeled'),
  "<label for='entity' class='inline'>by</label> ",
  popup_menu(-name=>'entity', -onchange=>'submit()', 
	     -values=>$$self{ENTITY_ORDER},
	     -labels=>$$self{ENTITIES},
	     -class=>'labeled'),
  "<label class='inline'>filter</label>";

  unless (exists $$self{DEST_ONLY_GRAPHS} && grep $graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) {
      print { $$self{CONTENT} }
      "<label class='inline' for='src_filter'>source</label>",
      textfield(-name=>'src_filter', -size=>15,
		-title=>("Regular expression to match against node names. "
			 ."Only those matching the expression will be shown."),
		-class=>'labeled');
  } else { print {$$self{CONTENT}} hidden('src_filter'); }

  print { $$self{CONTENT} }
  "<label class='inline' for='dest_filter'>$dest_filter_name</label>",
  textfield(-name=>'dest_filter', -size=>15,
	    -title=>("Regular expression to match against node names. "
		     ."Only those matching the expression will be shown."),
	    -class=>'labeled'),
  popup_menu(-name=>'no_mss', -values=>['true', 'false'], -labels=>{'true' => 'hide MSS nodes', 'false' => 'show MSS nodes'},
	     -default=>$no_mss, -onchange=>'submit()', -class=>'labeled'),
  "<br/>";
  
  print { $$self{CONTENT} }
  "<label for='period' class='inline'>Period</label>\n",
  popup_menu(-name=>'period', -onchange=>'submit()',
	     -values=>$$self{PERIOD_ORDER},
	     -labels=>{ map { $_ => $$self{PERIODS}{$_}[1] } @{$$self{PERIOD_ORDER}} },
	     -default=>$period,
	     -class=>'labeled'),
  "<label for='upto' class='inline'>up to</label>",
  textfield(-name=>'upto', -size=>15,
	    -title=>("Time up to and including which results will be shown. "
		     ."Specify the time in format matching the selected period:\n"
		     ."YYYYMMDDZHHMM for hourly periods;\n"
		     ."YYYYMMDD for daily periods;\n"
		     ."YYYYMM for monthly periods;\n"
		     ."YYYYWW for weekly periods."),
	    -class=>'labeled'),
		     submit(-label=>'Update', -class=>'labeled'), "<br/>",
		     "</form>";

  my ($last, $unit) = $$self{PERIODS}{$period}[0] =~ /([^:]+)/g;
  my %span = ("hour" => 3600, "day" => 86400, "week" => 7*86400, "month" => 86400);
  my %round = (%span, 'week' => 86400);
  my $now = time();
  my $end = (int($now/$round{$unit})+1)*$round{$unit};
  if ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)Z(\d\d)\d\d$/)
  {
    $end = timegm(0, 0, $4, $3, $2-1, $1-1900) + 3600;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, $3, $2-1, $1-1900) + 86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/ && $unit eq 'week')
  {
    # January 4th is always in (ISO) week one, so find out what
    # day of week that is, then go back to Monday of that week,
    # and advance specified number of weeks plus one.
    my $jan4 = timegm(0, 0, 0, 4, 0, $1-1900);
    my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
    my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($jan4);
    $end = $jan4 + (-$diff{$wday} + 7*$2)*86400;
  }
  elsif ($upto && $upto =~ /^(\d\d\d\d)(\d\d)$/)
  {
    $end = timegm(0, 0, 0, 1, $2, $1-1900);
  }

  my $start = ($last ? $end - $last*$span{$unit} : 0);
  # The new plot package really does set range to time 0.
  # Need to provide a more reasonable range.  PhEDEx started taking data in Sep 2004.
  $start = timegm(0, 0, 0, 1, 9, 2004-1900) if $start == 0;  

  my $conn = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{GRAPH_CONNECTION};

  my %args = ('conn' => $conn, 'unit' => $unit, 'span' => $span{$unit}, 'by' => $entity, 'last' => $last,
              'src_filter' => $src_filter, 'dest_filter' => $dest_filter, 'no_mss' => $no_mss,
	      'upto' => $upto, 'starttime' => $start, 'endtime' => $end);
  
  my $imgsrc = $self->imgsrc($graph, %args);
  if ( defined($imgsrc) ) {
    print {$$self{CONTENT}} "<p><img src='$imgsrc' /></p>";
  } else {
    print {$$self{CONTENT}} "<p>Sorry, something went wrong. Please try again later.</p>";
  }
}

1;

######################################################################
package Web25::Activity::RatePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Rate Plots",
	       LINK_TITLE => "Show recent transfer rate as plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quantity_rates';
  $$self{GRAPH_ORDER} = [ 'quantity_rates', 'quantity', 'quantity_cumulative' ];
  $$self{GRAPHS} = { 'quantity_rates' => "Transfer Rate", 
		     'quantity' => "Transfer Volume", 
		     'quantity_cumulative' => "Cumulative Volume" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

#sub output
#{
#  my ($self) = @_;
#  print {$$self{CONTENT}} "<div id='Activity::RatePlots'></div>";
#}

1;

######################################################################
package Web25::Activity::QueuePlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "Queue Plots",
	       LINK_TITLE => "Show pending transfer queue plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'destined';
  $$self{GRAPH_ORDER} = [ 'pending', 'destined', 'resident', 'missing', 'request', 'idle' ];
  $$self{GRAPHS} = { 
      'pending'  => "Volume Queued",       # any
      'destined' => "Volume Routed",       # by dest only
      'resident' => "Volume Resident",     # by dest only
      'missing'  => "Volume Missing",      # by dest only
      'request'  => "Volume Requested",    # by dest only
      'idle'     => "Volume Idle",         # by dest only
		     };

  $$self{DEST_ONLY_GRAPHS} = [ qw( destined resident missing request idle ) ];

  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;
  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('from_node' => $from_node,
		   'to_node' => $to_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $dest_only = (grep($graph eq $_, @{$$self{DEST_ONLY_GRAPHS}}) ? 1 : 0);
  if ($dest_only && $args{by} ne 'dest') {
      $self->alert("The \"$$self{GRAPHS}{$graph}\" graph can only show data by destination");
      return;
  } elsif ($dest_only) {
      $graphargs{node} = $to_node;
      delete $graphargs{from_node};
      delete $graphargs{to_node};
  }

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::QualityPlots;
use strict; use warnings;
use base "Web25::Activity::PlotPage";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Quality Plots",
	       LINK_TITLE => "Show transfer quality plots" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{DEFAULT_GRAPH} = 'quality_all';
  $$self{GRAPH_ORDER} = [ 'quality_all', 'quality_try', 'quality_done', 'quality_fail' ];
  $$self{GRAPHS} = { 'quality_all'  => "Quality Map",
		     'quality_try'  => "Attempts",
		     'quality_done' => "Successes",
		     'quality_fail' => "Failures" };
  bless $self, $class;
  return $self;
}

sub imgsrc
{
  my ($self, $graph, %args) = @_;

  my $from_node = ($args{src_filter} ? $args{src_filter} : '.*');
  my $to_node = ($args{dest_filter} ? $args{dest_filter} : '.*');

  my %graphargs = ('to_node' => $to_node,
		   'from_node' => $from_node,
		   'no_mss' => $args{no_mss},
		   'conn' => $args{conn},
		   'link' => $args{by},
		   'span' => $args{span},
		   'starttime' => $args{starttime}, 
		   'endtime' => $args{endtime});

  my $imgsrc = $$self{GRAPHTOOL}."/${graph}?". &urlencode(%graphargs);
  return $imgsrc;
}

1;

######################################################################
package Web25::Activity::Routing;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Routing",
	       LINK_TITLE => "Show current routing information" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my %params = $self->validate_all
      (
       allow => [qw(tofilter fromfilter blockfilter priority showinvalid)],
       spec  => 
       {
	   tofilter    => { using => 'regex', default => '.*' },
	   fromfilter  => { using => 'regex', default => '.*' },
	   blockfilter => { using => 'regex', default => '.*' },
	   priority    => { allowing => [qw(any high normal low)],
			    default   => 'any' },
	   showinvalid => { using => 'onoff' }
       }
       );
# Explicit checking of arguments
  foreach ( qw( blockfilter ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^[a-zA-Z0-9:.\-_/#*|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }
  foreach ( qw( fromfilter tofilter ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }

  my $tofilter    = $params{tofilter};
  my $fromfilter  = $params{fromfilter};
  my $priority    = $params{priority};
  my $blockfilter = $params{blockfilter};
  my $showinvalid = $params{showinvalid};

  my $now = time();
  my @nodes = sort $self->fetch_nodes();

  print {$$self{CONTENT}}
  "<form class='nice' method='get' action='#'>",
  "<label>Show paths on links to </label>",
  textfield(-name=>'tofilter', -default=>$tofilter, -size=>15, -class=>'labeled'),
  "<label class='inline'>and from </label>",
  textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15, -class=>'labeled'),
  "<label class='inline'> with  </label>",
  popup_menu(-name=>'priority', -values=>['any', 'high', 'normal', 'low'],
	     -default=>$priority, -onchange=>'submit()', -class=>'labeled'),
  "<label class='inline'> priority  </label>",
  checkbox(-name=>'showinvalid', -checked=>($showinvalid||0), -label=>'Show Invalid Paths', -class=>'labeled'),
  "<br/><label>Filter blocks </label>",
  textfield(-name=>'blockfilter', -default=>$blockfilter, -size=>15, -class=>'labeled'),
  " ", submit(-label=>'Update'),
  "</form><br clear='all'>";

  my $query = qq{
      select nd.name destination, ns.name source, b.name block,
             s.priority, s.is_valid, s.route_files, s.route_bytes, s.xfer_attempts, s.time_request
       from t_status_block_path s
       join t_adm_node nd on nd.id = s.destination
       join t_adm_node ns on ns.id = s.src_node
       join t_dps_block b on b.id = s.block
       order by s.time_request
  };

  my $q = &dbexec($$self{DBH}, $query);

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  my @cols = qw(DESTINATION SOURCE BLOCK PRIORITY ROUTE_FILES ROUTE_BYTES
		XFER_ATTEMPTS AVG_ATTEMPTS TIME_REQUEST);
  unshift(@cols, 'IS_VALID') if $showinvalid;

  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead({
      DESTINATION => 'Destination',
      SOURCE => 'Source',
      BLOCK => 'Block Name',
      PRIORITY => 'Priority',
      IS_VALID => 'Valid?',
      ROUTE_FILES => 'Routed<br/>Files',
      ROUTE_BYTES => 'Routed<br/>Bytes',
      XFER_ATTEMPTS => 'Transfer<br/>Attempts',
      AVG_ATTEMPTS => 'Average<br/>Attempts',
      TIME_REQUEST => 'Earliest<br/>Request'
      });

  $dbtable->set_dataformats({
       'PRIORITY' => sub { my $name;
 			  if    ($_[0] == 0) {$name = 'high'}
 			  elsif ($_[0] == 1) {$name = 'normal'}
 			  else               {$name = 'low' }
 			  return $name; },
      'IS_VALID' => sub { $_[0] ? 'valid' : 'invalid' },
      'ROUTE_BYTES' => sub { &format_size($_[0]) },
      'TIME_REQUEST' => sub { &age($now - $_[0])." ago" },
      'AVG_ATTEMPTS' => sub { sprintf("%.2f", $_[0]) }
  });

  $dbtable->add_pseudocolumn('AVG_ATTEMPTS', sub { return $_[1]->{ROUTE_FILES} ? 
						       $_[1]->{XFER_ATTEMPTS} / $_[1]->{ROUTE_FILES}
						   : 'N/A' });

  $dbtable->set_filters({
      'DESTINATION' => sub { $_[0] =~ /$tofilter/ ? 1 : 0 },
      'SOURCE' => sub { $_[0] =~ /$fromfilter/ ? 1 : 0 },
      'BLOCK' => sub { $_[0] =~ /$blockfilter/ ? 1 : 0 },
      'IS_VALID' => sub { $showinvalid || $_[0] == 1 ? 1 : 0 },
      'PRIORITY' => sub { ($priority eq 'any'
			   || ($priority eq 'high'   && $_[0] == 0)
			   || ($priority eq 'normal' && $_[0] == 1)
			   || ($priority eq 'low'    && $_[0] >= 2)) ? 1 : 0 }
  });

  $dbtable->set_cellformats({
      'AVG_ATTEMPTS' => sub { $_[0] >= 3 ? 'alarm' : '' },
      'TIME_REQUEST' => sub { ($now - $_[0]) > 3600*24*3 ? 'alarm' : '' },
      'IS_VALID' => sub { $showinvalid && $_[0] == 0 ? 'alarm' : '' }
  });

  $dbtable->set_statcols({
      'ROUTE_FILES' => 'SUM',
      'ROUTE_BYTES' => 'SUM'
      });

  my $nrows = $dbtable->output($q);

  if ($nrows == 0) {
      $self->note("No results available.");
  }
}

1;

######################################################################
package Web25::Activity::TransferDetails;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);

our $INDEX = { LIST => 1, ORDER => 6, TITLE => "Transfer Details",
	       LINK_TITLE => "Browse transfer state details" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
    my ($self) = @_;
    my %params = $self->validate_all
	(
	 allow => [qw(tofilter fromfilter andor)],
	 spec  => 
	 {
	     tofilter    => { using => 'regex', default => '.*' },
	     fromfilter  => { using => 'regex', default => '.*' },
	     andor       => { using => 'andor', default => 'or' },
	 }
	 );
# Explicit checking of arguments
    foreach ( qw( fromfilter tofilter ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }

    my $tofilter   = $params{tofilter};
    my $fromfilter = $params{fromfilter};
    my $andor      = $params{andor};

    # Transfer state details
    my $rows = 0;
    my $now = time();
    my %total = ();
    my $query = &dbexec($$self{DBH}, qq{
    select
      time_update,
      nd.name, ns.name,
      state, priority,
      files, bytes
    from t_status_task xs
      join t_adm_node ns on ns.id = xs.from_node
      join t_adm_node nd on nd.id = xs.to_node
    order by nd.name, ns.name, state});

    print { $$self{CONTENT} }
    "<form method='get' action='@{[$self->myurl()]}'><p>\n",
    "<input type='submit' value='Update'></p>\n",
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='10' align='center'>Transfer State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th rowspan='2'>Age</th>\n",
    " <th>To Node</th>\n",
    " <th>&nbsp;</th>\n",
    " <th>From Node</th>\n",
    " <th rowspan='2'>State</th>\n",
    " <th rowspan='2'>Transfer</th>\n",
    " <th rowspan='2'>Priority</th>\n",
    " <th rowspan='2'>N Files</th>\n",
    " <th rowspan='2'>Size</th>\n",
    " <th rowspan='2'>Detail</th>\n",
    "</tr>\n",
    "<tr class='selected'>",
    " <th>\n",
    textfield(-name=>'tofilter', -default=>$tofilter, -size=>15,
              -title=>("Regular expression to match against node or link names. "
                       ."Only those matching the expression will be shown.")
	      ),
     "</th>",
     "<th>",
     "<select name='andor' onchange='submit()'>",
     " <option ", ($andor eq 'and' ? 'selected=selected' : ''),
     "  value='and'>and</option>",
     " <option ", ($andor eq 'or' ? 'selected=selected' : ''),
     "  value='or'>or</option>",
     "</select>",
     "</th>",
     "<th>",
     textfield(-name=>'fromfilter', -default=>$fromfilter, -size=>15,
	       -title=>("Regular expression to match against node or link names. "
			."Only those matching the expression will be shown.")),
     "</th>",
     "</tr>\n";
    
    while (my $row = $query->fetchrow_arrayref)
    {
	my ($stamp,
	    $to_node, $from_node,
	    $state, $priority,
	    $files, $bytes) = @$row;

	next if (($fromfilter || $tofilter)
		 && ($andor eq 'or'
		     ? ! (($fromfilter && $from_node =~ /$fromfilter/)
			  || ($tofilter && $to_node =~ /$tofilter/))
		     : ! (($fromfilter && $from_node =~ /$fromfilter/)
			  && ($tofilter && $to_node =~ /$tofilter/))));
	$total{$state} ||= { FILES => 0, BYTES => 0 };
	$total{$state}{FILES} += $files;
	$total{$state}{BYTES} += $bytes;
	my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
	my $transfer_name = ($priority % 2 == 0 ? 'local' : 'remote'); # Local even, remote odd
	my $priority_name = ($priority == 0 || $priority == 1 ? 'high'
			     : $priority == 2 || $priority == 3 ? 'normal'
			     : $priority == 4 || $priority == 5 ? 'low'
			     : 'unknown');
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	my $url = $self->myurl("page" => "Activity::FileInfo",
			       "to_node" => $to_node,
			       "from_node" => $from_node,
			       "state" => $state_name,
			       "priority" => $priority
			       );
	print { $$self{CONTENT} }
	"<tr>\n",
	" <td$stampcolor>", ($now - $stamp < 5*60 ? 'current' : &age($now - $stamp)), "</td>\n",
	" <td>$to_node</td>\n",
	" <td align='right'>&nbsp;</td>\n",
	" <td>$from_node</td>\n",
	" <td align='left'>$state_name</td>\n",
	" <td align='left'>$transfer_name</td>\n",
	" <td align='left'>$priority_name</td>\n",
	" <td align='right'>@{[&format_num($files)]}</td>\n",
	" <td align='right'>@{[&format_size($bytes)]}</td>\n",
	" <td align='center'><a href='$url'>(Files)</a></td>\n",
	"</tr>\n";
    }
    
    my $first_total = 1;
    my ($tfiles, $tbytes) = (0, 0);
    foreach my $state (sort keys %total)
    {
	$tfiles += $total{$state}{FILES};
	$tbytes += $total{$state}{BYTES};
	my $state_name = ($state == 0 ? "assigned"
			  : $state == 1 ? "exported"
			  : $state == 2 ? "transferring"
			  : $state == 3 ? "transferred"
			  : "unknown");
	
	print { $$self{CONTENT} }
        "<tr>\n",
        " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
        " <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>&nbsp;</td>\n",
	" <th align='right'>$state_name</td>\n",
	" <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
	" <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
	" <th align='right'>&nbsp;</th>\n",
	"</tr>\n";
	$first_total = 0;
    }

    print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>&nbsp;</td>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    " <th align='right'>&nbsp;</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n";

    # Destined
    $rows = 0;
    $query = &dbexec($$self{DBH}, qq{
    select
      n.name, max(br.time_update),
      sum(br.dest_files), sum(br.dest_bytes),
      sum(br.node_files), sum(br.node_bytes),
      sum(br.xfer_files), sum(br.xfer_bytes)
     from t_dps_block_replica br join t_adm_node n on n.id = br.node
     group by n.name order by n.name});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    "<th align='center' colspan='8'>Destined Data</th>\n",
    "</tr>",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Last<br>Change</th>\n",
    " <th rowspan='2'>Node</th>\n",
    " <th colspan='2'>Destined</th>\n",
    " <th colspan='2'>On Site</th>\n",
    " <th colspan='2'>In Transfer</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    " <th align='right'>N</th><th align='right'>Size</th>\n",
    "</tr>\n";

 my ($tdest_files, $tdest_size,
     $tnode_files, $tnode_size,
     $txfer_files, $txfer_size) = (0) x 6;

  while (my $row = $query->fetchrow_arrayref)
  {
    my ($n, $stamp,
	$dest_files, $dest_size,
	$node_files, $node_size,
	$xfer_files, $xfer_size) = @$row;

    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $n =~ /$fromfilter/)
		   || ($tofilter && $n =~ /$tofilter/)));

    $tdest_files += $dest_files; $tdest_size += $dest_size;
    $tnode_files += $node_files; $tnode_size += $node_size;
    $txfer_files += $xfer_files; $txfer_size += $xfer_size;

    my $node_color = (($dest_files && $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : $xfer_files ? " bgcolor='$pendcolor'" : "");
    my $xfer_color = (($xfer_files) ? " bgcolor='$goodcolor'"
		      : ($xfer_files + $node_files < $dest_files) ? " bgcolor='$pendcolor'"
		      : "");

    print { $$self{CONTENT} }
      "<tr>\n",
      " <td>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$n</td>\n",
      " <td align='right'>@{[&format_num($dest_files)]}</td>\n",
      " <td align='right'>@{[&format_size($dest_size)]}</td>\n",
      " <td align='right'$node_color>@{[&format_num($node_files)]}</td>\n",
      " <td align='right'$node_color>@{[&format_size($node_size)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_num($xfer_files)]}</td>\n",
      " <td align='right'$xfer_color>@{[&format_size($xfer_size)]}</td>\n",
      "</tr>\n";
  }
  my $node_color = (($tdest_files && $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : ($txfer_files) ? " bgcolor='$pendcolor'" : "");
  my $xfer_color = (($txfer_files) ? " bgcolor='$goodcolor'"
		    : ($txfer_files + $tnode_files < $tdest_files) ? " bgcolor='$pendcolor'"
		    : "");

  print { $$self{CONTENT} }
    "<tr>\n",
    " <th>&nbsp;</th>\n",
    " <th align='left'>Total</th>\n",
    " <th align='right'>@{[&format_num($tdest_files)]}</th>\n",
    " <th align='right'>@{[&format_size($tdest_size)]}</th>\n",
    " <th align='right'$node_color>@{[&format_num($tnode_files)]}</th>\n",
    " <th align='right'$node_color>@{[&format_size($tnode_size)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_num($txfer_files)]}</th>\n",
    " <th align='right'$xfer_color>@{[&format_size($txfer_size)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n";


    # Replicas
  $query = &dbexec($$self{DBH}, qq{
    select xr.time_update, n.name, xr.state, xr.is_custodial, xr.files, xr.bytes
    from t_status_replica xr join t_adm_node n on n.id = xr.node
    order by n.name, state});

  print { $$self{CONTENT} }
    "<p><table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6' align='center'>Replica State Details</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th rowspan='2'>Age</th>",
    " <th rowspan='2'>Node</th>",
    " <th rowspan='2'>State</th>",
    " <th rowspan='2'>Custodial</th>",
    " <th colspan='2'>Files</th>",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>N</th>\n",
    " <th>Size</th>\n",
    "</tr>\n";

  %total = ();
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($stamp, $node, $state, $custodial, $files, $bytes) = @$row;
    next if (($fromfilter || $tofilter)
	     && ! (($fromfilter && $node =~ /$fromfilter/)
		   || ($tofilter && $node =~ /$tofilter/)));
    $total{$state} ||= { FILES => 0, BYTES => 0 };
    $total{$state}{FILES} += $files;
    $total{$state}{BYTES} += $bytes;
    my $stampcolor = ($now - $stamp < 5*60) ? '' : " bgcolor='$warncolor'";
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    my $cust_name = ($custodial eq 'y' ? "custodial" : "non-cust.");
		    
    my $color = (($state == 1) ? " bgcolor='$goodcolor'" : "");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td$stampcolor>", ($now - $stamp < 5*60 ? 'Current' : &age($now - $stamp)), "</td>\n",
      " <td>$node</td>\n",
      " <td$color align='right'>$state_name</td>\n",
      " <td$color align='right'>$cust_name</td>\n",
      " <td$color align='right'>@{[&format_num($files)]}</td>\n",
      " <td$color align='right'>@{[&format_size($bytes)]}</td>\n",
      "</tr>\n";
  }

  $first_total = 1;
  ($tfiles, $tbytes) = (0, 0);
  foreach my $state (sort keys %total)
  {
    $tfiles += $total{$state}{FILES};
    $tbytes += $total{$state}{BYTES};
    my $state_name = ($state == 0 ? "at node"
		      : $state == 1 ? "on disk"
		      : "unknown");
    print { $$self{CONTENT} }
      "<tr>\n",
      " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
      " <th align='right'>$state_name</td>\n",
      " <th align='right'>@{[&format_num($total{$state}{FILES})]}</th>\n",
      " <th align='right'>@{[&format_size($total{$state}{BYTES})]}</th>\n",
      "</tr>\n";
    $first_total = 0;
  }
  print { $$self{CONTENT} }
    "<tr>\n",
    " <th align='left' colspan='2'>", ($first_total ? "Total" : "&nbsp;"), "</th>\n",
    " <th align='right'>All</td>\n",
    " <th align='right'>@{[&format_num($tfiles)]}</th>\n",
    " <th align='right'>@{[&format_size($tbytes)]}</th>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>\n",
    "</form>\n";
}

1;

######################################################################
package Web25::Activity::Deletions;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);

our $INDEX = { LIST => 1, ORDER => 7, TITLE => "Deletions",
	       LINK_TITLE => "View Deletion Queue",
               SECURE => 0 };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my $self = shift @_;

    my %params = $self->validate_all
	(
	 allow => [qw(reqfilter node blockfilter state)],
	 spec  => 
	 {
	     reqfilter  =>  { using => 'pos_int_list', default => ''},
	     node =>        { using => 'regex', default => 'Enter a node name' },
	     blockfilter => { using => 'regex', default => '.*' },
	     state       => { allowing => [qw(any pending complete)],
			      default   => 'any' },
	 }
	 );
# Explicit checking of arguments
  foreach ( qw( node ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }
  foreach ( qw( blockfilter ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^[a-zA-Z0-9:.\-_/#*|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }

    my @reqfilter   = split(/\s*[, ]+/, $params{reqfilter});
    my $nodefilter  = $params{node};
    my $blockfilter = $params{blockfilter};
    my $state       = $params{state};

    print { $$self{CONTENT} }
    "<p class='blocktext'>",
    "This page shows the blocks which are queued for deletions.  The record of ",
    "completed block deletions is removed after three days.</p>",
    "<form class='nice' method='get' action='#'>",
    "<label class='inline'>Show deletions from requests </label>",
    textfield(-name=>'reqfilter', -size=>15, -class=>'labeled'),
    "<label class='inline'> at node </label>",
    textfield(-name=>'node', -default=>$nodefilter, -size=>15, -class=>'labeled'),
    "<label class='inline'> with state </label>",
    popup_menu(-name=>'state', -values=>['any', 'pending', 'complete'],
	       -default=>$state, -class=>'labeled'),
    "<label class='inline'> filter blocks </label>",
    textfield(-name=>'blockfilter', -default=>$blockfilter, -size=>15, -class=>'labeled'),
    " ", submit(-label=>'Update'),
    "</form><br clear='all'>";
    my @where = ('1=1');
    my %binds;
    my %all_nodes = $self->fetch_nodes(with_ids=>1);
    my @select_nodes;
    if ( $nodefilter =~ m%^!(.*)$% ) {
      $nodefilter = $1;
      @select_nodes = grep !/$nodefilter/, keys %all_nodes;
    } else {
      @select_nodes = grep  /$nodefilter/, keys %all_nodes;
    }
    if (! @select_nodes ) {
	$self->note('No nodes match the given filter');
	return;
    }

    if (scalar @select_nodes < scalar keys %all_nodes) {
	my $list;
	($list, %binds) = &dbinlist('node', map { $all_nodes{$_} } @select_nodes);
	push @where,"n.id in ($list)";
    }

    if (@reqfilter) {
	my ($l, %b) = &dbinlist('request', @reqfilter);
	push @where, "del.request in ($l)";
	$binds{$_} = $b{$_} for keys %b;
    }

    my $where = join ' and ', @where;

    my $sql = qq{ select del.request, n.name node, b.name block, b.files, b.bytes, del.time_request, del.time_complete
		      from t_dps_block_delete del
		      join t_dps_block b on b.id = del.block
		      join t_adm_node n on n.id = del.node
		      where $where
		      order by del.time_complete desc, del.time_request desc };
    

    my $q = &dbexec($$self{DBH}, $sql, %binds);
    
    my $dbtable = new Web25::DBTable;
    $dbtable->set_filehandle($$self{CONTENT});
    $dbtable->set_tableclass('data');
    $dbtable->set_stripeclass('stripe');

    $dbtable->set_tablehead({ 
	REQUEST => 'Request',
	NODE => 'Node',
	BLOCK => 'Block',
	FILES => 'Files',
	BYTES => 'Size',
	TIME_REQUEST => 'Requested',
	TIME_COMPLETE => 'Completed' });

    my $reqpage = $self->myurl(page => 'Request::View');
    $dbtable->set_dataformats({ 
	REQUEST => sub { return defined $_[0] ? "<a href='${reqpage}?request=$_[0]'>$_[0]</a>" : 'unknown'; },
	BYTES => sub { &format_size($_[0]) },
	TIME_REQUEST  => sub { &formatTime($_[0], 'stamp') },
	TIME_COMPLETE => sub { $_[0] ? &formatTime($_[0], 'stamp') : 'Pending' } });

    $dbtable->set_filters({
	'BLOCK' => sub { $_[0] =~ /$blockfilter/ ? 1 : 0 },
	'TIME_COMPLETE' => sub { return 1 if $state eq 'any';
				 return 1 if $state eq 'pending' && !defined $_[0];
				 return 1 if $state eq 'complete'&& defined $_[0];
				 return 0;
			     }
    });
    
    $dbtable->set_statcols({
	'FILES' => 'SUM',
	'BYTES' => 'SUM'
	});

    my $nrows = $dbtable->output($q);

    if ($nrows == 0) {
	$self->note("No results available.");
    }
    
}

1;

######################################################################
package Web25::Activity::FileInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 0, ORDER => 100, TITLE => "File Info" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(to_node from_node state);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Activity::FileInfo");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my %params = $self->validate_all
      (
       allow =>    [qw(to_node from_node state priority)],
       required => [qw(to_node from_node state priority)],
       spec  => 
       {
	   to_node   => { using => 'node' },
	   from_node => { using => 'node' },
	   state     => { allowing => [qw(exported transferring transferred assigned)] },
	   priority  => { using => 'pos_int' },
       }
       );


  my $to_node   = $params{to_node};
  my $from_node = $params{from_node};
  my $state     = $params{state};
  my $priority  = $params{priority};

  my $state_join = '';
  my $state_cols = 'NULL from_pfn, NULL to_pfn, NULL space_token,';
  my $state_where = '';
  if    ($state eq 'exported')     { 
      $state_join = 'join t_xfer_task_export ts on ts.task = xt.id'; 
      $state_where = 'and xt.id not in ( select task from t_xfer_task_inxfer )';
  } elsif ($state eq 'transferring') {
      $state_join = 'join t_xfer_task_inxfer ts on ts.task = xt.id'; 
      $state_cols = 'ts.from_pfn, ts.to_pfn, ts.space_token,';
      $state_where = 'and xt.id not in ( select task from t_xfer_task_done )';
  } elsif ($state eq 'transferred')  { 
      $state_join = 'join t_xfer_task_done ts on ts.task = xt.id'; }
  elsif ($state eq 'assigned') {
      $state_where = 'and xt.id not in ( select task from t_xfer_task_export )';
  } else {
      $self->alert('Invalid state');
  }
     
  my $sql = qq{
    select f.id, f.logical_name, f.filesize,
           $state_cols
	   xt.time_assign, err.cnt num_errors
      from t_xfer_task xt
      $state_join
      join t_xfer_file f on f.id = xt.fileid
      join t_adm_node ns on ns.id = xt.from_node
      join t_adm_node nd on nd.id = xt.to_node
      left join (select xe.fileid, xe.from_node, xe.to_node, count(*) cnt 
                   from t_xfer_error xe
                  group by xe.fileid, xe.from_node, xe.to_node
                 ) err 
           on     err.fileid = xt.fileid 
              and err.from_node= xt.from_node 
              and err.to_node = xt.to_node
    where ns.name = :from_node
      and nd.name = :to_node
      and xt.priority = :priority
      $state_where
      order by xt.time_assign, f.logical_name};

  my $query = &dbexec($$self{DBH}, $sql, 
		      ':from_node' => $from_node,
		      ':to_node' => $to_node,
		      ':priority' => $priority);
  print { $$self{CONTENT} }
    "<h1>Files $state from $from_node to $to_node.</h1>\n",
    "<ol align='left'>\n";
  while (my $row = $query->fetchrow_arrayref)
  {
    my ($fileid, $lfn, $size, $from_pfn, $to_pfn, $space_token, $assigned, $nerrors) = @$row;
    my $errorurl = $self->myurl('page' => 'Activity::ErrorInfo',
				'tofilter' => $to_node,
				'fromfilter' => $from_node,
				'fileid' => $fileid);
    print { $$self{CONTENT} }
    "<li><b>lfn</b>=@{[&escapeHTML($lfn)]}<br />",
    "<b>size</b>=$size<br />",
    ($from_pfn ? "<b>from_pfn</b>=@{[&escapeHTML($from_pfn)]}<br />" : ""),
    ($to_pfn ? "<b>to_pfn</b>=@{[&escapeHTML($to_pfn)]}<br />" : ""),
    ($space_token ? "<b>to_pfn</b>=@{[&escapeHTML($space_token)]}<br />" : ""),
    ($nerrors ? "<span class='alarm'><b>errors</b>=$nerrors</span> <a href='$errorurl'>(View)</a><br />"  : ""),
    ($assigned ? "<b>time_assign</b>=@{[strftime('%Y-%m-%d %H:%M:%S', gmtime($assigned))]} UTC<br />" : ""),
    "<br /></li>\n";
  }
  print { $$self{CONTENT} } "</ol></p>\n";
}

1;
######################################################################
package Web25::Activity::ErrorInfo;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 8, TITLE => "Recent Errors" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(tofilter fromfilter andor);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && ($args{"page"} ne "Activity::Rate" &&
			  $args{"page"} ne "Activity::TransferDetails" &&
			  $args{"page"} ne "Activity::ErrorInfo"));

  if ( !$args{page} or $args{page} eq 'Activity::ErrorInfo' ) {
    @save = qw(tofilter fromfilter andor report_code xfer_code from_pfn to_pfn log_detail log_validate);
  }
  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
    my ($self) = @_;
    my %params = $self->validate_all
	(
	 allow => [qw(page_num fileid tofilter fromfilter report_code xfer_code 
		      from_pfn to_pfn log_detail log_validate andor)],
	 spec  => 
	 {
	     page_num     => { using => 'pos_int'},
	     fileid       => { using => 'pos_int'},
	     tofilter     => { using => 'regex', default => '.*' },
	     fromfilter   => { using => 'regex', default => '.*' },
	     report_code  => { using => 'regex', default => '.*' },
	     xfer_code    => { using => 'regex', default => '.*' },
	     from_pfn     => { using => 'regex', default => '.*' },
	     to_pfn       => { using => 'regex', default => '.*' },
	     log_detail   => { using => 'regex', default => '.*' },
	     log_validate => { using => 'regex', default => '.*' },
	     andor	  => { using => 'andor' },
	 }
	 );
# Explicit checking of arguments
    foreach ( qw( report_code xfer_code ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} !~ m%^(-)?[0-9,.*]*$% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }
    foreach ( qw( from_filter to_filter ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }
    foreach ( qw( from_pfn to_pfn ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} !~ m%(^[a-zA-Z0-9:.\-_/=\?*]*$)?$% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }
    foreach ( qw( log_detail log_validate ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} =~ m%(\\|;)% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }
    my $fileid     = $params{fileid};
    my $tofilter   = $params{tofilter};
    my $fromfilter = $params{fromfilter};

    my @nodes = sort $self->fetch_nodes();

    my @where;
    my %binds;
    if ($fileid) {
	push @where, qq[xe.fileid = :fileid];
	$binds{':fileid'} = $fileid;
    } else {
	print {$$self{CONTENT}}
	&help("Filtering Help", "Filtering Help", 
	      "The <b>to</b> and <b>from</b> node filters are perl regular expressions.  ",
	      "The rest of the filters are Oracle regular expressions (regexp_like function) ",
	      "with one special option: You may put '!' as the first ",
	      "character in the field to only return results which do ",
	      "NOT match the given regular expession.  For performance ",
	      "reasons, you must filter one of <b>to</b> or <b>from</b> ",
	      "if you wish to filter on any of the other fields.  The ",
	      "<b>Transfer Log</b> cannot be ", "filtered due to its ",
	      "large size."),
   	"<form method='get' action='#' class='nice'>",
	"<label>Show errors on links to </label>",
	textfield(-name=>'tofilter', -value=>$tofilter, -class=>'labeled'),
	"<label>from</label>",
	textfield(-name=>'fromfilter', -value=>$fromfilter, -class=>'labeled'), "<br/>",
	"<label>Report Code:</label>",
	textfield(-name=>'report_code', -value=>$params{report_code}, -class=>'labeled'),
	"<label>Transfer Code:</label>",
	textfield(-name=>'xfer_code', -value=>$params{xfer_code}, -class=>'labeled'), "<br/>",
	"<label>To PFN:</label>",
	textfield(-name=>'to_pfn', -value=>$params{to_pfn}, -class=>'labeled'),
	"<label>From PFN:</label>",
	textfield(-name=>'from_pfn', -value=>$params{from_pfn}, -class=>'labeled'), "<br/>",
	"<label>Detail Log:</label>",
	textfield(-name=>'log_detail', -value=>$params{log_detail}, -class=>'labeled'),
	"<label>Validate Log:</label>",
	textfield(-name=>'log_validate', -value=>$params{log_validate}, -class=>'labeled'), "<br/>",
	"<label>&nbsp;</label>", submit(-label=>'Update', -class=>'labeled'), "<br/>",
	"</form>";
    }

    my @from = grep /$fromfilter/, @nodes;

    if (! @from ) {
        $self->note('No nodes match the given "from-node" filter');
        return;
    }

    if (scalar @from != scalar @nodes) {
	my ($from_list, %from_binds) = &dbinlist('from', @from);
	push @where, "ns.name in ($from_list)";
	$binds{$_} = $from_binds{$_} foreach (keys %from_binds);
    }
    my @to = grep /$tofilter/, @nodes;

    if (! @to ) {
        $self->note('No nodes match the given "to-node" filter');
        return;
    }

    if (scalar @to != scalar @nodes) {
	my ($to_list, %to_binds) = &dbinlist('to', @to);
	push @where, "nd.name in ($to_list)";
	$binds{$_} = $to_binds{$_} foreach (keys %to_binds);
    }

    my @filter_list = qw(report_code xfer_code from_pfn to_pfn log_detail log_validate);
    foreach my $col (@filter_list) {
	my $f = $params{$col};
	my $not = substr($f, 0, 1) eq '!' ? 'not ' : '';
	$f = substr($f, 1) if $not;
	next if !defined $f || $f eq '' || $f eq '.*';
	my $bind_label = ":${col}_rxp";
	push @where, "${not}regexp_like($col, $bind_label)";
	$binds{$bind_label} = $f;
    }

    my $where = @where ? " where ".join(' and ', @where) : '';

    # Make sure the nodes are filtered if we are filtering with regexp_like
    # TODO:  Remove these restrictions with error pre-processing
    if ($where =~ /regexp_like/ &&
	($where !~ /nd.name|ns.name/ ||
	 $where =~ /ns.name in/ && scalar @from > 5 ||
	 $where =~ /nd.name in/ && scalar @to > 5)) {
	$self->alert("You must reduce the number of links you search  if you wish to use the other ",
		     "filters.  Filter also on link <b>to</b> or <b>from</b>.");
	return;
    }

    my $sql = qq{ select ns.name from_node, nd.name to_node,
		         time_assign, time_expire, time_export, time_inxfer, time_xfer, time_done,
		         report_code, xfer_code, from_pfn, to_pfn, space_token,
		         log_xfer, log_detail, log_validate
		    from t_xfer_error xe
                    join t_adm_node nd on nd.id = xe.to_node
		    join t_adm_node ns on ns.id = xe.from_node
                  $where
		order by time_done desc
	    };

    my $max_log_length = 100_000;
    $$self{DBH}->{LongReadLen} = $max_log_length;
    $$self{DBH}->{LongTruncOk} = 1;

    my $pager = new Web25::QueryPager;
    $pager->init($self, $sql, {%binds}, 10);
    my $n_errors = $pager->get_total_results();

    if ($fileid) {
	my $alllink = $self->myurl('fromfilter' => $fromfilter, 'tofilter' => $tofilter);
	print {$$self{CONTENT}}
	"<p><a href='$alllink'>Show all errors for this link</a></p>";
    } else {
	print {$$self{CONTENT}} 
	"<h1>$n_errors recent errors on links to ", &escapeHTML($tofilter), 
	" from ", &escapeHTML($fromfilter), "</h1>";
    }

    if ($n_errors >= 100) {
	print {$$self{CONTENT}} 
	"<p>Please note that PhEDEx only stores the last 100 link errors to the database ",
	"for a limited period of time. More errors may have occurred that are not visible here.</p>"
    }

    print {$$self{CONTENT}} $pager->pager();

    my $q = $pager->paged_result();

    my $time_labels = { TIME_ASSIGN => "Time Assigned",
			TIME_EXPORT => "Time Exported",
			TIME_INXFER => "Time Pumped",
			TIME_XFER   => "Time Transfer Start",
			TIME_DONE   => "Time Transfer Done",
			TIME_EXPIRE => "Time Transfer Expires" };

    my $log_labels = { LOG_XFER => "Transfer Log",
		       LOG_DETAIL => "Detail Log",
		       LOG_VALIDATE => "Validate Log" };

    my $now = time();
    ERROR: while (my $error = $q->fetchrow_hashref()) {
	print { $$self{CONTENT} }
	"<div class='nice errorinfo'>",
	"<h1>Error $$error{RESULT_NUMBER}</h1>";

	print { $$self{CONTENT} }
	"<label>To Node:</label><span class='labeled halfwidefield'>$$error{TO_NODE}</span>",
	"<label>From Node:</label><span class='labeled halfwidefield'>$$error{FROM_NODE}</span><br/>";

	my $time_assign = $$error{TIME_ASSIGN};
	my $tn = 0;
	foreach my $time (qw(TIME_ASSIGN TIME_XFER TIME_EXPORT TIME_DONE TIME_INXFER TIME_EXPIRE)) {
	    my $timestamp   = &formatTime($$error{$time}, 'stamp');
	    my $diff_assign = &age($$error{$time} - $time_assign, 'second');
	    my $diff_now    = &age($$error{$time} - $now, 'second');

	    print { $$self{CONTENT} }
	    "<label>$$time_labels{$time}:</label><span class='labeled halfwidefield'>", 
	    ($timestamp ? ($timestamp,
			   " <span class='diff_assigned'>($diff_assign since assigned)</span> ",
			   " <span class='diff_now'>($diff_now from now)</span>") :
	     $$error{$time} ),
	     "</span>",
	     (++$tn % 2 == 0 ? "<br/>" : '');
	}

	$$error{SPACE_TOKEN} ||= '(none)';
	print { $$self{CONTENT} }
	"<hr/>",
	"<label>Report Code:</label><span class='labeled halfwidefield'>$$error{REPORT_CODE}</span>",
	"<label>Transfer Code:</label><span class='labeled halfwidefield'>$$error{XFER_CODE}</span><br/>",
	"<hr/>",
	"<label>To PFN:</label><span class='labeled'>$$error{TO_PFN}</span><br/>",
	"<label>From PFN:</label><span class='labeled'>$$error{FROM_PFN}</span><br/>",
	"<label>Space Token:</label><span class='labeled'>$$error{SPACE_TOKEN}</span><br/>",
	"<hr/>";

	foreach my $log (qw(LOG_XFER LOG_DETAIL LOG_VALIDATE)) {
	    if (! defined $$error{$log} ) { $$error{$log} = ''; }
	    my $chars = length $$error{$log};
	    my $trunc = ($chars == $max_log_length ? "<br/><span class='alarm'>Truncated</span>" : '');
	    $$error{$log} =~ s/\s*$/\n/;
	    my $lines = ($$error{$log} =~ tr/\n/\n/);
	    $lines = 0 if $chars == 0;
  
	    my $logmsg = &escapeHTML($$error{$log});
	    $logmsg = join('<br />',split("\n",$logmsg));
	    print { $$self{CONTENT} }
	    "<label>$$log_labels{$log}:<br/><span class='note'>($lines lines)<br/>($chars chars)$trunc</span></label>",
	    "<div class='labeled logbox'>$logmsg</div><br/>";	    
 	}
	print { $$self{CONTENT} } "</div>";
    }
    print {$$self{CONTENT}} $pager->pager();
}

1;

######################################################################
package Web25::Activity::Latency;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);

#our $INDEX = { LIST => 1, ORDER => 9, TITLE => "Latency",
#	       LINK_TITLE => "Show block & file latency information" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

#sub myurl
#{
#  my ($self, %args) = @_;
#  my @save = qw(tofilter fromfilter andor);
#
#  # Return bare link if we are switching pages
#  return $self->SUPER::myurl(%args)
#    if ($args{"page"} && ($args{"page"} ne "Activity::Latency"));
#
#  if ( !$args{page} or $args{page} eq 'Activity::Latency' ) {
#    @save = qw(tofilter fromfilter blockfilter priority);
#  }
#  # Keep my if remaining on the same page (but e.g. different instance)
#  return $self->SUPER::myurl($self->urlparams(@save), %args);
#}

sub output
{
  my ($self) = @_;
#  my %params = $self->validate_all
#      (
#       allow => [qw(tofilter fromfilter blockfilter priority)],
#       spec  => 
#       {
#	   tofilter    => { using => 'regex', default => '.*' },
#	   fromfilter  => { using => 'regex', default => '.*' },
#	   blockfilter => { using => 'regex', default => '.*' },
#	   priority    => { allowing => [qw(any high normal low)],
#			    default   => 'any' },
#       }
#       );
## Explicit checking of arguments
#  foreach ( qw( blockfilter ) ) {
#    if ( $params{$_} ) {
#      $params{$_} = unescape($params{$_});
#      if ( $params{$_} ne '.*' &&
#           $params{$_} !~ m%^[a-zA-Z0-9:.\-_/#*|]*$% ) {
#        die("The $_ parameter (foo) to bar did not pass");
#      }
#    }
#  }
#  foreach ( qw( fromfilter tofilter ) ) {
#    if ( $params{$_} ) {
#      $params{$_} = unescape($params{$_});
#      if ( $params{$_} ne '.*' &&
#           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
#        die("The $_ parameter (foo) to bar did not pass");
#      }
#    }
#  }
#
#  my $tofilter    = $params{tofilter};
#  my $fromfilter  = $params{fromfilter};
#  my $priority    = $params{priority};
#  my $blockfilter = $params{blockfilter};
#
#  my $now = time();
#  my @nodes = sort $self->fetch_nodes();

  print {$$self{CONTENT}} "<div id='Activity::Latency'></div>";
}

1;

######################################################################
package Web25::Data::ExplorePage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);
use Sort::Key::Natural;
use Sort::Key::Maker sort_dbs =>
  sub { $$_{LABEL}, ($$_{BASE} || ''), $$_{ID} }, qw(nat nat int);
use Sort::Key::Maker sort_dataset_dbs =>
  sub { $$_{DBS}{LABEL}, ($$_{DBS}{BASE}||''), $$_{DBS}{ID}, $$_{NAME}, $$_{ID} },
  qw(nat nat int nat int);
use Sort::Key::Maker sort_name_id =>
  sub { $$_{NAME}, $$_{ID} }, qw(nat int);
use Sort::Key::Maker sort_name =>
  sub { $$_{NAME} }, qw(nat);

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  $$self{SAVE_DB}   = [ qw(filter dcolumn rcolumn nvalue scolumn rows) ];
  $$self{SAVE_PAGE} = [ @{$$self{SAVE_DB}}, qw(dbs node dexp bexp) ];
  bless $self, $class;
  return $self;
}

sub init
{
    my $self = shift @_;

    # build the dbs list
    $$self{DBS_LIST} = [ sort_dbs $self->dbs_list() ];

    # build the node list
    $$self{NODE_LIST} = [ sort_name $self->node_list() ];

    # build the group list
    $$self{GROUP_LIST} = [sort grep(!/^deprecated-/, $self->fetch_groups()) ];
    
    # Data columns
    $$self{DCOLUMN_NAMES} = [ qw(DBS Name Blocks Files Bytes Open Transient Id) ];
    $$self{DCOLUMN} = { "DBS" => 0, "Name" => 1, "Blocks" => 0, "Files" => 1,
			"Bytes" => 1, "Open" => 0, "Transient" => 0, "Id" => 0 };
    
    # Replica columns
    $$self{RCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
    $$self{RCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };

    # Subscription columns
    $$self{SCOLUMN_NAMES} = [ qw(DBS Name Files Bytes Source) ];
    $$self{SCOLUMN} = { "DBS" => 0, "Name" => 1, "Files" => 0, "Bytes" => 0, "Source" => 0 };

    # Node column values
    $$self{NVALUES} = [ "Node blocks", "Node files", "Node bytes",
			"Destined blocks", "Destined files", "Destined bytes",
			"Missing blocks", "Missing files", "Missing bytes",
			"% Complete (files)", "% Complete (bytes)"
			];

}

sub myurl
{
  my ($self, %args) = @_;

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"}
        && $args{"page"} ne "Data::Replicas"
        && $args{"page"} ne "Data::Subscriptions"
	&& $args{"page"} ne "Data::LoadTestInject");

  # If we stay in the same database, keep all, otherwise strip off db-specific
  my @save = $args{"db"} && $args{"db"} ne $$self{DBID}
    ? @{$$self{SAVE_DB}} : @{$$self{SAVE_PAGE}};

  # Return a URL with saved parameters
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub saveform
{
  my ($self, @omit) = @_;
  my $result = "";
  foreach my $option ('view', @{$$self{SAVE_PAGE}})
  {
    next if grep($option eq $_, @omit) || !defined param($option);
    if ($option eq 'nvalue')
    {
      $result .= "<input type='hidden' name='$option' value='$$self{NVALUE}' />";
    }
    elsif (grep($option eq $_, qw(dcolumn rcolumn scolumn)))
    {
      $result .= "<input type='hidden' name='$option' value='$_' />"
	for grep($$self{uc($option)}{$_}, param($option));
    }
    elsif (grep($option eq $_, qw(dbs node dexp bexp)))
    {
      $result .= "<input type='hidden' name='$option'"
		 . " value='@{[&escapeHTML($_)]}' />"
	for param($option);
    }
    else
    {
      $result .= "<input type='hidden' name='$option'"
	  . " value='@{[&escapeHTML(param($option))]}' />";
    }
  }

  return $result;
}

sub dbs_list
{
  my ($self) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select id, name, dls from t_dps_dbs
    order by name asc});

  my (%bases, @result);
  while (my ($id, $name, $dls) = $q->fetchrow())
  {
    # Build DBS object
    my $dbs = { ID => $id, URL => $name, DLS => $dls,
		BASE => undef, LABEL => $name };
    if ($name =~ /^(http.*)\?instance=(.*)/)
    {
      $$dbs{BASE} = $1;
      $$dbs{LABEL} = $2;
      $$dbs{LABEL} =~ s,/Writer$,,;
    }

    # Add HTML-formatted data
    my $htmllabel = &escapeHTML($$dbs{LABEL});
    my $htmldls = &breakAtSlash(&escapeHTML($$dbs{DLS}));
    my $suplink = "";
    if ($$dbs{BASE})
    {
      $bases{$$dbs{BASE}} = scalar(keys %bases) + 1
	if ! exists $bases{$$dbs{BASE}};
  
      $$dbs{BASE_ID} = $bases{$$dbs{BASE}};
      $suplink = "<sup><small>$$dbs{BASE_ID}</small></sup>";
    }
    $$dbs{HTML_DBS} = "$htmllabel$suplink";
    $$dbs{HTML_DLS} = $htmldls || '&nbsp;';

    # Add to the result
    push(@result, $dbs);
  }

  $q->finish();
  return @result;
}

sub dataset_list
{
  my ($self, @dbses) = @_;
  my $q = &dbprep($$self{DBH}, qq{
    select ds.id, ds.name, ds.is_open, ds.is_transient,
           nvl(count(b.id),0), nvl(sum(b.files),0), nvl(sum(b.bytes),0)
    from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
    where dbs = :dbsid
    group by ds.id, ds.name, ds.is_open, ds.is_transient
    order by ds.name asc});

  my @result = ();
  foreach my $dbs (@dbses)
  {
    &dbbindexec($q, ":dbsid" => $$dbs{ID});
    while (my ($id, $name, $open, $transient, $nblocks, $nfiles, $nbytes) = $q->fetchrow())
    {
      push(@result, {
	DBS => $dbs,
	ID => $id,
	NAME => $name,
	IS_OPEN => $open,
	IS_TRANSIENT => $transient,
	BLOCKS => $nblocks,
	FILES => $nfiles,
	BYTES => $nbytes });
    }
    $q->finish();
  }

  return @result;
}

sub dataset_replicas
{
  my ($self, @datasets) = @_;

  # "where in" lists are limited to 1000 entries
  my ($where, %binds) = ("", ());
  if (scalar @datasets < 1000) {
      my $list;
      ($list, %binds) = &dbinlist('dataset', map { $$_{ID} } @datasets);
      $where = " where ds.id in ($list) ";
  }

  my $q = &dbexec($$self{DBH}, qq{
    select ds.id dataset, n.id node,
           nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
           nvl(sum(br.dest_files),0) dest_files,
           nvl(sum(br.dest_bytes),0) dest_bytes,
           nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
           nvl(sum(br.node_files),0) node_files,
           nvl(sum(br.node_bytes),0) node_bytes
      from t_dps_dataset ds
      join t_dps_block b on b.dataset = ds.id
      join t_dps_block_replica br on br.block = b.id
      join t_adm_node n on n.id = br.node
      $where
     group by ds.id, n.id}, %binds);

  my %byid = map { $$_{ID} => $_ } @datasets;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{DATASET}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_list
{
  my ($self, $dataset) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, b.name, b.is_open, b.files, b.bytes
    from t_dps_block b where b.dataset = :dsid},
    ":dsid" => $$dataset{ID});

  my @result = ();
  while (my ($id, $name, $open, $nfiles, $nbytes) = $q->fetchrow())
  {
    push(@result, {
      DATASET => $dataset,
      ID => $id,
      NAME => $name,
      IS_OPEN => $open,
      BLOCKS => 1,
      FILES => $nfiles,
      BYTES => $nbytes });
  }

  $q->finish();
  return @result;
}

sub file_list
{
  my ($self, $block) = @_;
  my $q = &dbexec($$self{DBH}, qq{
    select f.id, f.logical_name, f.filesize, n.name
    from t_dps_file f join t_adm_node n on n.id = f.node
    where inblock = :bid},
    ":bid" => $$block{ID});

  my @result = ();
  while (my ($id, $name, $size, $source) = $q->fetchrow())
  {
    push(@result, {
      BLOCK => $block,
      SOURCE => $source,
      ID => $id,
      NAME => $name,
      SIZE => $size });
  }

  $q->finish();
  return @result;
}

sub block_replicas
{
  my ($self, @blocks) = @_;
  my %datasets = map { $$_{DATASET}{ID} => 1 } @blocks;
  my ($list, %binds) = &dbinlist('ds', keys %datasets);
  my $q = &dbexec($$self{DBH}, 
		  qq{ select b.id block, br.node node,
                        nvl(sum(case when br.dest_files > 0 then 1 else 0 end),0) dest_blocks,
                        nvl(sum(br.dest_files),0) dest_files,
                        nvl(sum(br.dest_bytes),0) dest_bytes,
                        nvl(sum(case when br.node_files > 0 then 1 else 0 end),0) node_blocks,
                        nvl(sum(br.node_files),0) node_files,
                        nvl(sum(br.node_bytes),0) node_bytes
                      from t_dps_block b
                      join t_dps_block_replica br on br.block = b.id
                     where b.dataset in ($list)
                     group by b.id, br.node}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my $row = $q->fetchrow_hashref())
  {
    $byid{$$row{BLOCK}}{REPLICAS}{$$row{NODE}} = $row;
  }

  $q->finish ();
}

sub block_sources
{
  my ($self, @blocks) = @_;
  my %datasets = map { $$_{DATASET}{ID} => 1 } @blocks;
  my ($list, %binds) = &dbinlist('ds', keys %datasets);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id, f.node, n.name
    from t_dps_block b
      join t_dps_file f on f.inblock = b.id
      join t_adm_node n on n.id = f.node
    where b.dataset in ($list)
    group by b.id, f.node, n.name}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $node, $name) = $q->fetchrow())
  {
    $byid{$block}{SOURCES}{$node} = $name;
    $byid{$block}{DATASET}{SOURCES}{$node} = $name;
  }

  $q->finish ();
}

sub file_replicas
{
  my ($self, @blocks) = @_;
  my ($list, %binds) =  &dbinlist('block', map { $$_{ID} } @blocks);
  my $q = &dbexec($$self{DBH}, qq{
    select b.id block, f.id, 
           case when br.is_active = 'n' then br.node
                else xr.node
            end node
    from t_dps_block b
    join t_dps_block_replica br on br.block = b.id
    join t_dps_file f on f.inblock = b.id
    left join t_xfer_replica xr on xr.fileid = f.id
   where b.id in ($list)}, %binds);

  my %byid = map { $$_{ID} => $_ } @blocks;
  while (my ($block, $file, $node) = $q->fetchrow())
  {
    $byid{$block}{FILE_REPLICAS}{$file}{$node} = 1;
  }

  $q->finish ();
}

sub node_list
{
  my ($self) = @_;

  my @result = ();
  my %nodes = $self->fetch_nodes(with_ids=>1);
  while (my ($name, $id) = each %nodes) {
    push(@result, { ID => $id, NAME => $name });
  }

  return @result;
}

sub apply_options
{
  my ($self) = @_;

  # Determine which dataset options we are showing (in dataset mode)
  if (defined param('dcolumn'))
  {
    $$self{DCOLUMN}{$_} = 0 for keys %{$$self{DCOLUMN}};
    $$self{DCOLUMN}{$_} = 1 for grep(exists $$self{DCOLUMN}{$_}, param('dcolumn'));
  }

  # Determine which replica options we are showing (in replica mode)
  if (defined param('rcolumn'))
  {
    $$self{RCOLUMN}{$_} = 0 for keys %{$$self{RCOLUMN}};
    $$self{RCOLUMN}{$_} = 1 for grep(exists $$self{RCOLUMN}{$_}, param('rcolumn'));
  }

  # Determine which replica options we are showing (in subscription mode)
  if (defined param('scolumn'))
  {
    $$self{SCOLUMN}{$_} = 0 for keys %{$$self{SCOLUMN}};
    $$self{SCOLUMN}{$_} = 1 for grep(exists $$self{SCOLUMN}{$_}, param('scolumn'));
  }

  # Determine which replica value we show (in replica mode)
  $$self{NVALUE} = param('nvalue') || "Node files";
  $$self{NVALUE} = "Node files" if !grep($$self{NVALUE} eq $_, @{$$self{NVALUES}});

  # Determine if we are showing all or interesting rows
  $$self{ROWS} = param('rows') || 'all';
  $$self{ROWS} = 'all' if !grep($$self{ROWS} eq $_, qw(all interesting));

  # Determine which nodes we show
  my %nodesel;
  if (defined param('node')) {
      %nodesel = (map { $_ => 1 } param('node'));
  } else {
      my %auth_nodes = reverse $self->fetch_nodes(web_user_auth => 'Data Manager||Site Admin', with_ids => 1);
      if (%auth_nodes && scalar keys %auth_nodes <= 5) {
	  %nodesel = (map { $_ => 1 } keys %auth_nodes);
      } else {
	  %nodesel = (map { $$_{ID} => 1 } grep($$_{NAME} =~ /CERN/, @{$$self{NODE_LIST}}));
      }
  }
  $$self{NODE_SHOWN} = [ grep($nodesel{$$_{ID}}, @{$$self{NODE_LIST}}) ];
  $$_{IS_SHOWN} = 1 for @{$$self{NODE_SHOWN}};
  
}

sub fetch_data
{
  my ($self) = @_;

  # Obtain the list of DBSes, sort them and pick the ones we show.
  my %shown = map { $_ => 1 } param('dbs');

  if (keys %shown)
  {
    $$self{DBS_SHOWN} = [ grep(exists $shown{$$_{ID}}, @{$$self{DBS_LIST}}) ];
  }
  else
  {
    $$self{DBS_SHOWN} = $$self{DBS_LIST};
  }

  $$_{IS_SHOWN} = 1 for @{$$self{DBS_SHOWN}};

  # Bail out if there is no filter
  my ($filter) = $self->output_filter();
  return if ! defined $filter || $filter eq '' || $filter =~ /^Enter dataset/;
  

  # Now get a sorted list of the datasets we are interested in
  my @datasets = grep($$_{NAME} =~ /$filter/,
		      $self->dataset_list(@{$$self{DBS_SHOWN}}));
  if ($$self{DCOLUMN}{"DBS"})
  {
    $$self{DATASET_LIST} = [ sort_dataset_dbs @datasets ];
  }
  else
  {
    $$self{DATASET_LIST} = [ sort_name_id @datasets ];
  }

  # Fetch blocks and block replicas
  my %dexpand = map { $_ => 1 } param('dexp');
  my %bexpand = map { $_ => 1 } param('bexp');
  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    if (! $dexpand{$$ds{ID}})
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ $$ds{ID}, param('dexp') ]) .
        "#d$$ds{ID}'>&#187;</a>";
    }
    else
    {
      $$ds{EXPAND_LINK} =
        "<a href='" .
        $self->myurl('dexp' => [ grep($_ != $$ds{ID}, param('dexp')) ]) .
        "#d$$ds{ID}'>&#171;&#171;</a>";
    }

    # Pass if not expanded
    next if ! $dexpand{$$ds{ID}};

    # Expanded, obtain block list
    $$ds{BLOCK_LIST} = [ sort_name $self->block_list($ds) ];
    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      if (! $bexpand{$$block{ID}})
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ $$block{ID}, param('bexp') ]) .
          "#b$$block{ID}'>&#187;</a>";
      }
      else
      {
        $$block{EXPAND_LINK} =
          "<a href='" .
          $self->myurl('bexp' => [ grep($_ != $$block{ID}, param('bexp')) ]) .
          "#b$$block{ID}'>&#171;&#171;</a>";
      }

      # Pass if not expanded
      next if ! $bexpand{$$block{ID}};

      # Expanded, obtain file list
      $$block{FILE_LIST} = [ sort_name $self->file_list($block) ];
    }
  }

  # Fetch per-node replicas for datasets, blocks and files in expanded view
  if (ref ($self) !~ /Datasets/)
  {
    $self->dataset_replicas(@{$$self{DATASET_LIST}})
      if @{$$self{DATASET_LIST}};

    my @allblocks = map { @{$$_{BLOCK_LIST}} } grep($$_{BLOCK_LIST}, @{$$self{DATASET_LIST}});

    $self->block_replicas(@allblocks)
      if @allblocks;

    $self->block_sources(@allblocks)
      if (@allblocks
	  && ((ref ($self) =~ /::Replicas/ && $$self{RCOLUMN}{"Source"})
	      || (ref ($self) =~ /::Subs/ && $$self{SCOLUMN}{"Source"})));

    my @expblock = grep($bexpand{$$_{ID}}, @allblocks);
    $self->file_replicas(@expblock) if @expblock;
  }
}


sub dbs_form
{
    my ($self) = @_;

    my $form = "";
    $form .= "<div id='dbschoice'>\n";
    $form .= "  <div id='dbsmenu' style='width:100%;font-size:0.9em'>\n";
    $form .= "    <table>\n";
    $form .= "     <thead>\n";
    $form .= "      <tr>\n";
    $form .= "       <th width='4%' align='center'>Show</th>\n";
    $form .= "       <th width='20%' align='left'>DBS</th>\n";
    $form .= "       <th width='100%' align='left'>DLS contact</th>\n";
    $form .= "       <th width='4%' align='right'>Id</th>\n";
    $form .= "      </tr>\n";
    $form .= "     </thead>\n";
    $form .= "     <tbody>\n";

    my $n = 0;
    foreach my $dbs (@{$$self{DBS_LIST}})
    {
	my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
	$form .= "      <tr$rowcolor>\n";
	$form .= "       <td align='center'><input type='checkbox' name='dbs' value='$$dbs{ID}'";
	$form .= ($$dbs{IS_SHOWN} ? " checked='checked'" : '') . " /></td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DBS}</td>\n";
	$form .= "       <td align='left'>$$dbs{HTML_DLS}</td>\n";
	$form .= "       <td align='right' style='color:#666'>$$dbs{ID}</td>\n";
	$form .= "      </tr>\n";
    }
    $form .= "     </tbody>\n";
    $form .= "    </table>\n";
    $form .= "  </div>\n";
    $form .= "</div>\n";
    return $form;
}

sub node_form
{
  my ($self) = @_;

  my $form = "";

  $form .= "<div id='nodechoice'>\n";
  $form .= "<input type='button' value='Select all' onclick=\"select_all('nodechoice', 'node', '1')\"/>\n",
  $form .= "<input type='button' value='Select none' onclick=\"select_all('nodechoice', 'node', '0')\"/>\n",

  my (@all, @columns) = @{$$self{NODE_LIST}};
  my $percolumn = int(scalar(@all)/4 + 0.5);
  $percolumn = 4 if ! $percolumn;
  push (@columns, [ splice(@all, 0, $percolumn) ]) while @all;

  $form .= "  <div id='nodemenu' style='font-size:0.9em'>\n";
  $form .= "    <table style='white-space:  nowrap;'>\n";
  $form .= "     <tbody>\n";
  $form .= "      <tr>\n";

  foreach my $col (@columns)
  {
      $form .= "       <td>\n";
      $form .= join("\n", (map { "        <input type='checkbox' name='node' value='$$_{ID}'" .
				     ($$_{IS_SHOWN} ? " checked='checked'" : "") .
				     " />&nbsp;" . &escapeHTML($$_{NAME}) . "<br />" }
			   @$col));
      $form .= "       </td>\n";
  }
  
  $form .= "     </tr>\n";
  $form .= "    </tbody>\n";
  $form .= "   </table>\n";
  $form .= " </div>\n";
  $form .= "</div>\n";
  return $form;
}


sub columns_form
{
    my ($self, @display_columns) = @_;

    my $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Display Columns</i></p>\n";
    foreach my $pair (@display_columns)
    {
	my ($dataset, $column) = @{$pair};

	$form .= "   <input type='checkbox' name='$dataset' value='$column'" .
	    ($$self{uc($dataset)}{$column} ? " checked='checked'" : "") .
	    " />&nbsp;$column<br/>\n";
    }
    
    return $form;
}

sub output_filter
{
  my ($self) = @_;
  my $filter = param('filter');
  if ($filter) { $filter =~ s/^\s+//; $filter =~ s/\s+$//; }

  my $filterform = "" .
    "<form style='display:inline' method='get' action='@{[$self->myurl()]}'>" .
    $self->saveform('filter') .
    textfield(-name=>'filter', -default=>($filter or "Enter dataset or regular expression"), -size=>60 ) .
    " <input type='submit' value='Filter' />" .
     &help("[?]", 'Filtering',
	   'Enter a dataset name or perl regular expression.  ',
	   'To show all datasets, enter ".*"') .
    "</form>";

  return ($filter, $filterform);
}

sub validate
{
  my $self = shift;
  # Note: the Data::Explore subclasses pass around a large set or
  # parameters between them to maintain state.  This requires us to
  # validate them all here, or to have a very similar validation in
  # multiple pages.  We choose the former.
  my %params = $self->validate_all
	(
	 allow => [qw(node dcolumn rcolumn scolumn nvalue rows dbs dexp bexp filter
		      col subsaction reqfilter priority suspended custodial group
		      groupchange s_value action actionvalue create_source create_dest rate lp_id)],
	 spec  => 
	 {
	     # Params for Data::Replicas
	     node         => { using => 'node',  multiple => 1 },
	     dcolumn      => { allowing => $$self{DCOLUMN_NAMES}, multiple => 1 },
	     rcolumn      => { allowing => $$self{RCOLUMN_NAMES}, multiple => 1 },
	     scolumn      => { allowing => $$self{SCOLUMN_NAMES}, multiple => 1 },
	     nvalue       => { allowing => $$self{NVALUES} },
	     rows         => { allowing => [qw(all interesting)] },
	     dbs          => { allowing => [(map { $$_{ID} } @{$$self{DBS_LIST}})], multiple => 1 },
	     dexp         => { using => 'pos_int', multiple => 1 },
	     bexp         => { using => 'pos_int', multiple => 1 },
	     filter       => { using => 'regex' },
	     col          => { regex => '^[A-Za-z_ ]+$', multiple => 1 },

	     # params for Data::Subscriptions
	     subsaction   => { allowing => [qw(suspend unsuspend priorityhi prioritymd prioritylo groupchange)]},
	     reqfilter    => { using => 'pos_int_list' },
  	     priority     => { allowing => [qw(any high normal low)], default => 'any' },
 	     suspended    => { allowing => [qw(any y n active suspended)], default => 'any' },
 	     custodial    => { allowing => [qw(any y n custodial non-custodial)], default => 'any' },
 	     complete     => { allowing => [qw(any y n complete incomplete)], default => 'any' },
 	     collapse     => { allowing => [qw(y n)], default => 'y' },
 	     group        => { allowing => ['any', @{$$self{GROUP_LIST}}], default => 'any' },
	     groupchange  => { allowing => $$self{GROUP_LIST} },
	     s_value  => { regex => qr%^(DATASET|BLOCK):(/[^/\#]+){3}[^:]*:T%, multiple => 1 }, # combined name, for 4.0 schema updates
	     create_since => { regex => '^-?[0-9]+(d|D|m|M|y|Y)?$' },

	     # params for Data::LoadTest
	     action        => { allowing => [qw(rate inject_now start stop remove)] },
#	     actionvalue   => { ... }, # varies according to action
	     create_source => { using => 'create_source' },
	     create_dest   => { using => 'create_dest' },
	     rate          => { using => 'pos_float' },
	     inject_now    => { using => 'pos_int' },
	     lp_id	   => { using => 'loadtestp_id', multiple => 1 } # combined ID
	 }
	 );
# Explicit checking of arguments
    foreach ( qw( filter ) ) {
      if ( $params{$_} ) {
        $params{$_} = unescape($params{$_});
        if ( $params{$_} ne '.*' &&
             $params{$_} !~ m%!?[_,A-Z,a-z,0-9, .*()|]% ) {
          die("The $_ parameter (foo) to bar did not pass");
        }
      }
    }
    my $nodes_allowed;
    foreach ( @{$self->{NODE_LIST}} ) {
      $nodes_allowed->{$_->{ID}} = $nodes_allowed->{$_->{NAME}} = 1;
    }
    if ( $params{node} ) {
      if ( ref($params{node}) eq 'ARRAY' ) {
        foreach ( @{$params{node}} ) {
          $nodes_allowed->{$_} or die("The $_ parameter (foo) to bar did not pass");
        }
      } else {
        $nodes_allowed->{$params{node}} or die("The $params{node} parameter (foo) to bar did not pass");
      }
    }

  return $$self{PARAMS} = \%params;
}


sub output
{
  my ($self) = @_;

  # Apply form options and fetch the data we show on this form
  $self->init();
  $self->validate();
  $self->apply_options();
  $self->output_page();
  $self->output_options_form();
}

1;

######################################################################
package Web25::Data::Replicas;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Replicas",
	       LINK_TITLE => "Explore replicas" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  $self->fetch_data(); # puts all data into $self

  my ($filter, $filterform) = $self->output_filter();

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $node_th = $$self{NVALUE};
  $node_th =~ s/Node\s+//;
  $node_th =~ s/ +/\&nbsp;/g;
  $node_th = ucfirst($node_th);

  print { $$self{CONTENT} }
    "<table>\n",
    " <thead>\n",
    "  <tr bgcolor='#f8f8f8'>\n",
    "   <th width='1%' align='left'>&nbsp;</th>\n",
    ($$self{RCOLUMN}{"DBS"}       ? "   <th width='10%' align='left'>DBS</th>\n" : ()),
    ($$self{RCOLUMN}{"Name"}      ? "   <th width='100%' align='left'>Name&nbsp;&nbsp;$filterform</th>\n" : ()),
    ($$self{DCOLUMN}{"Blocks"}    ? "   <th width='4%' align='center'>Blocks</th>\n" : ()),
    ($$self{RCOLUMN}{"Files"}     ? "   <th width='6%' align='right'>Files</th>\n" : ()),
    ($$self{RCOLUMN}{"Bytes"}     ? "   <th width='6%' align='right'>Bytes</th>\n" : ()),
    ($$self{RCOLUMN}{"Source"}    ? "   <th width='6%' align='left'>Source</th>\n" : ()),
    ($$self{DCOLUMN}{"Open"}      ? "   <th width='4%' align='center'>Open</th>\n" : ()),
    ($$self{DCOLUMN}{"Transient"} ? "   <th width='4%' align='center'>Transient</th>\n" : ()),
    (map { "   <th width='4%' align='center'>@{[&escapeHTML($$_{NAME})]} $node_th</th>\n" } @{$$self{NODE_SHOWN}}),
    "   </tr>\n",
    "  </thead>\n",
    "  <tbody class='nowrap'>\n";

  my $n = 0;
  my %total = (BLOCKS => 0, FILES => 0, BYTES => 0);
  $total{$$_{ID}} = { VALUE => 0, ATTR => "" } for @{$$self{NODE_SHOWN}};
  my ($quantity, $formatter) = ("", sub { return -1, 0 }, sub { return @_ });
  if ($$self{NVALUE} eq "Node blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = (($$obj{NODE_BLOCKS} || $$obj{DEST_BLOCKS}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BLOCKS} || 0;
      my $refvalue = $$ref{BLOCKS};
      my $interesting = ($$obj{DEST_BLOCKS} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing blocks")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BLOCKS} || 0) - ($$obj{NODE_BLOCKS} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BLOCKS} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = (($$obj{NODE_FILES} || $$obj{DEST_FILES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_FILES} || 0;
      my $refvalue = $$ref{FILES};
      my $interesting = ($$obj{DEST_FILES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing files")
  {
    $formatter = \&format_num;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_FILES} || 0) - ($$obj{NODE_FILES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Node bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{NODE_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = (($$obj{NODE_BYTES} || $$obj{DEST_BYTES}) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Destined bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = $$obj{DEST_BYTES} || 0;
      my $refvalue = $$ref{BYTES};
      my $interesting = ($$obj{DEST_BYTES} ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  }
  elsif ($$self{NVALUE} eq "Missing bytes")
  {
    $formatter = \&format_size;
    $quantity = sub { my ($ref, $obj) = @_;
      my $value = max(0, ($$obj{DEST_BYTES} || 0) - ($$obj{NODE_BYTES} || 0));
      my $refvalue = 0;
      my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
      return ($value, $refvalue, $interesting); };
  } 
  elsif ($$self{NVALUE} eq "% Complete (files)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_FILES} || 0) / ($$obj{DEST_FILES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_FILES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  } elsif ($$self{NVALUE} eq "% Complete (bytes)")
  {
      $formatter = \&format_percent;
      $quantity = sub { my ($ref, $obj) = @_;
        my $value = max(0, ($$obj{NODE_BYTES} || 0) / ($$obj{DEST_BYTES} || -1));
        my $refvalue = 1;
        my $interesting = (($$obj{DEST_BYTES} && $value) ? 1 : 0);
  	return ($value, $refvalue, $interesting);  };
  }


  foreach my $ds (@{$$self{DATASET_LIST}})
  {
    my %values = ();
    my $interesting = 0;
    foreach my $node (@{$$self{NODE_SHOWN}})
    {
      my ($value, $refvalue, $intr) = &$quantity($ds, $$ds{REPLICAS}{$$node{ID}});
      my $attr = $value == $refvalue ? "" : " style='color:#d00'";
      $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
      $interesting ||= $intr;
    }

    next if $$self{ROWS} eq 'interesting' && ! $interesting;

    my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
    my @sources = ($$ds{SOURCES} ? values %{$$ds{SOURCES}}
		   : "<span style='color:#666'>(Expand)</span>");
    my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		  ? "<span style='color:#666'>(Multiple)</span>"
		  : $sources[0]);
    print { $$self{CONTENT} }
      "  <tr$rowcolor>\n",
      "   <td><a name='d$$ds{ID}'>$$ds{EXPAND_LINK}</a></td>\n",
      ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()),
      ($$self{RCOLUMN}{"Name"}      ? "   <td>@{[&escapeHTML($$ds{NAME})]}</td>\n" : ()),
      ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>@{[&format_num($$ds{BLOCKS})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$ds{FILES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$ds{BYTES})]}</td>\n" : ()),
      ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
      ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$ds{IS_OPEN}</td>\n" : ()),
      ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>$$ds{IS_TRANSIENT}</td>\n" : ()),
    (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
      "  </tr>\n";

    $total{BYTES} += $$ds{BYTES};
    $total{BLOCKS} += $$ds{BLOCKS};
    $total{FILES} += $$ds{FILES};
    for (@{$$self{NODE_SHOWN}})
    {
	if ($$self{NVALUE} !~ /^%/) {
	    $total{$$_{ID}}{VALUE} += $values{$$_{ID}}{VALUE};
	} else {
	    $total{$$_{ID}}{VALUE} = 0; # TODO:  Properly sum part/whole for percents
	}
	$total{$$_{ID}}{ATTR} ||= $values{$$_{ID}}{ATTR};
    }

    foreach my $block (@{$$ds{BLOCK_LIST}})
    {
      %values = ();
      $interesting = 0;
      foreach my $node (@{$$self{NODE_SHOWN}})
      {
        my ($value, $refvalue, $intr) = &$quantity($block, $$block{REPLICAS}{$$node{ID}});
        my $attr = $value == $refvalue ? "" : " style='color:#d00'";
        $values{$$node{ID}} = { PRETTY => &$formatter($value), VALUE => $value, ATTR => $attr };
        $interesting ||= $intr;
      }

      next if $$self{ROWS} eq 'interesting' && ! $interesting;

      my $rowcolor = ($n++ % 2 < 1) ? " bgcolor='#fffeec'" : " bgcolor='#f8f2f4'";
      my @sources = ($$block{SOURCES} ? values %{$$block{SOURCES}}
		     : "<span style='color:#666'>(Expand)</span>");
      my $source = (! @sources ? "&#8211;" : scalar(@sources) > 1
		    ? "<span style='color:#666'>(Multiple)</span>"
		    : &escapeHTML($sources[0]));
      print { $$self{CONTENT} }
        "  <tr$rowcolor>\n",
        "   <td><a name='b$$block{ID}'>$$block{EXPAND_LINK}</a></td>\n",
        ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
        ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:2em'>@{[&escapeHTML($$block{NAME})]}</td>\n" : ()),
        ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='right'>&nbsp;</td>\n" : ()),
        ($$self{RCOLUMN}{"Files"}     ? "   <td align='right'>@{[&format_num($$block{FILES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$block{BYTES})]}</td>\n" : ()),
        ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>$source</td>\n" : ()),
        ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>$$block{IS_OPEN}</td>\n" : ()),
        ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
        (map { "   <td align='right'$values{$$_{ID}}{ATTR}>$values{$$_{ID}}{PRETTY}</td>\n" } @{$$self{NODE_SHOWN}}),
        "  </tr>\n";

      foreach my $file (@{$$block{FILE_LIST}})
      {
        my $rowcolor = ($n++ % 2 < 1) ? '' : " bgcolor='#f8f8f8'";
        my $span = 1; $span++ if $$self{RCOLUMN}{"Files"};
        my $have = "<span style='color:#666'>y</span>";
        my $havenot = "<span style='color:#d00'>N</span>";
        my $goal = ($$self{NVALUE} =~ /Missing/ ? $havenot : $have);
	my %nodeattr = map { $$_{ID} => ($$block{FILE_REPLICAS}{$$file{ID}}{$$_{ID}}
			                 ? $have : $havenot) }
		      @{$$self{NODE_SHOWN}};
	$interesting = scalar(grep($_ eq $goal, values %nodeattr));
	next if $$self{ROWS} eq 'interesting' && ! $interesting;

        print { $$self{CONTENT} }
          "  <tr$rowcolor>\n",
          "   <td>&nbsp;</td>\n",
          ($$self{RCOLUMN}{"DBS"}       ? "   <td>$$ds{DBS}{HTML_DBS}</td>\n" : ()), # Rowspan
          ($$self{RCOLUMN}{"Name"}      ? "   <td style='padding-left:3em' colspan='$span'>@{[&escapeHTML($$file{NAME})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Bytes"}     ? "   <td align='right'>@{[&format_size($$file{SIZE})]}</td>\n" : ()),
          ($$self{RCOLUMN}{"Source"}    ? "   <td align='left'>@{[&escapeHTML($$file{SOURCE})]}</td>\n" : ()),
          ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
          ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
          (map { "   <td align='right'>$nodeattr{$$_{ID}}</td>\n" } @{$$self{NODE_SHOWN}}),
          "  </tr>\n";
      }
    }
  }

  # Footer, sum totals
  print { $$self{CONTENT} }
  " </tbody>\n",
  " <tfoot>\n",
  "   <tr bgcolor='#f8f8f8'>\n",
  "    <th>&nbsp;</th>\n",
  ($$self{RCOLUMN}{"DBS"} && $$self{RCOLUMN}{"Name"}
   ? "   <th colspan='2' align='left'>Total</th>\n"
   : $$self{RCOLUMN}{"DBS"} || $$self{RCOLUMN}{"Name"}
   ? "   <th align='left'>Total</th>\n"
   : ()),
       ($$self{DCOLUMN}{"Blocks"}    ? "   <td align='center'>@{[&format_num($total{BLOCKS})]}</td>\n" : ()),
       ($$self{RCOLUMN}{"Files"}     ? "   <th align='right'>@{[&format_num($total{FILES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Bytes"}     ? "   <th align='right'>@{[&format_size($total{BYTES})]}</th>\n" : ()),
       ($$self{RCOLUMN}{"Source"}    ? "   <th align='right'>&nbsp;</th>\n" : ()),
       ($$self{DCOLUMN}{"Open"}      ? "   <td align='center'>&#8211;</td>\n" : ()),
       ($$self{DCOLUMN}{"Transient"} ? "   <td align='center'>&#8211;</td>\n" : ()),
       (map { "   <td align='right'$total{$$_{ID}}{ATTR}>@{[&$formatter($total{$$_{ID}}{VALUE})]}</td>\n" } @{$$self{NODE_SHOWN}}),
       "   </tr>\n",
       " </tfoot>\n",
       "</table>\n";
  
  # Produce "footnotes" for the DBS URL base strings
  my %bases = map { $$_{BASE_ID} => $$_{BASE} } grep($$_{BASE}, @{$$self{DBS_LIST}});
  if (keys %bases)
  {
      print { $$self{CONTENT} }
      "<div style='font-size: 0.9em;margin-top:1em'>\n<hr>\n",
      (map { ("<sup><small>$_</small></sup>",
	      "&nbsp;", &breakAtSlash(&escapeHTML($bases{$_})), "<br />\n") }
       sort keys %bases),
      "</div>";
  }
}

# Produce content to the options panel
sub output_options_form
{
    my ($self) = @_;

    my $optspane = new Web25::OptsPane;
    my $target = $self->myurl();
    $optspane->set_form_target($target);

    my $form = "";

    # Save everything except what this form controls
    $form = $self->saveform(qw(dcolumn rcolumn node nvalue dbs rows));
    $optspane->add_hidden($form);

   # Columns Tab
    my @display_columns;
    push @display_columns, 
    [('rcolumn', 'DBS')], 
    [('rcolumn', 'Name')], 
    [('dcolumn', 'Blocks')],
    [('rcolumn', 'Files')], 
    [('rcolumn', 'Bytes')], 
    [('rcolumn', 'Source')], 
    [('dcolumn', 'Open')], 
    [('dcolumn', 'Transient')];

    $form = $self->columns_form(@display_columns);
    $optspane->add_tab('Columns', $form);

    # DBS Source tab
    $form = $self->dbs_form();
    $optspane->add_tab('DBS Sources', $form);

    # Node Selection tab
    $form = $self->node_form();
    $optspane->add_tab('Nodes Shown', $form);
    
    # Node Values tab
    $form = "";
    $form .= "   <p style='margin-top:1ex'><i>Node Values</i></p>\n";
    foreach my $opt (@{$$self{NVALUES}})
    {
	$form .= "  <input type='radio' name='nvalue' value='$opt'" .
	    ($$self{NVALUE} eq $opt ? " checked='checked'" : "") .
	    " />&nbsp;$opt<br/>\n";
    }

    $form .= "   <p style='margin-top:1ex'><i>Filter rows</i></p>\n" .
	"   <input type='radio' name='rows' value='all'" .
	($$self{ROWS} eq 'all' ? " checked='checked'" : "") .
	" />&nbsp;Show all rows<br/>\n" .
	"   <input type='radio' name='rows' value='interesting'" .
	($$self{ROWS} eq 'interesting' ? " checked='checked'" : "") .
	" />&nbsp;Show interesting rows<br/>\n";

    $optspane->add_tab('Node Values', $form);

    print { $$self{OPTIONS} } $optspane->output();
}

1;

######################################################################
package Web25::Data::Subscriptions;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard unescape);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Subscriptions",
	       LINK_TITLE => "Explore subscriptions" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  my ($h,$page,$href,$url);
  $url = $self->myurl();
  $url =~ s%\?.*$%%;
  $h=CGI::Vars();
  delete $h->{view};
  $page = delete $h->{page};

  my ($key,$value,@values);
  if ( keys %{$h} ) {
    $href = '';
    foreach $key ( sort keys %{$h} ) {
      $value = $h->{$key};
      @values = split('\0',$value);
      foreach ( @values ) {
        $_ = unescape($_);
        if ( $_ !~ m|^[\w\/\-\*\?\.!#: ]*$| ) {
          die("The $key parameter (foo) to bar did not pass");
        }
      }
      $href .= $key . '=' . join(";$key=",@values) . ';';
    }
    $href =~ s%;$%%;
    $url .= '#' . escapeHTML($href);
    $self->{REDIRECT} = $url;
    return;
  }
  print {$self->{CONTENT}} "<div id='Data::Subscriptions'></div>";
}

sub output_options_form { }

1;

######################################################################
package Web25::Data::LoadTestInject;
use strict; use warnings;
use base "Web25::Data::ExplorePage";
import Web25::Common;
use CGI qw(:standard);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "LoadTest Injections",
	       LINK_TITLE => "Manage/View LoadTest Injections" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output_page
{
  my ($self) = @_;

  if (!$$self{SECMOD}->isAuthenticated() ||
      !$$self{SECMOD}->isKnownUser() ||
      !($$self{SECMOD}->hasRole('Admin', 'phedex') ||
	$$self{SECMOD}->hasRole('Data Manager') ||
	$$self{SECMOD}->hasRole('Site Admin') ||
	$$self{SECMOD}->hasRole('PADA Admin'))) {
      $self->auth_help_popup('manage LoadTest injections'
			     => ['cert', 'Data Manager', 'Site Admin', 'PADA Admin', 'Admin']);
  }
  
  my %admin_opts = ('rate'       => 'set rate (MB/s)',
		    'inject_now' => 'one-time injection (files)',
		    'start'      => 'start injections',
		    'stop'       => 'stop injections',
		    'remove'     => 'remove injection');
  my @opts_order = qw(rate inject_now start stop remove);

  my $admin_ok = 0;
  if ($$self{SECMOD}->isCertAuthenticated() &&
      ($$self{SECMOD}->hasRole('Admin', 'phedex') ||
       $$self{SECMOD}->hasRole('Data Manager') ||
       $$self{SECMOD}->hasRole('Site Admin') ||
       $$self{SECMOD}->hasRole('PADA Admin'))) {
      $admin_ok = 1;
  }

  if (param('action')) {
      $self->update_injections();
  }

  if (param('create_source') && param('create_source') != -1 
      && param ('create_dest') && param('create_dest') != -1) {
      $self->create_injection();
  }

  print { $$self{CONTENT} } (new Web25::OptsPane)->link("Show Options");

  my $q =$self->get_injections();
  
  my @cols = qw(SELECT DEST_NODE_NAME THROTTLE_NODE_NAME SRC_DATASET_NAME DEST_DATASET_NAME
		IS_ACTIVE RATE INJECT_NOW TIME_INJECT);
  my $th =
  { SELECT => 'Select',
    DEST_NODE_NAME => 'Injection Node',
    SRC_DATASET_NAME => 'Source Dataset',
    DEST_DATASET_NAME => 'Injection Dataset',
    THROTTLE_NODE_NAME => 'Destination Node',
    IS_ACTIVE => 'Status',
    RATE => 'Rate',
    INJECT_NOW => 'Inject Now',
    TIME_INJECT => 'Last Injection'
    };
  
  # Special data fromats
  my $now = time();
  my $df = 
  { 
      IS_ACTIVE   => sub { return $_[0] eq 'y' ? 'Active' : 'Stopped'; },
      RATE => sub { return &format_size($_[0], 1) . "/s"; },
      TIME_INJECT => sub { &formatTime($_[0], 'stamp') || '&#8211;' }
  };

  # Special cell formats
  my $cf = 
  { 
  };

  # Pseudo columns
  my %pseudo =
      (
       'SELECT'  => sub { "<input type='checkbox' name='lp_id' value='$_[1]->{SRC_DATASET}:$_[1]->{DEST_DATASET}:$_[1]->{DEST_NODE}'/>" }
       );
  
  if (!$admin_ok) {
      delete $pseudo{SELECT};
      delete $df->{SELECT};
      delete $th->{SELECT};
      @cols = grep !/SELECT/, @cols;
  }

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols(\@cols);
  $dbtable->set_tablehead($th);
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats($df);
  $dbtable->set_cellformats($cf);
  $dbtable->add_pseudocolumn($_, $pseudo{$_}) foreach (keys %pseudo);
  my @querycols;
  foreach (@cols) {
      my $default = 1;
      push @querycols, [ ($$th{$_}, 'col', $_,  $default) ];
  }
  $dbtable->set_querycols( @querycols );
  $dbtable->set_statcols({RATE => 'SUM', INJECT_NOW => 'SUM'});

  if ($admin_ok) {
      my $target = $self->myurl();
  
      print { $$self{CONTENT} }
      "<p><label>Selections:</label>\n",
      "<input type='button' value='Select all' onclick=\"select_all('subsform', 'lp_id', '1')\"/>\n",
      "<input type='button' value='Select none' onclick=\"select_all('subsform', 'lp_id', '0')\"/>\n",
      "</p>\n";

      print { $$self{CONTENT} }
      "<form id='subsform' method='post' action='$target'>",
      $self->saveform(),
      "<p>\n",
      "<label>Actions:</label>\n",
      "<select class='labeled' name='action'>\n";
      foreach my $opt (@opts_order) {
	  print { $$self{CONTENT} } 
	  "<option value='$opt'>$admin_opts{$opt}</option>\n";
      }
      
      print { $$self{CONTENT} }
      "</select>\n",
      " = ",
      textfield(-name=>'actionvalue', -class=>'labeled', -size=>'5'),
      "<input type='submit' value='Update'/>\n",
      "</p>\n";

  }

  my $nrows = $dbtable->output($q);

  if ($admin_ok) {
      print { $$self{CONTENT} } "</form>\n";
  }

  if ($nrows == 0) {
      $self->alert("No data exists for your selected nodes.");
  }

  my $optspane = new Web25::OptsPane;
  
  my $target = $self->myurl();
  $optspane->set_form_target($target);

  my $form = "";

  # Save everything except what this form controls
  $form = $self->saveform(qw(node));
  $optspane->add_hidden($form);

  $form = $dbtable->columns_form();
  $optspane->add_tab('Columns', $form);

  # Node Selection tab
  $form = $self->node_form();
  $optspane->add_tab('Nodes Shown', $form);

  my $sources = $self->get_sources();

  my $create_source_form;
  if (values %$sources) {
      # Create new Injections widget
      # List of all nodes, except MSS nodes
      my %all_nodes = $self->fetch_nodes(with_ids => 1);
      foreach (keys %all_nodes) {
	  delete $all_nodes{$_} if /_MSS$/;
      }
      my $sort_all_nodes = [ map { $all_nodes{$_} } sort keys %all_nodes ];
      unshift @$sort_all_nodes, -1;
      $all_nodes{'Select a Node'} = -1;

      my $sort_sources = [ map { $$_{SRC_DATASET} } 
			    sort {$$a{SRC_NODE_NAME} cmp $$b{SRC_NODE_NAME}}
			   values %$sources ];
      unshift @$sort_sources, -1;
      $$sources{-1} = { SRC_DATASET => -1, SRC_NODE_NAME => 'Select a Node' };

      $create_source_form = join "",
      "Create LoadTest Stream<br/>",
      "from ",
      popup_menu(-name=>'create_source',
		 -values=>$sort_sources,
		 -labels=>{ map { $$_{SRC_DATASET} => $$_{SRC_NODE_NAME} }
			    values %$sources }),
      " to ",
      popup_menu(-name=>'create_dest',
		 -values=>[ map { $all_nodes{$_} } sort keys %all_nodes ],
		 -labels=>{ reverse %all_nodes }), 
      " at ",
      textfield(-name=>'rate',
		-value=>5,
		-size=>5),
      " MB/s";
  } else {
      $create_source_form = join "",
      "<p>You don't have permission to create new LoadTest streams.  ",
      "Check that you have a LoadTestSource injected for your authorized nodes.</p>";
  }

  $optspane->add_tab('Create Injection', $create_source_form);

  print { $$self{OPTIONS} } $optspane->output();

}

sub output_options_form { }

sub update_injections
{
    my ($self) = @_;

    my $now = time();
    my %warn_hash;  # to keep unique warnings
    my $action = param('action');
    my $bad = 0;
    unless (grep $action, qw(rate inject_now start stop remove)) {
	$warn_hash{"Unknown action"} = 1;
	$bad = 1;
    }

    my $actionvalue = param('actionvalue');
    if (($action eq 'rate' || $action eq 'inject_now')
	&& (!defined $actionvalue || ! (sprintf("%.4f", $actionvalue) >= 0) )) {
	my $desc;
	if    ($action eq 'rate')       { $desc = 'change the rate'; }
	elsif ($action eq 'inject_now') { $desc = 'do an immediate injection'; }
	$warn_hash{"You must provide a value in order to $desc"} = 1;
	$bad = 1;
    }

    if ($action eq 'rate' && $actionvalue > 10_000) {
	$warn_hash{"Rate is too high.  Limit is 10 GB/s."} = 1;
	$bad = 1;
    }
	
    if ($action eq 'inject_now' && $actionvalue > 10_000) {
	$warn_hash{"Injection size is too high.  Limit is 10000 files."} = 1;
	$bad = 1;
    }

    if ($bad) {
	print { $$self{CONTENT} } "<p class='alarm'>$_</p>" for keys %warn_hash;
	return;
    }

    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'PADA Admin||Data Manager||Site Admin', with_ids => 1);
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids => 1); # just a hash of id => name

    my $u_rate = &dbprep($$self{DBH}, qq{ update t_loadtest_param set rate = :rate * power(1000, 2), time_update = :now
					   where src_dataset = :src_dataset
                                             and dest_dataset = :dest_dataset
					     and dest_node = :dest_node });

    my $u_inject = &dbprep($$self{DBH}, qq{ update t_loadtest_param set inject_now = :inject_now, time_update = :now
					     where src_dataset = :src_dataset
                                               and dest_dataset = :dest_dataset
					       and dest_node = :dest_node });

    my $u_active = &dbprep($$self{DBH}, qq{ update t_loadtest_param set is_active = :is_active, time_update = :now
					     where src_dataset = :src_dataset
                                               and dest_dataset = :dest_dataset
					       and dest_node = :dest_node });
    
    my $del = &dbprep($$self{DBH}, qq{ delete from t_loadtest_param
 				        where src_dataset = :src_dataset
                                          and dest_dataset = :dest_dataset
					  and dest_node = :dest_node });

    my $action_list = 
    {
	rate => { desc => 'rate changed',
		  dml => $u_rate,
		  values => { ':rate' => $actionvalue, ':now' => $now }
	      },
	inject_now => { desc => 'immediate injection set',
			dml => $u_inject,
			values => { ':inject_now' => $actionvalue, ':now' => $now }
		    },
	stop => { desc => 'injections stopped',
		  dml => $u_active,
		  values => { ':is_active' => 'n', ':now' => $now }
	      },
	start => { desc => 'injections started',
		   dml => $u_active,
		   values => { ':is_active' => 'y', ':now' => $now }
	       },
	remove => { desc => 'injections deleted',
		    dml => $del,
		    values => {}
		}
    };

    # Execute the update
    $action = $action_list->{$action};

    my $n_changed = 0;

    foreach (param('lp_id')) {
	my ($src_dataset, $dest_dataset, $dest_node) = split /:/;
	if (grep $dest_node == $_, values %auth_nodes) { # Check permission
	    my $dml = $$action{dml};
	    
	    my $rv = &dbbindexec($dml, 
				 ':src_dataset' => $src_dataset,
				 ':dest_dataset' => $dest_dataset,
				 ':dest_node' => $dest_node,
				 %{$$action{values}});
	    $n_changed += $rv;
	} else {
	    my $warn = "<p class='alarm'>Sorry, you don't have permission to update ".
		"$all_nodes{$dest_node} injections!</p>";
	    $warn_hash{$warn} = 1;
	}
    }
    $$self{DBH}->commit();

    # Print scoldings
    print { $$self{CONTENT} } keys %warn_hash;

    # Report the changes
    if ($n_changed) {
	print { $$self{CONTENT} } "<p class='note'>$action->{desc} for $n_changed injections!</p>";
    } else {
	print { $$self{CONTENT} } "<p class='alarm'>Nothing was changed!<p>";
    }
}

sub get_injections
{
  my ($self) = @_;
  $self->fetch_nodes();
  my @node_ids = map { $$_{IS_SHOWN} ? $$_{ID} : '' } @{$$self{NODE_LIST}};
  @node_ids = grep /\d+/, @node_ids;
  my ($node_list, %node_binds) = &dbinlist('node', @node_ids );

  my $q = &dbexec($$self{DBH}, qq{
        select
        lp.dest_node, dn.name dest_node_name,
	lp.src_dataset, ds.name src_dataset_name,
        lp.dest_dataset, dd.name dest_dataset_name,
        lp.is_active, lp.dataset_size, lp.dataset_close,
        lp.block_size, lp.block_close,
        lp.rate, lp.inject_now,
        lp.throttle_node, tn.name throttle_node_name,
        lp.time_inject
            from t_loadtest_param lp
            join t_dps_dataset ds on ds.id = lp.src_dataset
            join t_dps_dataset dd on dd.id = lp.dest_dataset
            join t_adm_node dn on dn.id = lp.dest_node
            left join t_adm_node tn on tn.id = lp.throttle_node
	    where lp.dest_node in ($node_list)
	    order by dn.name, ds.name, dd.name
        }, %node_binds);                    

  return $q;
}

sub create_injection
{
    my ($self) = @_;

    my $src_dataset = param('create_source');
    my $to_node = param('create_dest');
    my $rate = param('rate');
    my $now = time();

    if (!$src_dataset || !$to_node) {
	print {$$self{CONTENT}} "<p class='alarm'>Missing parameters for injection creation</p>";
	return;
    }

    if ( !$rate || ! (sprintf("%.4f", $rate) > 0)) {
	print {$$self{CONTENT}} "<p class='alarm'>Rate too low. Injection rate must be >0.1KB/s</p>";
	return;
    }

    if ($rate > 10_000) {
        print {$$self{CONTENT}} "<p class='alarm'>Rate too high.  Injection rate is limited to 10 GB/s</p>";
        return;
    }
    
    my %all_nodes = reverse $self->fetch_nodes(with_ids=>1);
    my $sources = $self->get_sources(); # gets only authorized sources
    my $source = $$sources{$src_dataset};

    my $from = $$source{SRC_NODE_NAME};
    my $to = $all_nodes{$to_node};

    if ($from eq $to) {
	print {$$self{CONTENT}} "<p class='alarm'>You can't create a stream from $from to $to</p>";
	return;
    }

    my $dest_ds_name = "/PhEDEx_Debug/LoadTest07_$from/$to";
    my $dest_ds;
    my @rv;

    ($dest_ds) = &dbexec($$self{DBH}, qq{
	select ds.id from t_dps_dataset ds where ds.name = :name
	}, ':name' => $dest_ds_name)->fetchrow();

    @rv = &dbexec($$self{DBH}, qq{
	insert into t_dps_dataset
	    (id, dbs, name, is_open, is_transient, time_create)
	    values
	    (seq_dps_dataset.nextval, 1, :name, 'y', 'y', :now)
	    returning id into :dest_ds
	},  ':name' => $dest_ds_name,
		  ':now' => $now,
		  ':dest_ds' => \$dest_ds) unless $dest_ds;
    
    my ($lt_exists) = &dbexec($$self{DBH}, qq{
	select 1 from t_loadtest_param
         where src_dataset = :src_ds
           and dest_dataset = :dest_ds
           and dest_node = :dest_node 
       }, ':src_ds' => $$source{SRC_DATASET},
			      ':dest_ds' => $dest_ds,
			      ':dest_node' => $$source{SRC_NODE})->fetchrow();
    
    if ($lt_exists) {
	print {$$self{CONTENT}} "<p class='alarm'>Injection from $from to $to already exists!</p>";
    } else {
	@rv = &dbexec($$self{DBH}, qq{
	    insert into t_loadtest_param
	    (src_dataset, dest_dataset, dest_node, is_active,
	     dataset_size, dataset_close, block_size, block_close,
	     rate, inject_now, throttle_node,
	     time_create, time_update)
	    values
	    (:src_ds, :dest_ds, :dest_node, 'y',
	     NULL, 'n', 100, 'y',
	     :rate * power(1000,2), 0, :throttle_node,
	     :time_create, :time_update)
	}, ':src_ds' => $$source{SRC_DATASET},
		      ':dest_ds' => $dest_ds,
		      ':dest_node' => $$source{SRC_NODE},
		      ':rate' => $rate, ':throttle_node' => $to_node,
		      ':time_create' => $now, ':time_update' => $now);
    }

    if ($rv[1] > 0) {
	$$self{DBH}->commit();
	print {$$self{CONTENT}} "<p class='note'>Created LoadTest stream from $from to $to</p>";
    }


}

sub get_sources
{
    my ($self) = @_;
    my %auth_nodes = $self->fetch_nodes(web_user_auth => 'PADA Admin||Data Manager||Site Admin', with_ids => 1);
    return {} unless %auth_nodes;
    my ($node_list, %node_binds) = &dbinlist('node', values %auth_nodes );

    # This query looks funny, but it works faster then the obvious thing
    # The key is to not process all the rows of t_dps_file
    my $q = &dbexec($$self{DBH}, qq{
	select ds.id src_dataset, ds.name src_dataset_name,
               n.id src_node, n.name src_node_name
	  from t_dps_dataset ds
          cross join t_adm_node n
         where ds.name like '%LoadTest07Source%'
           and n.id =
           (select f.node from t_dps_file f
              join t_dps_block b on b.id = f.inblock
             where rownum = 1
               and b.dataset = ds.id
               and f.node in ($node_list))
     }, %node_binds);

    return $q->fetchall_hashref('SRC_DATASET');
}

1;

######################################################################
package Web25::Data::Verify;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard unescape);
use List::Util qw(max);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Verification",
	       LINK_TITLE => "Block Verification Test Results" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(node block test status);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
      if ($args{"page"} && ($args{"page"} ne "Data::Verify"));

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}


sub output
{
  my ($self) = @_;

  my $q_tests = &dbexec($$self{DBH}, qq{ select name from t_dvs_test order by name });
  my @tests;  
  while (my $row = $q_tests->fetchrow()) {
      push @tests, $row; 
  }
  unshift @tests, 'Any';
  
  my $q_status = &dbexec($$self{DBH}, qq{ select name from t_dvs_status order by name });
  my @status;  
  while (my $row = $q_status->fetchrow()) {
      push @status, $row; 
  }
  unshift @status, 'Any';


  my %params = $self->validate_all
      (
       allow => [qw(node block test status page_num)],
       spec => {
	   node     => { using => 'regex', default => '.*' },
	   block    => { using => 'regex', default => '.*' },
	   test     => { allowing => \@tests, default => 'Any' },
	   status   => { allowing => \@status, default => 'Any' },
	   page_num => { using => 'pos_int' },
       }
       );
# Explicit checking of arguments
  foreach ( qw( node ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^!?[_,A-Z,a-z,0-9, .*()|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }
  foreach ( qw( block ) ) {
    if ( $params{$_} ) {
      $params{$_} = unescape($params{$_});
      if ( $params{$_} ne '.*' &&
           $params{$_} !~ m%^[a-zA-Z0-9:.\-_/#*|]*$% ) {
        die("The $_ parameter (foo) to bar did not pass");
      }
    }
  }
			    
  my $nodefilter   = $params{node};
  my $blockfilter  = $params{block};
  my $testchoice   = $params{test};
  my $statuschoice = $params{status};

  print {$$self{CONTENT}}
  "<form method='get' action='#' class='nice'>",
  "<label class='inline'>Show</label>",
  popup_menu(-name=>'test', values=>\@tests, -class=>'labeled'),
  "<label class='inline'>tests on nodes </label>",
  textfield(-name=>'node', -value=>$nodefilter, -size=>10, -class=>'labeled'),
  "<label class='inline'>for block</label>",
  textfield(-name=>'block', -value=>$blockfilter, -size=>20, -class=>'labeled'),
  "<label class='inline'>with</label>",
  popup_menu(-name=>'status', values=>\@status, -class=>'labeled'),
  "<label class='inline'>status</label>",
  submit(-label=>'Update', -class=>'labeled'), "<br/>",
  "</form>";
  my @where;
  my %binds;
  my %all_nodes = $self->fetch_nodes(with_ids=>1);
  my @select_nodes;
  if ( $nodefilter =~ m%^!(.*)$% ) {
    $nodefilter = $1;
    @select_nodes = grep !/$nodefilter/, keys %all_nodes;
  } else {
    @select_nodes = grep  /$nodefilter/, keys %all_nodes;
  }

  if (! @select_nodes ) {
      $self->note('No nodes match the given filter');
      return;
  }

  if (scalar @select_nodes < scalar keys %all_nodes) {
      my $list;
      ($list, %binds) = &dbinlist('node', map { $all_nodes{$_} } @select_nodes);
      push @where,"n.id in ($list)";
  }

  if ($testchoice ne 'Any') {
      push @where, 't.name = :test';
      $binds{':test'} = $testchoice;
  }

  if ($statuschoice ne 'Any') {
      push @where, 's.name = :status';
      $binds{':status'} = $statuschoice;
  }

  my $where = @where ?  "where ".join(' and ', @where) : '';

  my $sql = qq{ select v.id, b.name block, block blockid, n_files, n_tested, n_ok,
             s.name status, t.name test, time_reported, n.name node
             from t_status_block_verify v join t_dvs_status s on v.status = s.id
             left join t_dps_block b on v.block = b.id
             join t_dvs_test t on v.test = t.id
	     join t_adm_node n on n.id = v.node
	     $where
             order by time_reported desc };

  my $pager = new Web25::QueryPager;
  $pager->init($self, $sql, {%binds}, 1000, undef, {BLOCK => $blockfilter});
  my $n_rows = $pager->get_total_results();
  
  if (! $n_rows) {
      print { $$self{CONTENT} } "<p>No results to show.</p>";
      return;
  }

  print {$$self{CONTENT}} $pager->pager();
  my $q = $pager->paged_result();

  my $dbtable = new Web25::DBTable;
  $dbtable->set_filehandle($$self{CONTENT});
  $dbtable->set_tablecols([qw(TIME_REPORTED NODE BLOCK TEST STATUS N_FILES N_TESTED N_OK)]);
  $dbtable->set_tablehead({ TIME_REPORTED => 'Time Reported',
			    NODE => 'Node',
			    BLOCK => 'Block',
			    TEST => 'Test',
			    STATUS => 'Status',
			    N_FILES => '# Files',
			    N_TESTED => '# Tested',
			    N_OK => '# OK' });
  $dbtable->set_tableclass('data');
  $dbtable->set_stripeclass('stripe');
  $dbtable->set_dataformats({ TIME_REPORTED => sub { &formatTime($_[0], 'stamp') } });
  $dbtable->set_rowformats({ STATUS => sub { return $_[0] eq 'Fail' ? 'alarm' : '' } });
#  $dbtable->set_formats($cf);
  $dbtable->output($q);
  print {$$self{CONTENT}} $pager->pager();
  
}

1;

######################################################################
package Web25::Reports::DailyReports;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 1, TITLE => "Daily Reports",
	       LINK_TITLE => "Browse all daily reports" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my @reports = sort <$reportdir/$dbname-*.txt*>;
  print { $$self{CONTENT} }
    "<p><table class='striped'><tbody>\n",
    "<tr class='selected'><th colspan='32'>Available reports</th></tr>\n",
    "<tr class='selected'>\n",
    " <th>Month</td>\n",
    (map { sprintf " <th>%02d</th>\n", $_ } 1 .. 31),
    "</tr>\n";
  my $prev = "";
  my $prevday = 0;
  foreach my $file (@reports)
  {
    my $basename = $file; $basename =~ s|.*/||;
    my $cleanname = $basename; $cleanname =~ s|^$dbname-||;
    my $url = $self->myurl("page" => "Reports::DailyReport", "reportfile" => $cleanname);
    my ($year, $month, $day) = ($cleanname =~ /(\d\d\d\d)(\d\d)(\d\d)\..*/);
    if ("$year-$month" ne $prev)
    {
      if ($prev)
      {
        while (++$prevday <= 31) { print { $$self{CONTENT} } "<td></td>\n"; }
        print { $$self{CONTENT} } "</tr>\n";
      }

      print { $$self{CONTENT} } "<tr>\n <td>$year&#8209;$month</td>\n";
      $prev = "$year-$month";
      $prevday = 0;
    }
    while (++$prevday < $day) { print { $$self{CONTENT} } " <td></td>\n"; }
    print { $$self{CONTENT} } "<td align='center'><a href='$url'>R</a></td>\n";
    $prevday = $day;
  }

  print { $$self{CONTENT} } "</tbody></table></p>\n";
}

1;

######################################################################
package Web25::Reports::DailyReport;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);
use POSIX qw(strftime);

our $INDEX = { LIST => 1, ORDER => 2, TITLE => "Daily Report",
	       LINK_TITLE => "Show today's daily report" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub myurl
{
  my ($self, %args) = @_;
  my @save = qw(reportfile);

  # Return bare link if we are switching pages
  return $self->SUPER::myurl(%args)
    if ($args{"page"} && $args{"page"} ne "Reports::DailyReport");

  # Keep my if remaining on the same page (but e.g. different instance)
  return $self->SUPER::myurl($self->urlparams(@save), %args);
}

sub output
{
  my ($self) = @_;
  my $dbname = $$self{CONFIG}{INSTANCES}{$$self{DBID}}{TITLE}; $dbname =~ s/Production/Prod/;
  my $reportdir = "/afs/cern.ch/cms/aprom/phedex/DailyReports";
  my $report = param('reportfile') || (strftime('%Y%m%d', gmtime()) . ".txt");
  print { $$self{CONTENT} } "<pre class='wide' align='left'>\n";
  if ($report && $report =~ m|^[-A-Za-z0-9.]+$|)
  {
    my $reportfile = (<$reportdir/$dbname-$report>)[0];
    if (-f $reportfile)
    {
      local $/ = undef;
      open (REPORT, $reportfile =~ /.gz$/ ? "gzip -dc < $reportfile |" : "< $reportfile");
      my $report = <REPORT>;
      close (REPORT);
      $report =~ s/&/&amp;/gso;
      $report =~ s/</&lt;/gso;
      $report =~ s/>/&gt;/gso;
      $report =~ s/\"/&quot;/gso;
      print { $$self{CONTENT} } $report;
    }
  }
  print { $$self{CONTENT} } "</pre>\n";
}

1;

######################################################################
package Web25::Reports::Size;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 3, TITLE => "File Sizes",
	       LINK_TITLE => "Show file size distribution and other statistics" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;
  my $now = time();
  my $overview = $$self{DBH}->selectrow_arrayref(qq{
    select time_update, n_files, sz_total, sz_min, sz_max, sz_mean, sz_median
    from t_status_file_size_overview});
  my $histo = $$self{DBH}->selectall_arrayref(qq{
    select time_update, bin_low, bin_width, n_total, sz_total
    from t_status_file_size_histogram order by bin_low asc});

  print { $$self{CONTENT} }
    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='6'>File size statistics ", &age($now - $overview->[0]), " ago</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    " <th>Min Size</th>\n",
    " <th>Max Size</th>\n",
    " <th>Mean Size</th>\n",
    " <th>Median Size</th>\n",
    "</tr>\n",
    "<tr>\n",
    " <td align='right'>@{[&format_num($overview->[1])]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[2], 0, 2, 'T')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[3], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[4], 0, 2, 'G')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[5], 0, 2, 'M')]}</td>\n",
    " <td align='right'>@{[&format_size($overview->[6], 0, 2, 'M')]}</td>\n",
    "</tr>\n",
    "</tbody>\n",
    "</table>\n",
    "</p>",

    "<p>",
    "<table class='striped'>\n",
    "<tbody>\n",
    "<tr class='selected'>\n",
    " <th colspan='4'>File size breakdown</th>\n",
    "</tr>\n",
    "<tr class='selected'>\n",
    " <th colspan='2'>Bin</th>\n",
    " <th>Files</th>\n",
    " <th>Total Size</th>\n",
    "</tr>\n";

  foreach my $row (@$histo)
  {
    print { $$self{CONTENT} }
      "<tr>\n",
      " <td align='right'>@{[&format_size($row->[1] * $row->[2],1,2,'G')]} ..</td>\n",
      " <td align='right'>@{[&format_size(($row->[1]+1) * $row->[2],1,2,'G')]}</td>\n",
      " <td align='right'>@{[&format_num($row->[3])]}</td>\n",
      " <td align='right'>@{[&format_size($row->[4],1,2,'T')]}</td>\n",
      "</tr>\n";
  }

  print { $$self{CONTENT} } "</tbody>\n</table>\n</p>\n";
}

1;

######################################################################
package Web25::Reports::SiteUsage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 4, TITLE => "Site Usage",
	       LINK_TITLE => "Site storage allocation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my %nodes = $self->fetch_nodes(with_ids => 1);
    my %params = $self->validate_all
	( allow => [qw(node)],
	  spec => {
	      node    => { using => 'node' },
	  }
	 );
    my $node = $params{'node'} || 'T0_CH_CERN_MSS';
    my $viewurl = '#';

    print { $$self{CONTENT} }
    "<form class='nice' method='get' action='$viewurl'>",
    "<label class='inline'>View node: </label>",
    popup_menu(-name=>'node',
	       -values=>[sort keys %nodes],
	       -default=>$node,
	       -onchange=>'submit()',
	       -class=>'labeled'),
    submit(-label=>'Submit', -class=>'labeled'), "</form><br clear='all'/>";

    my $node_id = $nodes{$node};

    # Group Data
    my $q_grp = &dbexec($$self{DBH}, qq{
	select nvl(g.name, 'undefined') user_group,  n.name node, 
	       s.dest_files, s.dest_bytes, s.node_files, s.node_bytes
	  from t_status_group s
	  left join t_adm_group g on g.id = s.user_group
	  join t_adm_node n on n.id = s.node
	 where n.name = :node
	 order by g.name }, ':node' => $node);

    print { $$self{CONTENT} } "<h2>$node Group Usage</h2>";

    my $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(USER_GROUP DEST_BYTES NODE_BYTES)]);
    $table->set_tablehead({USER_GROUP => 'Group', 
			   DEST_BYTES => 'Subscribed',
			   NODE_BYTES => 'Resident'});
    $table->set_dataformats({ DEST_BYTES => sub { &format_size($_[0], 1, 2) },
			      NODE_BYTES => sub { &format_size($_[0], 1, 2) } } );			
    $table->set_statcols({DEST_BYTES => 'SUM', NODE_BYTES => 'SUM'});
    $table->start();
    $table->head();
    while (my $row = $q_grp->fetchrow_hashref()) {
	$table->row($row);
    }
    $table->finish();

    # Custodial Data    
    my $cust = &dbexec($$self{DBH},
		       qq{ select br.is_custodial, sum(br.dest_files) dest_files, sum(br.dest_bytes) dest_bytes,
			          sum(br.node_files) node_files, sum(br.node_bytes) node_bytes
			     from t_dps_block_replica br
			     join t_adm_node n on br.node = n.id
			    where n.name = :node
			      and br.dest_files is not null and br.dest_files != 0
			    group by br.is_custodial }, ':node' => $node)->fetchall_hashref([qw(IS_CUSTODIAL)]);

    print { $$self{CONTENT} } "<h2>$node Custodial Data</h2>";

    $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(IS_CUSTODIAL DEST_BYTES NODE_BYTES)]);
    $table->set_tablehead({IS_CUSTODIAL => 'Custodial', 
			   DEST_BYTES => 'Subscribed',
			   NODE_BYTES => 'Resident'});
    $table->set_dataformats({ 
	IS_CUSTODIAL => sub { $_[0] eq 'y' ? 'Custodial' : 'Non-Custodial' },
	DEST_BYTES => sub { &format_size($_[0], 1, 2) },
	NODE_BYTES => sub { &format_size($_[0], 1, 2) } } );			
    $table->set_statcols({DEST_BYTES => 'SUM', NODE_BYTES => 'SUM'});
    $table->start();
    $table->head();
    foreach my $c (qw(y n)) {
	next unless exists $cust->{$c};
	$table->row( $cust->{$c} );
    }
    $table->finish();

    # Non-subscribed data
    my $nosub = &dbexec($$self{DBH},
		       qq{ select sum(br.src_files) src_files, sum(br.src_bytes) src_bytes,
			          sum(decode(br.src_files,0,br.node_files,0)) nosub_files, 
			          sum(decode(br.src_bytes,0,br.node_bytes,0)) nosub_bytes
			     from t_dps_block_replica br
			     join t_adm_node n on br.node = n.id
			    where n.name = :node
			      and br.dest_files = 0
			  }, ':node' => $node)->fetchrow_hashref();

    print { $$self{CONTENT} } "<h2>$node Non-subscribed Data</h2>";

    $table = new Web25::TableSpool;
    $table->set_filehandle( $$self{CONTENT} );
    $table->set_tableclass('data');
    $table->set_stripeclass('stripe');
    $table->set_tablecols([qw(SRC_BYTES NOSUB_BYTES)]);
    $table->set_tablehead({SRC_BYTES => 'Source',
			   NOSUB_BYTES => 'Non-subscribed'});
    $table->set_dataformats({ 
	SRC_BYTES   => sub { &format_size($_[0], 1, 2) },
	NOSUB_BYTES => sub { &format_size($_[0], 1, 2) } } );			
    $table->start();
    $table->head();
    $table->row( $nosub );
    $table->finish();
}

1;

######################################################################
package Web25::Reports::GroupUsage;
use strict; use warnings;
use base "Web25::Page";
import Web25::Common;
use CGI qw(:standard);

our $INDEX = { LIST => 1, ORDER => 5, TITLE => "Group Usage",
	       LINK_TITLE => "Group storage allocation" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
    my ($self) = @_;
    
    my $groups = &dbexec($$self{DBH}, qq{
	select nvl(g.name, 'undefined') user_group,  n.name node,
               s.dest_files, s.dest_bytes, s.node_files, s.node_bytes
	  from t_status_group s
	  left join t_adm_group g on g.id = s.user_group
	  join t_adm_node n on n.id = s.node
      })->fetchall_hashref([qw(USER_GROUP NODE)]);
    
    print { $$self{CONTENT} } "<h2>Group Usage</h2>";

    foreach my $group (sort keys %{$groups}) {
	print { $$self{CONTENT} } "<h3>$group</h3>";

	my $table = new Web25::TableSpool;
	$table->set_filehandle( $$self{CONTENT} );
	$table->set_tableclass('data');
	$table->set_stripeclass('stripe');
	$table->set_tablecols([qw(NODE DEST_BYTES NODE_BYTES)]);
	$table->set_tablehead({USER_GROUP => 'Group',
			       NODE => 'Node',
			       DEST_BYTES => 'Subscribed',
			       NODE_BYTES => 'Resident'});
	$table->set_dataformats({ DEST_BYTES => sub { &format_size($_[0], 1, 2) },
				  NODE_BYTES => sub { &format_size($_[0], 1, 2) } } );			
	$table->set_statcols({DEST_BYTES => 'SUM', NODE_BYTES => 'SUM'});
	$table->start();
	$table->head();
	foreach my $row (sort { $a->{NODE} cmp $b->{NODE} }
			 values %{$groups->{$group}}) {
	    $table->row($row);
	}
	$table->finish();
    }
}

1;

######################################################################
package Web25::Data::BulkDelete;
use strict; use warnings;
use base "Web25::Page";
use CGI qw(:standard unescape);
import Web25::Common;
our $INDEX = { LIST => 0, ORDER => 999, NOLOGIN => 1, TITLE => "Bulk Delete Data" };

sub new
{
  my $proto = shift;
  my $class = ref($proto) || $proto;
  my $self = $class->SUPER::new(@_);
  bless $self, $class;
  return $self;
}

sub output
{
  my ($self) = @_;

  my %params = $self->validate_all(
    allow    => [qw(dataspec)],
    spec     => {
      dataspec  => { regex => qr|^[A-Za-z0-9_\-#:\./%]+$|, multiple => 1 }
    }
  );
  no strict "refs";
  print { $$self{CONTENT} }
"<script type='text/javascript'>
  if ( typeof(PhedexPage) == 'undefined' ) { PhedexPage = {}; }
  PhedexPage.postdata = [
";
  if ( $params{dataspec} ) {
    if ( ref($params{dataspec}) eq 'ARRAY' ) {
      my @p;
      map { push @p, "  '" . unescape($_) . "'" } @{$params{dataspec}};
      print { $$self{CONTENT} } join(",\n",@p);
    } else {
      print { $$self{CONTENT} } "  '",unescape($params{dataspec}),"'\n";
    }
  }
  print { $$self{CONTENT} }
" ];
</script>
<div id='Data::BulkDelete'></div>
";
}

1;

######################################################################
package main;
BEGIN { use strict; use warnings; $^W=1; }
use CGI qw(:standard);

# Run the script main routine.  Determine which page we are looking
# at, instantiate it, then ask the page to generate itself.
sub runme
{
  # Read PhEDEx web server configuration, and derive a few server-related
  # quantities from the request-object
  my ($r,$h,$XForwardedHost,$CMSRequestURI,$config);
  $config = &read_config();
  $r = shift; # The Apache::RequestRec object...
  $h = $r->headers_in();
  $XForwardedHost = $h->{'X-Forwarded-Host'} || 'no.such.domain'; # e.g. cmswttest.cern.ch
  $CMSRequestURI  = $h->{'CMS-Request-URI'};  # e.g. /phedex/dev2/datasvc/perl/prod/bounce
  $config->{SSL_SERVER_ROOT} ||= 'https://' . $XForwardedHost;
  $config->{SERVER_ROOT}     ||= 'http://'  . $XForwardedHost;
  $config->{GRAPHTOOL_URL}   ||= $config->{SSL_SERVER_ROOT} . $config->{SERVICE_PATH} . '/graphs';

  #eval "use CGI::Carp qw(fatalsToBrowser)";

  # Set debug mode
  $TESTING          = $config->{TESTING_MODE} ? 1 : 0;
  $TESTING_MAIL     = $config->{TESTING_MAIL} || undef;

  # Set DBSLookup path
  $DBS_LOOKUP = $$config{DBS_LOOKUP} || undef;

  # Interpret the trailing path suffix: /DB/PAGE?QUERY
  my $path = path_info() || "/prod";
  my ($db, $cgipage) = ("prod", "Info::Main");
  $db = $1 if ($path =~ m!\G/([^/]+)!g);
  my $newDB;
  if ( $db  && not exists $config->{INSTANCES}{$db}) {
    my $map = {
      testbed	=> 'tbedi',
      testbed2	=> 'tbedii',
      dev	=> 'test',
      tbedi	=> 'testbed',
      tbedii	=> 'testbed2',
      test	=> 'dev',
    };
    if ( $newDB = $map->{lc $db} ) {
      $config->{INSTANCES}{$db} = $config->{INSTANCES}{$newDB};
      $config->{INSTANCES}{$db}{ID} = $db;
    }
  }
  $cgipage = $1 if ($path =~ m!\G/([^/]+)!g);

  # Get the scope object for the page.
  no strict "refs";

  # Grab the database name from the path info
  my $content;
  if ( ! exists $$config{INSTANCES}{$db} ) {
      my $feedbackurl =
        "mailto:$config->{FEEDBACK_MAIL}?subject="
        . "PhEDEx%20web%20(SiteDB)%20is%20inaccessible or unknown";
      $content =
	  "<center><div class='alert'>\n".
	  " <p>The PhEDEx instance you asked for is not known to this installation.<br />".
	  " Please choose another instance, try again at another time, or if the problem".
	  " persists and this is an instance you should be using,".
	  " please <a href='$feedbackurl'>notify the administrators</a>.".
	  "</p>".
          "</div></center>\n";
      $cgipage = 'Error';
      $db = 'prod';
  }
  my $type;
  $type = "Web25::$cgipage"
    if ($cgipage =~ /^[A-Za-z0-9]+(::[A-Za-z0-9]+)*/
	&& exists ${"Web25::$cgipage\::"}{INDEX}
	&& exists ${"Web25::$cgipage\::"}{new});

  if ( ! $type ) {
      my $feedbackurl =
        "mailto:$config->{FEEDBACK_MAIL}?subject="
        . "PhEDEx%20web%20page%20is%20inaccessible or unknown";
      $content =
	  "<center><div class='alert'>\n".
	  " <p>The PhEDEx web page you asked for is not known to this installation.<br />".
	  " Please choose another page, try again at another time, or if the problem".
	  " persists and this is an instance you should be using,".
	  " please <a href='$feedbackurl'>notify the administrators</a>.".
	  "</p>".
          "</div></center>\n";
      $cgipage = 'Error';
      $type = 'Web25::Error';
  }

  # Instantiate the page object and remember it as a CGI parameter
  # so we can use it in generating links to other pages.
  my $page = &{"$type\::new"}($type, CONFIG => $config, DBID => $db);
  if ( $content ) { $page->{ERROR_MSG} = $content; }
  $type =~ s!^Web25::!!;
  param('page', $type);
  
  # Initialize the SecurityModule
  unless ($cgipage =~ /^XML/) {
      my %args;
      if ($$config{SECMOD_FILES_PATH}) {
        # If a local path is configured, use local files for initializing the security model:
        $args{FILES_PATH} = $$config{SECMOD_FILES_PATH};
        $args{HEADERS_IN} = $r->headers_in();
      } else {
        die "webpage has no way to initialize SecurityModule: configure secmod-files-path.";
      }
      $page->{SECMOD} = new PHEDEX::Web::LocalAuth({%args});
  }

  # Generate the page
  $page->generate();
}

# Parses DBParam file, returns a configuration object
# TODO:  Should just use Toolkit/Common/UtilsDB
sub parseDatabaseInfo
{
    my ($file, $section) = @_;
    my $self = {};
    $$self{DBCONFIG} = $file.':'.$section;

    $$self{DBH_LIFE} = 86400;
    $$self{DBH_AGE} = 0;
    if ($$self{DBCONFIG} =~ /(.*):(.*)/)
    {
	$$self{DBCONFIG} = $1;
	$$self{DBSECTION} = $2;
    }

    my $insection = $$self{DBSECTION} ? 0 : 1;
    open (DBCONF, "< $$self{DBCONFIG}")
	or die "$$self{DBCONFIG}: $!\n";

    while (<DBCONF>)
    {
	chomp; s/#.*//; s/^\s+//; s/\s+$//; s/\s+/ /g; next if /^$/;
	if (/^Section (\S+)$/) {
	    $insection = ($1 eq $$self{DBSECTION});
	} elsif (/^Interface (\S+)$/) {
	    $$self{DBH_DBITYPE} = $1 if $insection;
	} elsif (/^Database (\S+)$/) {
	    $$self{DBH_DBNAME} = $1 if $insection;
	} elsif (/^AuthDBUsername (\S+)$/) {
	    $$self{DBH_DBUSER} = $1 if $insection;
	} elsif (/^AuthDBPassword (\S+)$/) {
	    $$self{DBH_DBPASS} = $1 if $insection;
	} elsif (/^AuthRole (\S+)$/) {
	    $$self{DBH_DBROLE} = $1 if $insection;
	} elsif (/^AuthRolePassword (\S+)$/) {
	    $$self{DBH_DBROLE_PASS} = $1 if $insection;
	} elsif (/^ConnectionLife (\d+)$/) {
	    $$self{DBH_LIFE} = $1 if $insection;
	    $$self{DBH_CACHE} = 0 if $insection && $1 == 0;
	} elsif (/^LogConnection (on|off)$/) {
	    $$self{DBH_LOGGING} = ($1 eq 'on') if $insection;
	} elsif (/^LogSQL (on|off)$/) {
	    $ENV{PHEDEX_LOG_SQL} = ($1 eq 'on') if $insection;
	} elsif (/^SessionSQL (.*)$/) {
	    push(@{$$self{DBH_SESSION_SQL}}, $1);
	} else {
	    die "$$self{DBCONFIG}: $.: Unrecognised line\n";
	}
    }
    close (DBCONF);

    die "$$self{DBCONFIG}: database parameters not found\n"
	if (! $$self{DBH_DBITYPE} || ! $$self{DBH_DBNAME}
	    || ! $$self{DBH_DBUSER} || ! $$self{DBH_DBPASS});

    die "$$self{DBCONFIG}: role specified without username or password\n"
	if ($$self{DBH_DBROLE} && ! $$self{DBH_DBROLE_PASS});
    return $self;
}

sub read_config
{
  my $config_file = $ENV{PHEDEX_SERVER_CONFIG}
    || die "No server configuration.\n";

  $config_file =~ s/DEVNAME/$ENV{PHEDEX_DEV}/;
  open (CONFIG, "< $config_file")
    || die "$config_file: cannot read server configuration: $!\n";

  my $config = {};
  my $instance_rank = 0;
  while (1)
  {
    my $line = &parse_line($config_file);
    if (! defined $line)
    {
      last;
    }
    elsif ($line =~ /^$/)
    {
      next;
    }
    elsif ($line =~ /^([-a-zA-Z0-9]+):\s+(\S+)$/)
    {
	my $name = uc $1;
	my $value = $2;
	$name =~ s/-/_/g;
	
	$$config{$name} = $value;
    }
    elsif ($line =~ /^instance:\s+([\S\s]+)$/)
    {
      my $rest = $1;
      my $info = {};
      while ($rest =~ /\G([-a-z]+)\s*=\s*(\S+)\s*/g)
      {
        my $name = uc($1);
        my $value = $2;
        $name =~ s/-/_/g;
        $$info{$name} = $value;
      }

      my @required = qw(ID TITLE CONNECTION GRAPH_CONNECTION);
      my @missing = map { s/_/-/g; lc; } grep(! exists $$info{$_}, @required);
      die "$config_file: instance is missing parameters '@missing'\n" if @missing;
      my $dbparam_config = &parseDatabaseInfo($$config{DBPARAM}, $$info{CONNECTION});
      $$info{DBPARAM} = $dbparam_config;
      $$info{RANK} = $instance_rank++;
      $$config{INSTANCES}{$$info{ID}} = $info;
    }
    else
    {
      die "$config_file: unexpected parameters '$line'\n";
    }
  }

  close (CONFIG);
  return $config;
}

sub input_line
{
  my $line = <CONFIG>;
  return undef if ! defined $line;

  chomp($line);
  $line =~ s/#.*//;
  $line =~ s/^\s+//;
  $line =~ s/\s+$//;
  $line =~ s/\s+/ /;
  return $line;
}

sub parse_line
{
  my ($file) = @_;
  my $line = &input_line();
  return undef if ! defined $line;

  while (substr($line,-1,1) eq '\\')
  {
    chop($line);
    my $next = &input_line();
    die "$file: file ends in '\\', expected continued line\n"
      if ! defined $next;
    $line .= " ";
    $line .= $next;
  }

  return $line;
}

&runme(@_);
exit(0);
