#!/usr/bin/env perl

use strict;
$|++;
use PHEDEX::CLI::FakeAgent; # get PHEDEX::CLI::UserAgent for free...
use PHEDEX::Core::Loader;
use Getopt::Long;
use Data::Dumper;
my ($url,$response,$help,$verbose,$quiet,$action,$Action,$fakeagent,$service);
my ($instance,$format,$method,$test_cert,$ref,$timeout,$paranoid);
my ($proxy,$debug,$cert_file,$key_file,$ca_file,$ca_dir,$nocert,$h,@env);
my ($default_service);

my $me = $0;
$me =~ s:.*/::;

$url = 'http://cmsweb.cern.ch/phedex/datasvc';
$instance = 'tbedi';
$format   = 'xml';
$method   = 'post';
$default_service = 'PHEDEX::Web::DataService';
$help = $verbose = $debug = $quiet = 0;
$nocert = $test_cert = $timeout = $paranoid = $fakeagent = 0;

my $loader = PHEDEX::Core::Loader->new( NAMESPACE => 'PHEDEX::CLI' );
my @commands = map { lc $_ } values %{ $loader->Commands() };

Getopt::Long::Configure('require_order');
GetOptions
    ( 	 'help'		=> \$help,
	 'verbose!'	=> \$verbose,
	 'quiet!'	=> \$quiet,
	 'debug!'	=> \$debug,
	 'proxy=s'	=> \$proxy,
	 'cert_file=s'	=> \$cert_file,
	 'key_file=s'	=> \$key_file,
	 'ca_file=s'	=> \$ca_file,
	 'ca_dir=s'	=> \$ca_dir,
	 'url=s'	=> \$url,
	 'nocert'	=> \$nocert,
	 'testcert'	=> \$test_cert,
	 'timeout=i'	=> \$timeout,
	 'paranoid!'	=> \$paranoid,
	 'fakeagent!'	=> \$fakeagent,

	 'instance=s'	=> \$instance,
	 'format=s'	=> \$format,
	 'method=s'	=> \$method,
	 'service=s'	=> \$service,
	 'env=s@'	=> \@env,
	);

foreach ( @env )
{
    m%^([^=]*)=(.*)$% or next;
    $ENV{$1} = $2;
}

sub usage
{
  print <<EOF;

  Usage: $me [--proxy=s] [--cert_file=s] [--key_file=s]
	    [--method=s] [--url=s]
	    [--instance=s] [--format=s]
	    [--timeout=i] [--paranoid]
	    [--fakeagent] [--service=s]
	    [--debug] [--verbose]
	    command <command-options>
	    command <command-options>

 where
 --proxy, --cert_file, and --key_file are used to define your certificate.
 if none of these options are specified, your usercert.pem and userkey.pem
 in ~/.globus are assumed. If you specify any of them then you must specify
 all that are needed, the defaults are only taken if none are set.

 If you don't want to use a certificate at all, use --nocert, and you had
 better specify a --url that doesn't connect to https as well.

 --method	'post' or 'get'. Don't set this unless you know why.
 --url		is the URL of the PhEDEx dataservice instance. The default is
		$url

 --instance	name of PhEDEx instance to use: 'prod', 'dev', 'test' etc.
		The default is '$instance'.
 --format	format for returned data: 'perl', 'xml', 'json' or 'report'. The 
                default is 'xml'.  Not all commands support the
                'report' format, check the command documentation.
 --timeout	is the time to wait for a server response. The default is
		5 minutes, set in PHEDEX::CLI::UserAgent
 --paranoid	consider an XML-formatted 'error' message to be fatal, and
		dump lots of useful debugging info.
 --fakeagent	run interactively, with a fake useragent that sets up the
		environment and calls the dataservice directly.
 --service	name of Perl module to load to instantiate the data service.
		If --service is given, --fakeagent is assumed. If --fakeagent
		is given and --service is not specified, the default data
		service ($default_service) is assumed.

 --debug, --verbose, and --help are obvious

 Multiple commands can be given in a single call, the arguments for
each command are kept separate by the '--' pseudo-option. If you
specify global options, you must also use '--' to denote their end,
before starting the subcommand arguments.

E.g.

$me inject --node T1_XY_Buffer --verbose --help
$me --verbose -- inject --node T1_XY_Buffer
$me --verbose -- inject --node T1_XY_Buffer -- inject --node T2_PQ_Buffer

 Multiple commands in a single execution still results in multiple
 requests to the server, and they are fully independent.

EOF

  print " Known commands in this installation are:\n",
	' ',join(' ',@commands),"\n\n",
	" use \"$me <command> -help\" for details of a particular command\n\n";

  print " For more information about the data-service, visit $url/doc\n\n";
  exit 0;
}

$help && usage;

if ( !( $cert_file || $key_file || $proxy || $ca_file || $ca_dir ||
	$ENV{HTTPS_PROXY} || $ENV{HTTPS_CERT_FILE} || $ENV{HTTPS_KEY_FILE} ||
	$ENV{HTTPS_CA_FILE} || $ENV{HTTPS_CA_DIR} ) )
{
  $cert_file = $ENV{HOME} . '/.globus/usercert.pem';
  $key_file  = $ENV{HOME} . '/.globus/userkey.pem';
}

$fakeagent = 1 if $service;
my $module = 'PHEDEX::CLI::UserAgent';
if ( $fakeagent )
{
  $service = $default_service unless $service;
  $module = 'PHEDEX::CLI::FakeAgent';
}

my $pua = ($module)->new
	(
	  DEBUG	 	=> $debug,
	  CERT_FILE	=> $cert_file,
	  KEY_FILE	=> $key_file,
	  PROXY	 	=> $proxy,
	  CA_FILE	=> $ca_file,
	  CA_DIR	=> $ca_dir,
	  URL		=> $url,
	  FORMAT	=> ($format eq 'report' ? 'perl' : $format),
	  INSTANCE	=> $instance,
	  NOCERT	=> $nocert,

	  SERVICE	=> $service,
	);

$pua->timeout($timeout) if $timeout;
$pua->PARANOID($paranoid);
$pua->VERBOSE($verbose);
if ( $test_cert )
{
  $pua->VERBOSE(1);
  $pua->test_certificate();
}

my (@responses);
while (@ARGV)
{
  my $command = shift @ARGV;
  print "ARGV to '$command':  ", join(' ', @ARGV), "\n" if $debug;

  my $commands = $loader->Commands();
  if (! grep($command eq lc $_, values %$commands) ) {
      die "command '$command' is not known, use '$me --help' for help\n";
  }

  my $module = $loader->Load($command);
  my $cli = $module->new();
  print "created new $module object\n" if $debug;
  print $cli->Dump() if $debug;
  
  # Check if the CLI can make a report
  if ($format eq 'report' && ! $cli->can('Report')) {
      die "ERROR:  the 'report' format is unavailable for '$command'\n";
  }
  $pua->CALL($cli->Call());
  print $pua->Dump() if $debug;
  $response = $pua->$method($pua->target,$cli->Payload());

  print "Response: ",$response->content() if $debug;
  if ( $pua->response_ok($response) )
  {
    my $content = $response->content();
 
    my $report_module = $module . '::Report';
    eval(" use $report_module");
    if ( ! $@ )
    {
      $report_module->new( $content );
      next;
    }

    # If the user just wants the data, return what we got from the data service
    if ($format ne 'report') {
	print $content, "\n";
    } else {
	# Make sure the response was a perl object.  If it isn't, then
	# reformat it into an error object
	$content =~ s%^[^\$]*\$VAR1%\$VAR1%s; # get rid of stuff before $VAR1
	no strict 'vars';
	my $obj = eval($content);
	if ($@) {
	    $obj = { 'ERROR' => "Server responded with non-perl data:\n$content"};
	}

      # The user wants a human readable report, call CLI backend methods to make a report
      if (exists $obj->{ERROR}) {
	die "Error from server: ",$obj->{ERROR}, "\n";
      }

      if ($cli->ResponseIsValid($obj)) {
	$cli->Report($obj);
      } else {
	die "ERROR:  Response from server is not valid, cannot print report\n";	
      }
    }
  }
  else
  {
      my $content = $response->content();
      chomp $content;
      print "Bad response from server, output below:\n$content\n";
      print Data::Dumper->Dump([ $pua, $cli, $response ],[ 'UserAgent', 'CLI', 'Response' ]) if $debug;
#      print Data::Dumper->Dump([ \%ENV ], [ '$ENV' ]) if $debug;
      die "exiting after failure\n";
  }
}

exit 0;
