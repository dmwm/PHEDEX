#!/usr/bin/env perl
use strict;

##H
##H  Find orphan files in storage w.r.t. TMDB or DBS.
##H
##H   Usage:
##H
##H   StorageConsistencyCheck -db DBCONFIG [-lfnlist LFNLIST] [-verbose]
##H 
##H   DBCONFIG is the usual PhEDEx DB contact file.
##H
##H   LFNLIST is a file containing full LFNs as found in your storage
##H   element, one lfn per line. Anything before the '/store/' part is
##H   ignored, anything after it is taken to be the full LFN.
##H   If LFNLIST is given as '-', the script will read from stdin.
##H   Gzipped (*.gz) or bzipped (*.bz2) files can be read directly,
##H   allowing for compact filelists.
##H
##H   The output is a list of files known to the storage element (i.e. in the
##H   input list) but not known to TMDB. After that the same list is
##H   summarised by directory, where purely numerical subdirectories are
##H   grouped (i.e. /path/001 and /path/002 are grouped as /path).
##H
##H   EXAMPLES:
##H
##H   StorageConsistencyCheck -db ~/private/DBParam:Prod/Reader
##H      -lfnlist /afs/cern.ch/user/w/wildish/public/castor.store.merged.txt
##H   
##H

# Process command line arguments.
use Getopt::Long;
use File::Basename;
use PHEDEX::Core::Help;
use PHEDEX::Core::DB;
use PHEDEX::BlockConsistency::SQL;

my ($dbh);
my ($verbose,$debug,$terse);
my (%h,$conn);
my ($DBCONFIG,%lfn);
my ($lfnlist);
my $debug_me = 1;

$verbose = $debug = $terse = 0;
GetOptions("db=s"           => \$DBCONFIG,
           "lfnlist=s"      => \$lfnlist,

           "verbose|v+"     => \$verbose,
           "debug+"         => \$debug,
           "terse"          => \$terse,

           "help|h"         => sub { &usage() }
	  );

$|=1;

# Check arguments.
if( !$DBCONFIG )
{
  die "Insufficient parameters, use -h for help.\n";
}

#-------------------------------------------------------------------------------
$conn = { DBCONFIG => $DBCONFIG };
$dbh = &connectToDatabase ( $conn );

if ( $lfnlist =~ m%.gz$% )
{ open LFN, "cat $lfnlist | gzip -d - |" or die "open: $lfnlist: $!\n"; }
elsif ( $lfnlist =~ m%.bz2$% )
{ open LFN, "cat $lfnlist | bzip2 -d - |" or die "open: $lfnlist: $!\n"; }
elsif ( $lfnlist =~ m%^-$% )
{ *LFN = *STDIN; }
else
{ open LFN, "<$lfnlist" or die "open: $lfnlist: $!\n"; }

while ( <LFN> )
{
  chomp;
  $debug && print "Read: $_\n";;
  s%^.*/store%/store%;
  s%\s.*$%%;
  $h{LFN}{$_}++;
  $_ = dirname $_;
  $_ =~ s%/\d+$%%;
  $h{DIR}{$_}{SE}++;
}

if ( $verbose )
{
  print " #files  : directory\n";
  foreach ( sort keys %{$h{DIR}} )
  {
    printf("%8d : %s\n",$h{DIR}{$_}{SE},$_);
  }
  print "\n";
}
printf "Got %8d LFNs in %5d directories\n",
       scalar keys %{$h{LFN}},
       scalar keys %{$h{DIR}};

#-------------------------------------------------------------------------------
foreach my $dir ( keys %{$h{DIR}} )
{
# $verbose && print "Process $dir\n";
  my $tmp = PHEDEX::BlockConsistency::SQL::getLFNsFromWildCard( $dbh, $dir . '%' );
  foreach ( @{$tmp} )
  {
    delete $h{LFN}{$_};
    $_ = dirname $_;
    $_ =~ s%/\d+$%%;
    $h{DIR}{$_}{TMDB}++;
  }
  $verbose && print scalar keys %{$h{LFN}}, " files left...    \r";
}
$verbose && print "\n";

$dbh->disconnect();

print "Orphaned file summary:\n";
print join("\n", sort keys %{$h{LFN}}), "\n";
print "Final score: ", scalar keys %{$h{LFN}}, " files left...\n";

print "\n";
print "Directory summary:\n";
print "       SE/TMDB  diff : Directory\n";
foreach ( sort keys %{$h{DIR}} )
{
  $h{DIR}{$_}{TMDB} += 0;
  if ( $h{DIR}{$_}{SE} != $h{DIR}{$_}{TMDB} )
  {
    my $x = sprintf "%d/%d", $h{DIR}{$_}{SE}, $h{DIR}{$_}{TMDB};
    my $y = $h{DIR}{$_}{SE} - $h{DIR}{$_}{TMDB};
    printf "%13s %8d : %s\n", $x, $y, $_;
  }
}

print "\nFinished...\n";
