#!/usr/bin/env perl

##H Generate daily data transfer and quality statistics.
##H
##H Usage:
##H   MakeDailyStats
##H      -db FILE[:SECTION] -output BASE-FILE-NAME [-add FILE]
##H
##H -db        database connection configuration parameter file
##H -add       add transfer deltas from a file, with lines in the format
##H               YYYYMMDD NODE SIZE-VAL [NODE SIZE-VAL]...
##H -output    output base file name, including directory components
##H
##H Generates output files with BASE-FILE-NAME suffixed with
##H "total.csv", "pending.csv" and "quality.csv".
##H
##H Each file will contain rows for every hour since transfers have
##H been recorded in the database, with four leading columns, month,
##H week, day and hour, then a column for each node with value in
##H the following format: a floating point number for total and
##H pending (volume in terabytes); three integers delimited by
##H slashes for quality: counts of started, completed and finished
##H transfer operations in that hour, respectively.

BEGIN {
  $^W = 1; use strict; use warnings;
  our $me = $0; $me =~ s|.*/||;
  our $home = $0; $home =~ s|/[^/]+$||; $home ||= "."; $home .= "/../Toolkit/Common";
  unshift(@INC, $home);
}
use UtilsHelp;
use UtilsDB;
use POSIX;

my %nodes = ();
my %xferred = ();
my %pending = ();
my %quality = ();
my $first = undef;
my %args = ();

# Process command line arguments.
while (scalar @ARGV)
{
    if ($ARGV[0] eq '-db' && scalar @ARGV > 1)
    { shift (@ARGV); $args{DBCONFIG} = shift(@ARGV); }
    elsif ($ARGV[0] eq '-add' && scalar @ARGV > 1)
    { shift (@ARGV); push(@{$args{ADDFILE}}, shift (@ARGV)); }
    elsif ($ARGV[0] eq '-output' && scalar @ARGV > 1)
    { shift (@ARGV); $args{OUTPUTFILE} = shift (@ARGV); }
    elsif ($ARGV[0] eq '-h')
    { &usage(); }
    else
    { last; }
}

# Check arguments.
if (@ARGV || !$args{DBCONFIG} || !$args{OUTPUTFILE})
{
    die "Insufficient parameters, use -h for help.\n";
}

my $TERABYTE = &sizeValue ("1T");
my $MEGABYTE = &sizeValue ("1M");

# If we were given a file of transfer stats that are no longer known
# in the database, insert them into %xferred as "seed" values.  The
# file contains lines "YYYYMMDD SITE SIZE-VAL [SITE SIZE-VAL]...".
# For each day get the values, convert the date to a time value and
# then to the requested time unit, and add into %xferred as if they
# were real transfers.
foreach my $file (@{$args{ADDFILE}})
{
    open (F, "< $file") or die "$file: $!\n";
    while (<F>)
    {
	my ($date, @words) = split(/\s+/, $_);
	my ($year, $month, $day) = ($date =~ m|(\d\d\d\d)(\d\d)(\d\d)|);
	while (@words)
	{
	    my $node = shift (@words);
	    my $size = &sizeValue (shift (@words));
	    foreach my $hour (8 .. 19)
	    {
		my $hour = &timegm (0, 0, $hour, $day, $month-1, $year-1900, 0, -1);
		$first = $hour if (! $first || $first > $hour);
	    	$nodes{$node} = 1;
	    	$xferred{$hour}{$node} ||= 0;
	    	$xferred{$hour}{$node} += $size / 12.0;
	    }
	}
    }
    close (F);
}

# Fetch all completed and pending transfers and fill into %xferred
# and %pending.  Then the same with transfer quality into %quality.
$dbh = &connectToDatabase (\%args, 0);
my $data = &dbexec ($dbh, qq{
    select trunc(timebin/3600)*3600, to_node, sum(xferred_bytes)
    from t_perf_histogram where from_node not like '%_MSS'
    group by trunc(timebin/3600)*3600, to_node});
while (my ($hour, $node, $xferred) = $data->fetchrow())
{
    $first = $hour if (! $first || $first > $hour);
    $xferred{$hour}{$node} ||= 0;
    $xferred{$hour}{$node} += $xferred;
    $nodes{$node} = 1;
}

$data = &dbexec ($dbh, qq{
    select timebin, to_node, sum(pending_bytes)
    from t_perf_histogram where from_node not like '%_MSS'
    group by timebin, to_node order by timebin, to_node});
while (my ($timebin, $node, $pending) = $data->fetchrow())
{
    my $hour = int($timebin/3600)*3600;
    $first = $hour if (! $first || $first > $hour);
    $pending{$hour}{$node} = $pending;
    $nodes{$node} = 1;
}

$data = &dbexec ($dbh, qq{
    select
        trunc(timebin/3600)*3600,
	to_node,
	sum(case when new_state = 2 then transitions else 0 end),
	sum(case when old_state = 2 and new_state >= 100 then transitions else 0 end),
	sum(case when new_state = 3 then transitions else 0 end)
    from t_quality_histogram
    where from_node not like '%_MSS'
    group by trunc(timebin/3600)*3600, to_node});
while (my ($hour, $node, $started, $failed, $completed) = $data->fetchrow())
{
    $first = $hour if (! $first || $first > $hour);
    $quality{$hour}{$node}{STARTED} = $started;
    $quality{$hour}{$node}{FAILED} = $failed;
    $quality{$hour}{$node}{COMPLETED} = $completed;
    $nodes{$node} = 1;
}
$dbh->disconnect ();
undef $dbh;

# Print the statistics for all nodes.  Generate a continuous time
# series so we print out values even for time spans when there
# were no transfers to report.  This allows for correct histograms
# without having to understands time as real time values.
open (XFER_TOTAL, "> $args{OUTPUTFILE}total.csv")
    or die "$args{OUTPUTFILE}total.csv: $!\n";
open (PENDING, "> $args{OUTPUTFILE}pending.csv")
    or die "$args{OUTPUTFILE}pending.csv: $!\n";
open (QUALITY, "> $args{OUTPUTFILE}quality.csv")
    or die "$args{OUTPUTFILE}quality.csv: $!\n";

my @nodenames = sort keys %nodes;
print XFER_TOTAL join(",", qw(Month Week Day Hour), @nodenames), "\n";
print PENDING join(",", qw(Month Week Day Hour), @nodenames), "\n";
print QUALITY join(",", qw(Month Week Day Hour), @nodenames), "\n";

$first ||= int(time()/86400)*86400;
foreach my $time (&timeSeries ($first, "hour"))
{
    my $hour = $time->{LOW};
    my $span = $time->{HIGH} - $time->{LOW};
    my @times = map { &formatTime ($hour, $_) } qw(month week day hour);
    my $x = $xferred{$hour};
    my $p = $pending{$hour};
    my $q = $quality{$hour};

    print XFER_TOTAL
        join(",", @times, map { ($x->{$_}||0)/$TERABYTE } @nodenames), "\n";
    print PENDING
        join(",", @times, map { ($p->{$_}||0)/$TERABYTE } @nodenames), "\n";
    print QUALITY
        join(",", @times, map { ($q->{$_}{STARTED} || 0) . "/" .
				($q->{$_}{FAILED} || 0) . "/" .
				($q->{$_}{COMPLETED} || 0) } @nodenames), "\n";
}

# Done.
exit 0;

######################################################################
# Generate time series from FIRST to now using RANGE as unit.
#
# Returns a list of hash objects with LOW and HIGH limits, where
# each such time series element is a half-open internval [LOW, HIGH).
# The HIGH of one element is the LOW of the next element.
#
# If RANGE is "hour", generates intervals of hours.  If RANGE is "day",
# generates intervals for days, from midnight to midnight in UTC time.
# If RANGE is "week", returns intervals of ISO weeks, from midnight on
# Monday to the next Monday.  If RANGE is "month", returns intervals of
# calendar months from midnight of the first day of the month to the
# midnight of the first day of the next month.
#
# Time series starts from the beginning of the interval FIRST falls
# in and ends in an interval that contains current time.
sub timeSeries
{
    my ($first, $range) = @_;
    my $now = time();
    my @series = ();
    $first = int($first);

    if ($range eq 'hour') {
	# Convert first time to UTC hour in units of half a day.  Then
	# make a time series of hours until end of current 4 hours.
	my $low = 12 * int($first / 3600 / 12);
	my $high = int($now / 3600) + 1;
	for ( ; $low < $high; ++$low) {
	    push(@series, { LOW => $low * 3600, HIGH => ($low+1) * 3600 });
        }
    } elsif ($range eq 'day') {
	# Convert first time to UTC day at 00:00.  Then make a
	# time series of days until end of today.
	my $low = int($first / 86400);
	my $high = int($now / 86400) + 1;
	for ( ; $low < $high; ++$low) {
	    push(@series, { LOW => $low * 86400, HIGH => ($low+1) * 86400 });
        }
    } elsif ($range eq 'week') {
	# Convert first time to previous Monday.  Then make a
	# time series of weeks until we pass today.
	my %diff = (0 => 6, 1 => 0, 2 => 1, 3 => 2, 4 => 3, 5 => 4, 6 => 5);
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
	my $low = int($first/86400) - $diff{$wday};
	my $high = int($now / 86400) + 1;
	for ( ; $low < $high; $low += 7) {
	    push(@series, { LOW => $low * 86400, HIGH => ($low+7) * 86400 });
	}
    } elsif ($range eq 'month') {
	# Convert first time to first of the month.  Then convert
	# into a time-series of months.  This is a bit dodgy, we
	# go by day so we don't need to worry about month dates.
	my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime ($first);
	my $start = int(($first - ($mday-1)*86400)/86400);
	my $limit = int($now / 86400) + 1;
	while ($start < $limit) {
	    my $low = $start;
	    my ($prevyear, $prevmon) = ($year, $mon);
	    while ($year == $prevyear && $mon == $prevmon) {
		($sec, $min, $hour, $mday, $mon, $year, $wday, $yday)
		    = gmtime ((++$start) * 86400);
	    }
	    push (@series, { LOW => $low * 86400, HIGH => $start * 86400});
	}
    }

    return @series;
}

# Format TIME as unit of RANGE ("hour", "day", "week" or "month").
sub formatTime
{
    my ($time, $range) = @_;
    if ($range eq 'hour') { return strftime ('%Y%m%dZ%H00', gmtime(int($time))); }
    elsif ($range eq 'day') { return strftime ('%Y%m%d', gmtime(int($time))); }
    elsif ($range eq 'week') { return strftime ('%Y%V', gmtime(int($time))); }
    elsif ($range eq 'month') { return strftime ('%Y%m', gmtime(int($time))); }
}

# Stolen from SEAL Time.cpp.  Convert broken down time (mktime format)
# into UTC time in seconds in UNIX epoch format.  Uses mktime in a way
# that returns UTC, not local time.
sub timegm
{
    my @args = @_;
    my $t1 = mktime (@args);
    my @gmt = gmtime ($t1);
    my $t2 = mktime (@gmt);
    return $t1 + ($t1 - $t2);
}

# Convert a storage size into a numeric value (as bytes).  Storage
# sizes are a floating point number optionally followed by a letter
# "k", "M", "G", "T", "P" or "E" for kilo-, mega-, giga-, tera-,
# peta- and exabytes, respectively.  A raw number is accepted as
# well, returned as such, i.e. as bytes.
sub sizeValue
{
    my ($value) = @_;
    if ($value =~ /^([-+\d.Ee]+)([kMGTPE])$/)
    {
        my %scale = ('k' => 2**10, 'M' => 2**20, 'G' => 2**30,
		     'T' => 2**40, 'P' => 2**50, 'E' => 2**60);
        $value = $1 * $scale{$2};
    }
    return $value * 1.0;
}
