#!/usr/bin/perl

###############################################################################
# Script to analyze the PhEDEx download daemon log. Works with PhEDEx 2.5.x
#
# Author: Derek Feichtinger <derek.feichtinger@psi.ch>
#
# Version info: $Id: InspectPhedexLog,v 1.21 2008/02/12 22:27:59 dfeichti Exp $:
###############################################################################

use strict;
use Getopt::Std;
use Data::Dumper;
use Time::Local;
use POSIX;
use HTML::Entities;

my $flag_showErrors=0;
my $flag_rawErrors=0;
my $flag_verbose=0;
my $flag_debug=0;
my $flag_checkdate_start=0;
my $flag_checkdate_end=0;
my $flag_bunchDetect=0;
my $flag_errhisto=0;
my $flag_multiFailures=0;

my $errmsglen=200; # length of error messages to use (error will be cut)
my $multiFilePrintThresh=2;

sub usage {
print <<"EOF";
usage: InspectPhedexLog [options] logfile1 [logfile2 ...]

   Analyses PhEDEx download agent log files

   options:
      -s start_date   -t end_date
      -e     : also show error statistics (summary over error messages)
         -r  : do not try to regexp-process errors messages, but show raw
                 error messages (gigantic output!!)
         -H  : print simple histograms for every error class
         -v  : also print associated taskIDs
      -m     : investigate files with multiple transfer failures
         -v  : outputs per site error messages for failed files
         -x number: sets threshold on how many failures are needed until the file
                    will be printed (default=$multiFilePrintThresh)
      -c number  : defines the error message cutoff (default=$errmsglen)
                   Longer messages will be cut down to this length at the
                   beginning of the parser.This may lead to problems, if
                   the significant part comes later in the message
      -v     : verbose (increases output for -e, -m options)
      -d     : debug   Prints a summary line for every single transfer
      -f file: produces xml files with data, except for some histo
      -h     : display this help

 examples:
   InspectPhedexLog Prod/download Prod/download.1 Prod/download.2
   InspectPhedexLog -evs yesterday -t "2006-11-20 10:30:00" Prod/download
   InspectPhedexLog -es "-2 days"  Prod/download

   without any of the special options, the script will just print
   summary statistics for all download sources.

   Running with the -e option is probably the most useful mode to identify general site problems
   The -m option is useful to look into reasons of data set "tailing", but it is less useful to
   look at the LoadTest transfers for reasons of the changing target file name mapping.

EOF

}

# A note about the time values used in PhEDEx
#
# t-expire: time when transfer task is going to expire 
# t-assing: time when transfer task was assigned (task was created)
# t-export: time when files where marked as available at source
# t-inxfer: time when download agent downloaded task the file belongs to.
# t-xfer: time when transfer for that particular file starts
# t-done: time when transfer for that particular file finished
#
# Note from D.F.:
# This is not quite correct. Several files in a sequence always get the
# same t-xfer value and nearly identical t-done values (the t-done value
# differences are <0.1s). So these times seem to refer rather to a
# bunch of files and not to the times of particular files.



# OPTION PARSING
my %option=();
getopts("c:dehHmrs:t:vx:f:",\%option);


# disabled !!!! $flag_bunchDetect=1 if(defined $option{"b"});
$flag_showErrors=1 if(defined $option{"e"});
$flag_multiFailures=1 if(defined $option{"m"});
$flag_rawErrors=1 if(defined $option{"r"});
$flag_verbose=1 if(defined $option{"v"});
$flag_errhisto=1 if(defined $option{"H"});
$flag_debug=1 if(defined $option{"d"});

if (defined $option{"h"}) {
   usage();
   exit 0;
}

if (defined $option{"c"}) {
  $errmsglen=$option{"c"};
}

if (defined $option{"x"}) {
  $multiFilePrintThresh=$option{"x"};
}

my $logx = $option{"f"} || "/dev/null";

my ($dstart,$dend)=(0,1_500_000_000);
my ($sdstart,$sdend) = ("","");

if (defined $option{"s"}) {
   $dstart=DateToUnixEpochSeconds($option{"s"});
   die "Error: Could not parse starting date: $option{s}\n" if (!$dstart);
   $flag_checkdate_start=1;
}
if (defined $option{"t"}) {
   $dend=DateToUnixEpochSeconds($option{"t"});
   die "Error: Could not parse end date: $option{t}\n" if (!$dend);
   $flag_checkdate_end=1;
}

$sdstart=strftime("%F %T",gmtime($dstart));
print "given starttime $sdstart\n";

$sdend=strftime("%F %T",gmtime($dend));
print "given endtime $sdend\n";

die "Error: Error message cutoff (option -c) must be > 1 (now: $errmsglen)\n" if $errmsglen <=1;

my @logfiles=@ARGV;

my %sitestat;
my %failedfile; # repeatedly failing files
my %expiredfile; # repeatedly failing files
my %attempts; # histogram of required attempts until successful 

if ($#logfiles==-1) {
   usage();
   die "Error: no logfile(s) specified\n";
}


my $datestart;
my $dateend;
#my $date_old=0;
my %errinfo;
my %dberrinfo;
my ($date,$task,$from,$stat,$size,$txfer,$tdone,$ttransfer,$fname,$reason,$bsize,$size_sum)=(0,0,0,0,0,0,0,0,0,0,0,0);
my ($bunchsize,$bunchfiles,$txfer_old,$tdone_old,$closedbunch)=(0,0,0,0,0);
my $line;
my $statstr;

my $epdate;

foreach my $log (@logfiles) {
   open(LOG,"<$log") or die "Error: Could not open logfile $log";
   my ($MbperS,$MBperS);
   while($line=<LOG>) {
       if($line =~ /ORA-\d+.{60}/) {
           my ($ora) = $line =~ m/(ORA-\d+.{60})/;
           ($date) = $line =~ m/^(\d+-\d+-\d+\s+\d+:\d+:\d+):/;
           $dberrinfo{$ora}{num}++;
           push @{$dberrinfo{$ora}{"date"}}, DateToUnixEpochSeconds($date);
           next;
       }

       next unless ($line =~ /(^[\d\:\-\s]+): .* xstats:.*report-code=.*/);
#       print "got date $1\n"; die;
       next if ($flag_checkdate_start && ($1 le $sdstart) );
       next if ($flag_checkdate_end && ($1 ge $sdend) );

       ($date,$task,$from,$stat,$size,$txfer,$tdone,$fname) = $line =~
	   m/(\d+-\d+-\d+\s+\d+:\d+:\d+):.*task=([^\s]+).*from=([^\s]+).*report-code=([\d-]+).*size=([^\s]+).*t-xfer=([^\s]+).*t-done=([^\s]+).*lfn=([^\s]+)/;
       # report-code=0 means a successful transfer
       if(! $fname) {
	   die "Error: Parsing problem with line:\n$line";
       }

       $epdate=DateToUnixEpochSeconds($date);

       unless ($datestart) { $datestart = $epdate };

       $closedbunch=0;
       if($stat == 0) {   # successful transfer
	   $statstr="OK    ";  ##### sprintf("OK(%4d)  ",$stat);
	   $sitestat{"$from"}{"OK"}++;
	   $sitestat{"$from"}{"size"}+=$size;
	   $sitestat{"$from"}{"ttransfer"}+=$ttransfer;
	   $ttransfer=0;
	   # we add up a histogram of the total attempts per file and one for the expired attempts
	   if($flag_multiFailures) {
	       if (exists $failedfile{"$fname"}) {
		   for my $site (keys %{$failedfile{"$fname"}}) {
		       my $toterr = $failedfile{"$fname"}{$site}{"err"}+$failedfile{"$fname"}{$site}{"exp"};
		       $attempts{"$site"}{"toterr"}{$toterr}++;
		       $attempts{"$site"}{"exp"}{ $failedfile{"$fname"}{$site}{"exp"} }++
			   if $failedfile{"$fname"}{$site}{"exp"} > 0;
		   }
		   delete $failedfile{"$fname"};
	       } else {
		   # for files that made it in the first attempt
		   $attempts{"$from"}{"toterr"}{"0"}++;
		   $attempts{"$from"}{"exp"}{"0"}++;
	       }
	   }
	   
             # the following is needed because transfer time applies not to a single file but to the bunch
	     #if( ! defined $txfer_old || $txfer_old == 0  || $txfer == $txfer_old) {     # try to identify bunches
	       # all files in a bunch seem to have the same start time (xfer) and almost the same tdone
	     #  printf STDERR ("WARNING: there may be a transfer time problem (delta t-done=%.4f) in line\n$line\n",$tdone-$tdone_old) if $flag_bunchDetect && abs($tdone-$tdone_old) > 1.0 && $txfer_old != 0;
	     #  $bunchfiles++;
	     #  $bunchsize += $size;
	     #} else {
             #    $closedbunch=1;
	     #}
	     #printf("DEBUG: tdone-txfer %.5f   txfer-txfer_old %.5f    tdone-tdone_old %.5f  $from\n",$tdone - $txfer,
		#     $txfer-$txfer_old, $tdone-$tdone_old);
	     #($txfer_old,$tdone_old) = ($txfer,$tdone);

         } else {
             $statstr="FAILED";  #sprintf("FAILED(%4d)",$stat);
             $sitestat{"$from"}{"FAILED"}++;

	     # try to collect error information in categories. This needs to be extended for the myriad of SRM
	     # error messages ;-)
	     my ($detail,$validate) = $line =~ m/.*detail=\((.*)\)\s+validate=\((.*)\)\s*job-log.*$/;
	     die "DEBUG: no detail,validate IN LINE: \n     $line\n" if(! $detail && ! $validate);
	     if(! $flag_rawErrors) {
	       my $tmp;
	       # First some general substitution patterns to remove IDs, etc.
	       $detail = substr($detail,0,$errmsglen) . "...(error cut)" if length($detail) > $errmsglen;
	       $detail =~ s/\sid=[\d-]+\s/id=\[id\] /;
	       $detail =~ s/\sauthRequestID \d+\s/authRequestID \[id\] /;
	       $detail =~ s/RequestFileStatus#[\d-]+/RequestFileStatus#\[number\]/g;
	       $detail =~ s/srm:\/\/[^\s]+/\[srm-URL\]/;
	       $detail =~ s/at\s+\w{3}\s+\w{3}\s+\d+\s+\d+:\d+:\d+\s+[A-Z]+\s+\d+/at \[date\]/;

	       if( $detail=~/^\s*$/) {$reason = "-"}
	       elsif( (($reason) = $detail =~ m/.*(Failed DESTINATION error during FINALIZATION phase: \[GENERAL_FAILURE\] failed to complete PrepareToPut request.*)/) ) { $reason =~ s/request \[(-|\d)+\]/request [reqid]/ }
	       elsif( (($reason) = $detail =~ m/.*(the server sent an error response: 425 425 Can\'t open data connection).*/)) {}
	       elsif( (($reason) = $detail =~ m/.*(the gridFTP transfer timed out).*/) ) {}
	       elsif( (($reason) = $detail =~ m/.*(Failed SRM get on httpg:.*)/) ) {}
	       elsif( (($reason) = $detail =~ m/.*(Failed on SRM put.*)/) )
		 { $reason =~ s!srm://[^\s]+!\[srm-url\]!; }
	       elsif( (($reason,$tmp) = $detail =~ m/.*( the server sent an error response: 553 553)\s*[^\s]+:(.*)/) )
		 {$reason .= " [filename]: " . $tmp}
	       elsif( (($reason) = $detail =~ m/(.*Cannot retrieve final message from)/) )
		 {$reason .= "[filename]"}
	       #elsif( $detail =~ /.*RequestFileStatus.* failed with error.*state.*/)
		# {$reason = $detail; $reason =~ s/(.*RequestFileStatus).*(failed with error:).*(state.*)/$1 [Id] $2 $3/;}
	       elsif( $detail =~ /copy failed/ )
		 { $reason = $detail; $reason =~ s/at (\w{3} \w{3} \d+ \d+:\d+:\d+ \w+ \d+)/at \[date\]/g}
	       elsif( $detail =~ /state Failed : file not found/ )
		 { $reason = "file not found"; }
               elsif( $detail =~ /transfer expired in the PhEDEx download agent queue after [\d.]*h/ )
                 { $reason= "transfer expired in the PhEDEx download agent queue after [hours] h"; }
	       else {$reason = $detail};
	     } else {$reason = $detail};

	     if($reason eq "-") {
	       my $valreason;
	       $validate =~ s/srm:\/\/[^\s]+/\[srm-URL\]/g;
	       if( (($valreason) = $validate =~ m/.*(credential remaining lifetime is less then a minute).*/) ) {}
	       elsif( (($valreason) = $validate =~ m/.*(file \[srm-URL\] doesn\'t seem to exist).*/) ) {}
	       elsif( (($valreason) = $validate =~ m/.*(size mismatch disk=)\s+db=\d+.*/) )
		 { $valreason = "fake " . $valreason . " (nothing on disk)" }
	       elsif( (($valreason) = $validate =~ m/.*(size mismatch)\d+\s+db=\d+.*/) )
		 { $valreason .= " CHECK DB - MAY BE A CONSISTENCY ISSUE" }
	       else { $valreason = "[unknown reason - inspect log]"; }

	       $reason = "no detail - validate failed: $valreason";
	     }

	     if( $reason =~ /transfer expired/ or $reason =~ /^\s*Canceled/) {
	       $sitestat{"$from"}{"EXP"}++;
	       $statstr="EXP/CNCL";
	       $failedfile{"$fname"}{$from}{"exp"}++ if $flag_multiFailures;
	     } else {
	       $failedfile{"$fname"}{$from}{"err"}++ if $flag_multiFailures;
	     }
	     if($flag_multiFailures) {
	       $failedfile{"$fname"}{$from}{"reason"}{$reason}++;
	       ($failedfile{"$fname"}{$from}{"frompfn"}) = $line =~ m/from-pfn=([^\s]*)\s+to-pfn/;
	     }
	     $errinfo{$from}{$reason}{num}++;
	     push @{$errinfo{$from}{$reason}{tasks}},$task;
	     push @{$errinfo{$from}{$reason}{time}},$epdate if $flag_errhisto;

         }

#         ($date_old,$from_old,$ttransfer_old)=($date,$from,$ttransfer);


	 if($closedbunch) {
	   $ttransfer = $tdone_old - $txfer_old;
	   die "ERROR: ttransfer=0 ?????? in line:\n $line\n" if $ttransfer == 0;
	   $MbperS=$bunchsize*8/$ttransfer/1e6;
	   $MBperS=$bunchsize/1024/1024/$ttransfer;
	   printf("   *** Bunch:  succ. files: $bunchfiles  size=%.2f GB  transfer_time=%.1f s (%.1f MB/s = %.1f Mb/s)\n"
		  ,$bunchsize/1024/1024/1024,$ttransfer,$MBperS,$MbperS) if $flag_debug && $flag_bunchDetect;

	   $bunchfiles = 1;
	   $bunchsize = $size;
	 }
	 printf("$statstr $from  $fname  size=%.2f GB $date\n",$size/1024/1024/1024)  if $flag_debug;

   }  #while line=<LOG>

   close LOG;

} #foreach log

$dateend = $epdate;

open XML, ">$logx" or die "Cannot open $logx";
print XML "<InspectPhedexLog start=\"",strftime("%Y-%m-%d %H:%M:%S",localtime($datestart)),"\" end=\"",strftime("%Y-%m-%d %H:%M:%S",localtime($dateend)), "\">\n";

if ($flag_multiFailures) {
    print XML "<MultiFailures n_distinct=\"",scalar keys(%failedfile),"\">\n";

    my %total;
    foreach my $fname (keys %failedfile) {
	foreach my $from (keys %{$failedfile{$fname}}) {
	    $total{$fname}{"err"} += $failedfile{$fname}{$from}{"err"};
	    $total{$fname}{"exp"} += $failedfile{$fname}{$from}{"exp"};
	}
    }
    print "\nRepeatedly failing files that never were transferred correctly:\n";
    print   "===============================================================\n";
    print(" real errors  [incl. expired/cancl]\n");
    foreach my $fname (sort {$total{$b}{"err"} <=> $total{$a}{"err"}} keys %total) {
	next if $multiFilePrintThresh > $total{"$fname"}{"err"}+$total{"$fname"}{"exp"};
	printf(" %3d [%2d] $fname\n",$total{"$fname"}{"err"},
	       $total{"$fname"}{"err"}+$total{"$fname"}{"exp"});
        print XML "<file err_real=\"$total{$fname}{err}\" err_exp_canc=\"",($total{"$fname"}{"err"}+$total{"$fname"}{"exp"}), "\" lfn=\"$fname\">";

	if($flag_verbose) {
	    foreach my $from (keys %{$failedfile{$fname}}) {
		print "        from $from\n";
		print "        pfn=$failedfile{$fname}{$from}{frompfn}\n";
                print XML "\n<site name=\"$from\" pfn=\"$failedfile{$fname}{$from}{frompfn}\">\n";
		foreach $reason (sort { $failedfile{$fname}{$from}{"reason"}{$b} <=> $failedfile{$fname}{$from}{"reason"}{$a} }
				 keys %{$failedfile{$fname}{$from}{"reason"}}) {
		    printf("        %4d   $reason\n",$failedfile{$fname}{$from}{"reason"}{$reason});
		    print XML "<reason n=\"$failedfile{$fname}{$from}{reason}{$reason}\">\n$reason\n</reason>\n";
		}
		print XML "</site>\n";
	    }
	}
	print "\n";
        print XML "</file>\n";
    }

    print XML "</MultiFailures>\n";

    print "\nNumber of distinct files that failed: " . keys(%failedfile) . "\n";
    print "--------------------------------------------------------\n";

    print "\nHistogram of failed attempts per file until successful transfer:\n";
    print "--------------------------------------------------------\n";
    print "   Attempts     real errors     [incl. expired/cancl]\n\n";

    print XML "<Histo>\n";
    
    foreach my $from (sort {$a cmp $b} keys %attempts) {
	print "   $from:\n";
        print XML "<site name=\"$from\">\n";
	$attempts{$from}{"toterr"}{"0"}=$sitestat{$from}{"OK"};
	foreach my $n (sort {$a <=> $b} keys %{$attempts{$from}{"toterr"}}) {
	    printf("    %3d  %4d   [%4d]\n",$n,$attempts{$from}{"toterr"}{$n}-
		   $attempts{$from}{"exp"}{$n},$attempts{$from}{"toterr"}{$n});
	    print XML sprintf("<data attempts=\"%d\" real_err=\"%d\"  total_err=\"%d\"/>\n",$n,$attempts{$from}{"toterr"}{$n}-$attempts{$from}{"exp"}{$n},$attempts{$from}{"toterr"}{$n});
	}
	print XML "</site>\n";
    }
    print XML "</Histo>\n";
}

if($flag_showErrors) {
    print "\n\n==============\n";
    print "ERROR ANALYSIS\n";
    print "==============\n";
    
    print XML "<ErrorAnalysis>\n";

    print "\n\nData base Errors\n";
    print "==================\n";
    print XML "<DataBaseErrors>\n";

    foreach my $err (keys %dberrinfo) {
	printf("   %3d  $err\n",$dberrinfo{$err}{num});
	my $h=simpleHisto(\@{$dberrinfo{$err}{"date"}},10);
	printTimeHisto($h);
	$err = HTML::Entities::encode($err);
	print XML "<error n=\"$dberrinfo{$err}{num}\">\n$err\n</error>\n";
    }

    print XML "</DataBaseErrors>\n";

    print "\n\nError message statistics per site:\n";
    print "===================================\n";
    print XML "<ErrorPerSite>\n";
    foreach $from (keys %errinfo) {
	print "\n *** ERRORS from $from:***\n";
	print XML "<site name=\"$from\">\n";
	foreach $reason (sort { $errinfo{$from}{$b}{num} <=> $errinfo{$from}{$a}{num} } keys %{$errinfo{$from}}) {
            printf("   %4d   $reason\n",$errinfo{$from}{$reason}{num});
	    print "             task IDs: ", join(",",@{$errinfo{$from}{$reason}{tasks}}) . "\n\n" if $flag_verbose;
	    print XML "<reason n=\"$errinfo{$from}{$reason}{num}\">\n$reason\n<\/reason>\n";
	    if($flag_errhisto) {
		my $h=simpleHisto(\@{$errinfo{$from}{$reason}{"time"}},10);
		print "      simple histogram:\n";
		printTimeHisto($h);
	    }
	}
        print XML "</site>\n";
    }
    print XML "</ErrorPerSite>\n";
    print XML "</ErrorAnalysis>\n";    
}

print "\nSITE STATISTICS:\n";
print "==================\n";
print XML "<SiteStat>\n";

if ($dateend ==0) {
    print "   No transfer entries found ($datestart, $dateend)\n";
    print XML '</InspectPhedexLog>', "\n"; close XML;
    exit 0;
}

printf("                         first entry: %s      last entry: %s\n",
       strftime("%Y-%m-%d %H:%M:%S",localtime($datestart)),
       strftime("%Y-%m-%d %H:%M:%S",localtime($dateend)));

my ($MbperS,$MBperS);
my $totalsize=0;
foreach my $site (sort {$a cmp $b} keys %sitestat) {
    $sitestat{$site}{"OK"}=0 if ! defined $sitestat{$site}{"OK"};
    $sitestat{$site}{"FAILED"}=0 if ! defined $sitestat{$site}{"FAILED"};
    $sitestat{$site}{"EXP"}=0 if ! defined $sitestat{$site}{"EXP"};

    my $err = $sitestat{$site}{"FAILED"} - $sitestat{$site}{"EXP"};
    print "site: $site (OK: " . $sitestat{$site}{"OK"} . "   Err: " . $err
	. "   Exp/Canceled: " . $sitestat{$site}{"EXP"} . ")";
    print XML qq{<site name="$site" ok="$sitestat{$site}{"OK"}" err="$err" exp_cancelled="$sitestat{$site}{"EXP"}"};

    if (($sitestat{$site}{"OK"}+$sitestat{$site}{"FAILED"}) > 0) {
        my $succ = $sitestat{$site}{"OK"}/($sitestat{$site}{"OK"}+$sitestat{$site}{"FAILED"}-$sitestat{$site}{"EXP"})*100;
        printf("\tsucc. rate: %.1f %%", $succ);
        print XML sprintf(" succ_percent=\"%.1f\"", $succ);
    }

    $sitestat{$site}{"size"}=0 if ! exists $sitestat{$site}{"size"};
    $totalsize+=$sitestat{$site}{"size"};
    printf("   total: %.1f GB",$sitestat{$site}{"size"}/1e9);
    print XML sprintf(" stotal_gb=\"%.1f\"",$sitestat{$site}{"size"}/1024/1024/1024);

    if ( exists $sitestat{$site}{"ttransfer"} && $sitestat{$site}{"ttransfer"}>0) {
      $MbperS=$sitestat{$site}{"size"}*8/$sitestat{$site}{"ttransfer"}/1e6;
      $MBperS=$sitestat{$site}{"size"}/1024/1024/$sitestat{$site}{"ttransfer"};
      printf("   avg. rate: %.1f MB/s = %.1f Mb/s",$MBperS,$MbperS) if $flag_bunchDetect;
      print XML sprintf("avg_rate_mbyte_s=\"%.1f\" avg_rate_mbit_s=\"%.1f\"",$MBperS,$MbperS) if $flag_bunchDetect;
    }
    print "\n";
    print XML "/>\n";
}

print XML "</SiteStat>\n";

# Calculate total throughput from first to last used log entry
my $deltat=$dateend-$datestart;
if($deltat>0) {
    $MbperS=$totalsize/(1024*1024)*8/$deltat;
    $MBperS=$totalsize/(1024*1024)/$deltat;
    my $GBperDay=$MBperS/1024*3600*24;
    
    print "\nTOTAL SUMMARY:\n";
    print "==================\n";
    printf("                         first entry: %s      last entry: %s\n",
          strftime("%Y-%m-%d %H:%M:%S",localtime($datestart)),
          strftime("%Y-%m-%d %H:%M:%S",localtime($dateend)));
    printf("total transferred: %.1f GB  in %.1f hours\n",$totalsize/(1024*1024*1024),
	   $deltat/3600);
    printf("avg. total rate: %.1f MB/s = %.1f Mb/s  = %.1f GB/day\n",$MBperS,$MbperS,$GBperDay);

    print XML '<Total ', sprintf("volume_gb=\"%.1f\" time_h=\"%.1f\" ",$totalsize/(1024*1024*1024),$deltat/3600);
    print XML sprintf("agv_total_rate_mbyte_s=\"%.1f\" agv_total_rate_mbit_s=\"%.1f\" agv_total_rate_gb_day=\"%.1f\" />\n",$MBperS,$MbperS,$GBperDay);
}

print XML '</InspectPhedexLog>',"\n";
close XML;

# simple 1D histo
sub simpleHisto {
  my $data = shift; # ref to array of data values
  my $nbins = shift; # number of desired bins

  return undef if $#{@{$data}} < 0;

  my %histo;  # return structure
  my @h=();
  my @xlabel=();

  my $min=@{$data}[0];
  my $max=@{$data}[0];
  foreach my $x (@{$data}) {
    if($x < $min) {
      $min = $x;
      next;
    }
    $max = $x if $x > $max;
  }

  if ($#{@{$data}}==0) {
  }

  if($max==$min) {
    push @h,$#{@$data} + 1;
    push @xlabel,$min;
    %histo=( "value"=> \@h,
	     "xlabel"=> \@xlabel,
	     "binsize"=> undef
	   );
    return \%histo;
  }

  my $binsize = ($max-$min)/$nbins;
  if ($binsize <=0) {
    print STDERR "Error: Binsize=$binsize,  min=$min   max=$max  # datapoints:". $#{@{$data}}+1 . " nbins=$nbins\n";
    print "DATA: " . join(", ",@{$data}) . "\n";
    return undef;
  }

  for(my $n=0; $n<$nbins; $n++) {
    $xlabel[$n] = $min + ($n+0.5) * $binsize;
    $h[$n]=0;
  }

  my $bin;
  foreach my $x (@{$data}) {
    $bin = int(($x - $min)/$binsize);
    $h[$bin]++;
  }

  # need to add topmost bin to bin n-1
  $h[$nbins-1] += $h[$nbins];
  pop @h;

  $histo{value}=\@h;
  $histo{xlabel}=\@xlabel;
  $histo{binsize}=$binsize;

  return \%histo;
}

sub printTimeHisto {
  my $h = shift;

  for(my $i=0;$i<= $#{@{$h->{value}}};$i++) {
    printf("     %6d   %s\n",$h->{value}[$i],    strftime("%Y-%m-%d %H:%M:%S",localtime($h->{xlabel}[$i])));
  }
}



# This function I use to replace ParseDateString of
# Date::Manip.
# It can handle these formats:

# my @tests= ("2007-05-08 09:28:22","1970-01-01 00:00:00",
#	    "2007-05-08",
# 	    "-4hours","- 1 hour",
# 	    "-1 day", "-3days",
# 	    "now","yesterday"
# 	    );
sub DateToUnixEpochSeconds {
    my $date = shift;

    my $unixs=undef;
    my ($Y,$M,$D,$h,$m,$s)=(0,0,0,0,0,0);

    if( (($Y,$M,$D,$h,$m,$s) = $date =~ m/\s*(\d+)-(\d+)-(\d+)\s*(\d+)?:?(\d+)?:?(\d+)?/) ) {
	die "strange month number in date ($M)? Date was: $date\n"if $M < 0 or $M >12;
	$unixs=strftime("%s",$s, $m, $h, $D, $M-1, $Y-1900, -1, -1, -1);
    } elsif( (($D) = $date =~ m/\s*-\s*(\d+)\s*day/) ) {
	$unixs = time() - 24*3600*$D;
    } elsif( (($h) = $date =~ m/\s*-\s*(\d+)\s*hour/) ) {
	$unixs = time() - 3600*$h;
    } elsif( (($m) = $date =~ m/\s*-\s*(\d+)\s*min/) ) {
	$unixs = time() - 60*$m;
    } elsif( $date =~ /^\s*now\s*$/) {
	$unixs = time();
    } elsif( $date =~ /^\s*yesterday\s*$/) {
	$unixs = time() - 24*3600;
    } else {
	die "Error: Unknown date format: $date\n";
    }
    return $unixs;
}
